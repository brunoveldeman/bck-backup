#! /usr/bin/perl --
# bck-backup.
# Written & parts copyright by : Bruno Veldeman
#
# To simplify use, some modified modules have been copied into the code, this way no extra modules have to be installed.
# I'll check these modules from time to time to ensure they stay more or less up to date. (Mail::Sendmail[2.09], Config::Inifiles[2.52])
#
#################################################################################
#										#
#   This program is free software: you can redistribute it and/or modify	#
#   it under the terms of the GNU General Public License as published by	#
#   the Free Software Foundation, either version 3 of the License, or		#
#   (at your option) any later version.						#
#										#
#   This program is distributed in the hope that it will be useful,		#
#   but WITHOUT ANY WARRANTY; without even the implied warranty or		#
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		#
#   GNU General Public License for more details.				#
#										#
#   You should have received a copy of the GNU General Public License		#
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.	#
#										#
#################################################################################
#
#
use warnings;
use strict;
use English;
use Config;
# Program version
my( $version ) = "3.0.0";
# Exit state variable
my( $state ) = 0;
# Evaluate the command line parameters
my $cmdln =  eval { new CommandLine(); }  or die ($@);
$cmdln->ParseCommandLine();
####################################
# Look for flags
if ( $cmdln->GetHelpFlag )
{
	&PrintHelp( $cmdln->GetHelpFlag );
	exit(0);
};
if ( $cmdln->GetVersionFlag )
{
	&PrintVersion;
	exit(0);
};
if ( $cmdln->GetCheckFlag )
{
	&CheckConfig( $cmdln->GetConfigFileName );
	exit(0);
};
if ( $cmdln->GetInstallFlag )
{
	&CreateConfig( $cmdln->GetConfigFileName );
	exit(0);
};
if ( $cmdln->GetUpdateFlag )
{
	&Update( $cmdln->GetConfigFileName );
	exit(0);
};

#Load global section
my $gsection = eval { new GlobalSection(); } or die ($@);
if ( $cmdln->GetHttpFlag )
{
	my $web = new HttpServer();
	$web->SetConfigfile( $cmdln->GetConfigFileName );
	$web->Start( $cmdln->GetHttpFlag );
	exit(0);
};
if ( defined $cmdln->GetDo() )
{
	$state = &Main;
};
if ( $cmdln->GetReportFlag )
{
	CommReports();
};
if ( $cmdln->GetMailFlag )
{
	MailReports();
};
exit($state);
#
##################################################################################
#
# Sub Main
#
##################################################################################
sub Main # () -> ()
{
	my ( $cfg, $mastercfg );
	my ( $lang ) = undef;
	my ( $publicip, $line );
	my ( $logdate ) = GetLogDate();
	my $starttime = time();
	my ( @logfiles );
	my ( @filelist );
	my ( $globalstatus ) = 0;
	my ( $configfilename ) = $cmdln->GetConfigFileName;
	if ( -e $configfilename )
	{
		if ( -r "/etc/bck/bck.default" )
		{
			$mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			$cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg = Config::IniFiles->new( -file => $configfilename );
		};
	};
	if ( defined $cfg)
	{
		$publicip = &GetIP( $gsection->GetIpWebAddress() );
		my ( @dolist ) = split( /,/,$cmdln->GetDo() );
		my ( $seconds );
		my ( $entry );
		foreach $entry (@dolist)
		{
			my $section = eval { new DoSection(); } or die ($@);
			$section->SetSection( $entry );
			$section->SetLogDate( $logdate );
			$section->SetDebug( $cmdln->GetDebugFlag() );
			$section->SetVerbose( $cmdln->GetVerboseFlag() );
			$section->WriteLog( "START ************ bck version " . $version . " *************", 1 );
			$section->WriteLog( "Start time : local : " . &GetTime() . " ntp : " . &GetNtpTime( $gsection->GetNtpServer() ) , 1 ) ;
			$section->WriteLog( "Running on : " . $Config{'osname'} . " / " . $Config{'osvers'} . " [" . $Config{'archname'} . "] , Perl version : v" . $Config{'PERL_REVISION'} . "." . $Config{'PERL_VERSION'} . "." . $Config{'PERL_SUBVERSION'} , 1 );
			$section->WriteLog( "Client : " . $gsection->GetClient() . " / Public IP Address : $publicip", 1 );
			if ( $section->LoadSection( $cmdln->GetConfigFileName() ) == 0 )
			{
				my ( $status, $errortext, $warningtext ) = $section->Run();
				if ( $status == 0 )
				{
					#section ok
					$section->WriteLog( "Section [" . $section->{_section} . "]  (" . &HumanBytes( $section->GetSize() )  . ") ok." , 1);
					$section->WriteDb();
				}
				else
				{
					#section not ok
					$section->WriteLog( "Section [" . $section->{_section} . "]  (" . &HumanBytes( $section->{_size} ) . ") errors/warnings." , 1);
					$section->WriteDb();
				};
			}
			else
			{
				#section does not exist
				$section->WriteLog( "Section [" . $section->{_section} . "] does not exist." , 1);
				$section->WriteDb();
			};
			$section->WriteLog( "End time : " . &GetTime() , 1 );
			$seconds = (time() - $starttime);
			my ( $timestr ) =  sprintf("%02d:%02d:%02d", ($seconds/(60*60))%24 , ($seconds/60)%60 ,  $seconds%60 );
			$section->WriteLog( "Total time elapsed (hh:mm:ss): " . $timestr , 1 );
			$section->WriteLog( "END   ************ bck version " . $version . " *************", 1 );
		};
	}
	else
	{
		#Configuration file error
	};
	return(0);
};
##################################################################################
#
# Sub MailReports :
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub MailReports
{
	my ( $cfg, $mastercfg );
	my ( $lang ) = undef;
	my ( $publicip);
	my ( $logdate ) = GetLogDate();
	my $starttime = time();
	$publicip = &GetIP( $gsection->GetIpWebAddress() );
	my ( $configfilename ) = $cmdln->GetConfigFileName;
	if ( -e $configfilename )
	{
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
	};
	if ( defined $cfg)
	{
		my ( $dbfile ) = $cmdln->GetStatusFileName;
		my ( $report ) = Report->new();
		$report->SetTittle( "Backup report." );
		$report->SetIP( $publicip );
		my ( @mails ) = $cfg->Parameters( "mail" );
		my ( $mail );
		foreach $mail ( @mails )
		{
			my ( $maillvl, $mailmode ) = split( /,/, $cfg->val( "mail", $mail ) );
			if ( not defined $mailmode )
			{
				$mailmode = "html and plain";
			};
		$report->AddMail( $mail, $maillvl, $mailmode );
		};
		my ( $line, $date );
		my ( $reportstatus ) = 0;
		my ( $db ) = DbFile->new();
		$db->SetFile( $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' );
		# Get an array with lines that have the mail bit set to 0, mailbit = 0
		my ( @lines ) = $db->FindLines( 0, 0 );
		foreach $line ( @lines )
		{
			chomp( $line );
			# Clean up the line
			$line = StrCl( $line );
			my ( $id, $statusbits, $section, $name, $timestamp, $stat, $size, $destsize, $destfree, $infotext ) = split( /,/,$line );
			# Check values in db file
			if ( !defined $section ) { $section = 0 };
			if ( !defined $name ) { $name = 0 };
			if ( !defined $timestamp ) { $timestamp = 0 };
			if ( !defined $stat ) { $stat = 0 };
			if ( !defined $size ) { $size = 0 };
			if ( !defined $destsize ) { $destsize = 0 };
			if ( !defined $destfree ) { $destfree = 0 };
			$infotext = StrCl( $infotext );
			# End check values
			if ( $stat eq "Warning" )
			{
				if ( $reportstatus < 1 )
				{
					$reportstatus = 1;
				};
			}
			elsif ( $stat eq "ERROR" )
			{
				$reportstatus = 2;
			};
			$report->AddTable( $section, $name, $timestamp, $stat, $size, $destsize, $destfree, $infotext );
		};
		$report->SetState( $reportstatus );
		my ( $mailstatus ) = $report->SendReports();
		if ( $mailstatus == 0 )
		{
			# Update statusbit for mail at position "0" to "1", pass the array as reference.
			$db->UpdateStatusBits( 0, 1, \@lines );
		};
		return(0);
	};
};
##################################################################################
#
# Sub CommReports :
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub CommReports # () -> ()
{
	use Socket;
	my ( $response, $myip );
	my ( $peer, $address );
	my ( $cfg, $mastercfg ) = undef;
	my ( $lang ) = undef;
	my ( $publicip);
	my ( $logdate ) = GetLogDate();
	my $starttime = time();
	my ( $rsection ) = ReportSection->new();
	$publicip = &GetIP( $gsection->GetIpWebAddress() );
	my ( $configfilename ) = $cmdln->GetConfigFileName;
	if ( -e $configfilename )
	{
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
	};
	if ( defined $cfg)
	{
		my ( $dbfile ) = $cmdln->GetStatusFileName;
		my ( $date );
		my ( $reportstatus ) = 0;
		my ( $db ) = DbFile->new();
		$db->SetFile( $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' );
		# Get an array with lines that have the report bit set to 0, reportbit = 1
		my ( @lines ) = $db->FindLines( 1, 0 );
		my ( $numlines ) = scalar @lines;
		foreach my $line ( @lines )
		{
			chomp( $line );
			# Clean up the line
			$line = StrCl( $line );
			my ( $id, $mailed, $section, $name, $timestamp, $stat, $size, $destsize, $destfree, $infotext ) = split( /,/,$line );
			# check values in db file
			if ( !defined $section ) { $section = 0 };
			if ( !defined $name ) { $name = 0 };
			if ( !defined $timestamp ) { $timestamp = 0 };
			if ( !defined $stat ) { $stat = 0 };
			if ( !defined $size ) { $size = 0 };
			if ( !defined $destsize ) { $destsize = 0 };
			if ( !defined $destfree ) { $destfree = 0 };
			$size = NumCl( $size );
			$destsize = NumCl( $destsize );
			$destfree = NumCl( $destfree );
			$infotext = StrCl( $infotext );
			if ( $stat eq "Warning" )
			{
				if ( $reportstatus < 1 )
				{
					$reportstatus = 1;
				};
			}
			elsif ( $stat eq "ERROR" )
			{
				$reportstatus = 2;
			};
		};
		my ( $password ) = $rsection->GetPassword();
		my ( $host ) = $rsection->GetServer();
		my ( $port ) = $rsection->GetPort;
		$address = inet_aton( $host );
		if ( not defined $address )
		{
			return(0);
		}
		else
		{
			$peer = sockaddr_in( $port, $address );
			socket( S, PF_INET, SOCK_STREAM, getprotobyname('tcp') ) or die "Socket: $!";
			connect( S, $peer ) or die "Connect: $!";
			select ( S );
			$|=1;
			print S "bck . .\n";
			select ( STDOUT );
			{
				while ( sysread( S, my $buff, 1 ) )
				{
					last if ( $buff eq "\n" );
					$response .= $buff;
				};
				# Get the seed to create the password
				# Skip the first 3 chars as this is bck
				my ( $seed ) = StrCl( substr( $response, 3 ) );
				my  ( $auth ) = crypt( $password, $seed );
				select ( S );
				print S "bck$auth\n";
				foreach my $line ( @lines )
				{
					my ( $id, $statusbits, $section, $name, $timestamp, $stat, $size, $destsize, $destfree, $infotext ) = split( /,/,$line );
					my ( $repline ) = $statusbits . "," . $section . "," . $name . "," . $timestamp . "," . $stat . "," . $size . "," . $destsize . "," . $destfree . "," . $infotext;
					print S "$repline\n";
				};
				my ( $statusbits ) = 132 | ( $reportstatus << 3 );
				my ( $headerline ) = "$statusbits," . $publicip . "," . $gsection->GetClient() . "," . time . ",Remote,0,0,0";
				print S "$headerline\n";
				print S "bck/END/\n";
				$response = "";
				while ( sysread( S, my $buff, 1 ) )
				{
					last if ( $buff eq "\n" );
					$response .= $buff;
				};
				close S;
				select ( STDOUT );
				chomp( $response );
				$response = StrCl( $response );
			};
		};
		if ( ( $response ne "bck00" ) and ( $response ne "" ) )
		{
			# Update statusbit for comm at position "1" to "1", pass the array as reference.
			$db->UpdateStatusBits( 1, 1, \@lines );
		};
		return(0);
	};
};
##################################################################################
#
# Sub GetIP :
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub GetIP # (webaddress) -> (myip)
{
	use Socket;
	my ( $webaddress ) = @_;
	my ( $response, $myip );
	my ( $peer, $address );
	# Return empty IP string if no webaddress is passed
	return ("---.---.---.---") unless $webaddress;
	# Clean up the $webaddress string
	$webaddress =~ s/[^\w\.-\/]//g;
	my ( $host , $page ) = split( /\//, $webaddress, 2 );
	$page = "" unless $page;
	$address = inet_aton( $host );
	if ( not defined $address )
	{
		$myip = "Cannot connect!";
	}
	else
	{
		$peer = sockaddr_in( 80, $address );
		socket( S, PF_INET, SOCK_STREAM, getprotobyname('tcp') ) or return ("---.---.---.---");
		connect( S, $peer ) or return ("---.---.---.---");
		select(S);
		$|=1;
		print S "GET /$page HTTP/1.1\r\n";
		print S "Host: $host\r\n";
		print S "Accept: text/html\r\n";
		print S "Connection: close\r\n\r\n";
		select STDOUT;
		{
			while ( defined ( my $line = <S> )  )
				{
				chomp($line);
				$response .= $line;
				}
			close S;
		};
		$response =~ m/([\d]+\.[\d]+\.[\d]+\.[\d]+)/;
		if (defined ( $1 ) )
			{
			$myip = $1;
		}
		else
		{
		$myip = "---.---.---.---";
		};
	};
	return ($myip);
};
##################################################################################
#
# Sub HumanBytes :
# 
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub HumanBytes
{
	my ( $bytes ) = @_;
	my ( $output );
	#byte	  B
	#kilobyte  K = 2**10 B = 1024 B
	#megabyte  M = 2**20 B = 1024 * 1024 B
	#gigabyte  G = 2**30 B = 1024 * 1024 * 1024 B
	#terabyte  T = 2**40 B = 1024 * 1024 * 1024 * 1024 B
	#petabyte  P = 2**50 B = 1024 * 1024 * 1024 * 1024 * 1024 B
	#exabyte   E = 2**60 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
	#zettabyte Z = 2**70 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
	#yottabyte Y = 2**80 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
	if ( defined $bytes and ( $bytes != 0 ) )
	{
		if ( $bytes > ( 2 ** 80 ) )
		{
			$output = sprintf("%.2f YB",( $bytes / ( 2 ** 80 ) ) );
		}
		elsif ( $bytes > ( 2 ** 70) )
		{
			$output = sprintf("%.2f ZB",( $bytes / ( 2 ** 70 ) ) );
		}
		elsif ( $bytes > ( 2 ** 60) )
		{
			$output = sprintf("%.2f EB",( $bytes / ( 2 ** 60 ) ) );
		}
		elsif ( $bytes > ( 2 ** 50) )
		{
			$output = sprintf("%.2f PB",( $bytes / ( 2 ** 50 ) ) );
		}
		elsif ( $bytes > ( 2 ** 40) )
		{
			$output = sprintf("%.2f TB",( $bytes / ( 2 ** 40 ) ) );
		}
		elsif ( $bytes > ( 2 ** 30) )
		{
			$output = sprintf("%.2f GB",( $bytes / ( 2 ** 30 ) ) );
		}
		elsif ( $bytes > ( 2 ** 20) )
		{
			$output = sprintf("%.2f MB",( $bytes / ( 2 ** 20 ) ) );
		}
		elsif ( $bytes > ( 2 ** 10) )
		{
			$output = sprintf("%.2f KB",( $bytes / ( 2 ** 10 ) ) );
		}
		else
		{
			$output = sprintf("%.0f B",( $bytes ) );
		};
	}
	else
	{
		$output = "-"
	};
	return( $output );
};
##################################################################################
#
# Sub StrCl : Check a string so it is valid input. Only let alfanum and a few 
#             harmless chars through, if undefined, return a space so things won't
#             break
#
##################################################################################
sub StrCl # ( string ) -> ( clean string )
{
	my ( $string ) = shift;
	# If undefined, make it one space.
	$string = " " unless $string;
	# Remove al chars exept a-z 0-9 A-Z , . _ - : ; and space
	$string =~ s/[^\w\,\.-:;\s]//g;
	return ( $string );
};
##################################################################################
#
# Sub NumCl : Check a number so it is valid input. Only let numbers through, if 
#             undefined, return a 0 so things won't break
#
##################################################################################
sub NumCl # ( num ) -> ( clean num )
{
	my ( $num ) = shift;
	# If undefined, make it 0
	$num = 0 unless $num;
	# Remove al chars exept 0-9
	$num =~ s/[^\d]//g;
	# If we end up with an empty value, make it 0
	$num = 0 unless ( $num ne "" );
	return ( $num );
};
##################################################################################
#
# Sub NumNz : Check a number so it is valid input. Only let numbers through, if 
#             undefined or 0, return a 1 so things won't break
#
##################################################################################
sub NumNz # ( num ) -> ( clean num )
{
	my ( $num ) = shift;
	# If undefined, make it 0
	$num = 1 unless $num;
	# Remove al chars exept 0-9
	$num =~ s/[^\d]//g;
	# If we end up with an empty value, make it 0
	$num = 0 unless ( $num ne "" );
	$num = 1 unless ( $num ne 0  );
	return ( $num );
};
##################################################################################
#
# Sub GetTime :
#
##################################################################################
sub GetTime # () -> (mytime)
{
	my ($mytime);
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	$mytime = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . sprintf( "%02d:%02d:%02d" , $hour, $min, $sec ) . " (" . ($wday) . ")";
	return ($mytime);
};
##################################################################################
#
# Sub GetNtpTime : Get time from time server
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub GetNtpTime # (ntpservername) -> (mytime)
{
	use Socket;
	my ( $ntpserver, $ntpport ) = @_;
	my ( $mytime, $buflen, $sndmsg, $ttime ,$ipaddr, $portaddr, @response );
	# If no server name or address is passed, return emty time string
	return ( "-/-/---- --:--:-- (-)" ) unless $ntpserver;
	$ntpserver = StrCl( $ntpserver );
	# If no port is given, we use the standard port.
	$ntpport = 123 unless $ntpport;
	# Clean up the number
	$ntpport = NumCl( $ntpport );
	$buflen = 1024;
	my ( $retry ) = 3;
	my ( $timeout ) = 3;
	while ( $retry gt 0 )
	{
		eval
		{
			local $SIG{ALRM} = sub { die print "timeout" };
			$retry--;
			alarm( $timeout );
			socket( SOCKET, PF_INET, SOCK_DGRAM, getprotobyname( "udp" ) );
			$ipaddr = inet_aton( $ntpserver );
			if ( defined $ipaddr )
			{
				$portaddr = sockaddr_in( $ntpport, $ipaddr );
				# We send a message
				$sndmsg="\010"."\0"x47;
				send(SOCKET, $sndmsg, 0, $portaddr);
				$portaddr = recv(SOCKET, $sndmsg, $buflen, 0);
				# We receive the time message
				@response = unpack("N12",$sndmsg);
				$ttime = $response[10];
				# Since ntp starts counting on 1/1/1900 and unix starts on 1/1/1970, we substract the seconds needed.
				$ttime -= ( ( 1970 - 1900 ) * ( 365 * 24 * 60 * 60 ) + ( int ( ( 1970 - 1900 ) / 4 ) * 24 * 60 * 60 ) );
				# Now we put it in a human readable format.
				my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( $ttime );
				$mytime = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . sprintf( "%02d:%02d:%02d" , $hour, $min, $sec ) . " (" . ($wday) . ")";
			};
			alarm(0);
		};
		last;
	};
	if ( $@ )
	{
		return ( "-/-/---- --:--:-- (-)" );
	}
	else
	{
		return ($mytime);
	};
};
##################################################################################
#
# Sub GetLogDate : Date/time format for log files
#
##################################################################################
sub GetLogDate # () -> (mydate)
{
	my ( $mytime );
	$mytime = time;
	return ( $mytime );
};
##################################################################################
#
# Sub CheckConfig :
#
##################################################################################
sub CheckConfig # ($configfilename) -> ()
{
	use File::Path;
	my ( $configfilename ) = @_;
	my ( $line, $testmail );
	$testmail = 0;
	use Socket;
	use MIME::Base64;
	print "bck version : $version\n";
	print "   Checking configuration file...\n";
	if (-r $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
		unless ($cfg)
		{
			print "   Error in loading configuration file `$configfilename'\n";
			foreach $line ( @Config::IniFiles::errors )
			{
			print "	  $line .\n";
			};
		}
		else
		{
			print "   Configuration file structure OK.\n";
			print "   Checking configuration.\n";
			print "   Global variables :\n";
			my ($lang)		= $cfg->val('global', 'lang');
			my ($client)	= $cfg->val('global', 'client');
			my ($sysloglevel) = $cfg->val('global', 'sysloglevel');
			my ($smtpserver) = $cfg->val('global', 'smtpserver');
			my ($smtpuser)	= $cfg->val('global', 'smtpuser');
			my ($smtppass)	= $cfg->val('global', 'smtppass');
			my ($smtpfrom)	= $cfg->val('global', 'smtpfrom');
			my ($smtpport)	= $cfg->val('global', 'smtpport');
			my ($ntpserver)	= $cfg->val('global', 'ntpserver');
			my ($ipwebaddress)	= $cfg->val('global', 'ipwebaddress');
			my ($logdir)	= $cfg->val('global', 'logdir');
			my ($dbdir)		= $cfg->val('global', 'dbdir');
			my ($tempdir)	= $cfg->val('global', 'tempdir');
			my ($oktag)		= $cfg->val('global', 'oktag');
			my ($errortag)	= $cfg->val('global', 'errortag');
			my ($warningtag) = $cfg->val('global', 'warningtag');
			# Tests
			if ( defined $lang)
			{
				print "	 lang ok.\n";
			}
			else
			{
				print "	#lang not defined\n";
			};
			if ( defined $client)
			{
				print "	 client ok.\n";
			}
			else
			{
				print "	#client not defined\n";
			};
			if ( defined $sysloglevel)
			{
				if ( ($sysloglevel >= 0) and ($sysloglevel <= 5) )
				{
					print "	 sysloglevel ok.\n";
				}
				else
				{
					print "	#sysloglevel out of range\n";
				}
			}
			else
			{
				print "	#sysloglevel not defined\n";
			};
			if ( defined $smtpserver )
			{
				print "	 smtpserver ok.\n";
			}
			else
			{
				print "	#smtpserver not defined\n";
			};
			if ( defined $smtpport)
			{
				my ( $iaddr, $paddr, $proto, $timeout );
				$timeout = 3;
				$testmail = 0;
				if ( defined ($smtpserver) )
				{
					print "	 smtpport ok.\n	 -testing connection.\n";
					if ( $iaddr  = inet_aton($smtpserver) )
					{
						#It worked
						$paddr = sockaddr_in($smtpport, $iaddr);
						$proto = getprotobyname('tcp');
						if ( socket(SOCK, PF_INET, SOCK_STREAM, $proto) )
						{
							#It worked
							eval {
							  local $SIG{ALRM} = sub { die "timeout" };
							  alarm($timeout);
							  connect(SOCK, $paddr) || error();
							  alarm(0);
							};
							if ($@) {
							  close SOCK || die "close: $!";
							  print "	#--$smtpserver is NOT listening on tcp port $smtpport.\n";
							}
							else {
							  close SOCK || die "close: $!";
							  print "	 --$smtpserver is listening on tcp port $smtpport.\n";
							  $testmail = 1;
							}
						}
						else
						{
							print "	Socket error: $!.\n";
						};
					}
					else
					{
						print "	host $smtpserver not responding, check your config file.\n";
					};
				}
				else
				{
					print "	 smtpport ok.\n";
				};
			}
			else
			{
				print "	#smtpport not defined\n";
			};
			if ( defined $smtpuser )
			{
				print "	 smtpuser ok.\n";
			}
			else
			{
				print "	#smtpuser not defined\n";
			};
			if ( defined $smtppass)
			{
				if ( ( defined $smtpuser) and ( $testmail == 1 ) )
				{
					print "	 smtppass ok.\n	 -testing smtp authentication.\n";
					my($iaddr, $paddr, $proto, $mailaddr, $_LOCALHOST, $failed ) = undef;
					require Sys::Hostname;
					$_LOCALHOST = Sys::Hostname::hostname();
					$mailaddr = getEmailAddress( $smtpfrom );
					$failed = 0;
					#
					# Please refer to Socket module manual. (perldoc Socket)
					#
					$iaddr = inet_aton($smtpserver);
					$paddr = sockaddr_in($smtpport, $iaddr);
					$proto = getprotobyname('tcp');
					socket(SOCK, PF_INET, SOCK_STREAM, $proto);
					connect(SOCK, $paddr);
					
					receiveFromServer(\*SOCK);
					sendToServer(\*SOCK, "EHLO $_LOCALHOST");
					if ( receiveFromServer(\*SOCK) != 0 )
					{
						sendToServer(\*SOCK, "HELO $_LOCALHOST");
						receiveFromServer(\*SOCK);
					}
					#
					# Start authentication test.
					#
					$failed = 1 if sendToServer(\*SOCK, "AUTH LOGIN");
					$failed = 1 if receiveFromServer(\*SOCK) != 0;
					$failed = 1 if sendToServer(\*SOCK, encode_base64($smtpuser, "")) != 0;
					$failed = 1 if receiveFromServer(\*SOCK) != 0;
					$failed = 1 if sendToServer(\*SOCK, encode_base64($smtppass, "")) != 0;
					$failed = 1 if receiveFromServer(\*SOCK) != 0;
					$failed = 1 if sendToServer(\*SOCK, "QUIT") != 0;
					$failed = 1 if receiveFromServer(\*SOCK) != 0;
					eof(SOCK) || close(SOCK);
					if ( $failed eq 1 )
					{
						print "	#--smtp authentication failed.\n";
					}
					else
					{
						print "	 --smtp authentication ok.\n";
					};
				}
				else
				{
					print "	 smtppass ok.\n";
				};
			}
			else
			{
				print "	#smtppass not defined\n";
			};
			if ( defined $smtpfrom )
			{
				print "	 smtpfrom ok.\n";
			}
			else
			{
				print "	#smtpfrom not defined\n";
			};
			if ( defined $ntpserver )
			{
				print "	 ntpserver ok.\n";
				print "	 -testing connection\n";
				print "	 --" . GetNtpTime( $ntpserver ) . " returned by server\n"
			}
			else
			{
				print "	#ntpserver not defined\n";
			};
			if ( defined $ipwebaddress )
			{
				print "	 ipwebaddress ok.\n";
			}
			else
			{
				print "	#ipwebaddress not defined\n";
			};
			if ( defined $logdir )
			{
				if ( -d $logdir )
				{
					print "	 logdir ok.\n";
				}
				else
				{
					if ( mkpath( $logdir ) )
					{
						print "	+logdir created\n";
					}
					else
					{
						print "	#logdir does not exist\n";
					};
				};
			}
			else
			{
				print "	#logdir not defined\n";
			};
			if ( defined $dbdir )
			{
				if ( -d $dbdir )
				{
					print "	 dbdir ok.\n";
				}
				else
				{
					if ( mkpath($dbdir) )
					{
						print "	+dbdir created\n";
					}
					else
					{
						print "	#dbdir does not exist\n";
					};
				};
			}
			else
			{
				print "	#dbdir not defined\n";
			};
			if ( defined $tempdir )
			{
				if ( -d $tempdir )
				{
					print "	 tempdir ok.\n";
				}
				else
				{
					print "	#tempdir does not exist\n";
				};
			}
			else
			{
				print "	#tempdir not defined\n";
			};
			if ( defined $oktag)
			{
				print "	 oktag ok.\n";
			}
			else
			{
				print "	#oktag not defined\n";
			};
			if ( defined $errortag)
			{
				print "	 errortag ok.\n";
			}
			else
			{
				print "	#errortag not defined\n";
			};
			if ( defined $warningtag)
			{
				print "	 warningtag ok.\n";
			}
			else
			{
				print "	#warningtag not defined\n";
			};
		};
	};
	return (0);
};
##################################################################################
#
# Mail send test routines
#
##################################################################################
##################################################################################
#
# receiveFromServer : Receive data from server on socket connection.
#
##################################################################################
sub receiveFromServer # ( $socket ) -> ( $reply )
{
	my($socket) = shift;
	my($reply);
	#
	# We keep receiveing the data from the server until
	# it waits for next command.
	#
	while ($socket && ($reply = <$socket>))
	{
		return (1) if $reply =~ /^5/;
		last if $reply =~ /^\d+ /;
	};
	return( 0 );
};
##################################################################################
#
# sendToserver : Send data to server on socket conection.
#
##################################################################################
sub sendToServer # ( $socket, $message ) -> ()
{
	my($socket) = shift;
	my($message) = shift;
	print "	 --Tx $message\n";
	# Fix BareLf problem.
	$message =~ s/\n/\r\n/g;
	$message =~ s/\r\r\n/\r\n/g;
	#
	# Sending data to the server.
	#
	send($socket, "$message\r\n", 0);
	return( 0 );
};
##################################################################################
#
# getEmailAddress : Get email from "Name" <my.email@my.host> line.
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub getEmailAddress # ( $test ) -> ( $email )
{
	my($value) = shift;
	my($retvalue) = undef;
	if ($value =~ /^\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/)
	{
		($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
		return $retvalue;
	};
	if ($value =~ /^[^\<]+\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/)
	{
		($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
		return $retvalue;
	};
	return "" if $value =~ /\s+/;
	$value =~ tr/[A-Z]/[a-z]/;
	return $value if $value =~ /^[^\@]+\@[\w\-]+(\.[\w\-]+)+$/;
	return( "" );
}
##################################################################################
#
# End of mail test send routines
#
##################################################################################
##################################################################################
#
# Sub PrintHelp : print help when --help option is used
#
##################################################################################
sub PrintHelp # ( $pluginhelp) -> ()
{
	my ( $pluginhelp ) = shift;
	$pluginhelp = ::NumCl( $pluginhelp );
	no warnings 'redefine';
	print "bck version : $version\n";
	print "Copyright (c) 2006 by Bruno Veldeman\n";
	print "Options :\n";
	print "	--verbose			: Verbose\n";
	print "	--config-file=[/mypath/myconfig.file]\n";
	print "	--update			: Update from http/ftp server.\n";
	print "	--httpserver			: Run bck in http server mode for use with inetd.\n";
	print "	--reportserver			: Run bck in report server mode for use with inetd.\n";
	print "	--report			: Report in to central server.\n";
	print "	--mail				: Send pending reports by e-mail\n";
	print "	--check				: Check configuration file.\n";
	print "	--debug				: Debugging verbosity.\n";
	print "	--version			: Show version.\n";
	print "	--do=[block1[,block2...]]	: Execute block1, block2...\n";
	print "	--help|?			: Show this help.\n";
	print "	--pluginhelp			: Show help for plugins\n.";
	use FindBin qw( $Bin $Script );
	use File::Basename;
	my ( $path ) = $Bin;
	my ( $name ) = $Script;
	if ( -l "$path/$name" )
	{
		my ( $link ) = readlink "$path/$name";
		$path = dirname( $link );
		$name = basename( $link );
	};
	# We construct the $plugin string based on "type"
	my ( $plugindir ) = $path . "/plugins/";
	my ( @modules );
	my ( $module );
	# If the plugin and plugin folder exist, we continue
	if ( -d "$plugindir" )
	{
		# Set lib folder to find the plugins
		print "Plugin folder: $plugindir\n";
		if ( opendir ( DIR, $plugindir ) )
		{
			print "Found plugins:";
			while( ( my $filename = readdir(DIR)))
			{
				if ( $filename =~ m/.pm$/)
				{
					push( @modules, "$filename");
					print " $filename";
				}
			}
			closedir(DIR);
			print "\n";
		}
		else
		{
			print "Could not read plugins directory.\n";
		};
	};
	return( 0 ) unless ( $pluginhelp eq 2 );
	my ( $cols ) = 80;
	my ( $formathelp ) = "format help= \n"
				. '|--Description:   ^' . '<' x ( $cols - 20 ) . "|\n"
				. '$value' . "\n"
				. '|                 ^' . '<' x ( $cols - 22 ) . '~~' . "|\n"
				. '$value' . "\n"
				. '.' . "\n";
	my ( $formatreq ) = "format required = \n"
				. '|@>>>>>>>>>>>> => ^' . '<' x ( $cols - 20 ) . "|\n"
				. '$key, $value' . "\n"
				. '|                 ^' . '<' x ( $cols - 22 ) . '~~' . "|\n"
				. '$value' . "\n"
				. '.' . "\n";
	my ( $formatopt ) = "format optional = \n"
				. '|@>>>>>>>>>>>> => ^' . '<' x ( $cols - 20 ) . "|\n"
				. '$key, $value' . "\n"
				. '|                 ^' . '<' x ( $cols - 22 ) . '~~' . "|\n"
				. '$value' . "\n"
				. '.' . "\n";
	foreach $module ( @modules )
	{
		print "\n|--Plugin:\t  $module\n";
		# Try to load the plugin
		my ( $plugin ) = "$plugindir$module";
		if ( require "$plugin" )
		{
			my( $do ) = Plugin->new( 0, 0, 0, {0, 0} );
			# Print out the help info for the plugin
			my ( $key );
			 if ( defined $do->{_help} )
			 {
				my ( $value ) = $do->{'_help'};
				eval $formathelp;
				$~ = 'help';
				write;
			 };
			print "|--Required:                                                                 --|\n";
			foreach $key ( keys %{$do->{_required}} )
			{
				my ( $value ) = ${$do->{'_required'}}{$key};
				eval $formatreq;
				$~ = 'required';
				write;
			};
			print "|--Optional:                                                                 --|\n";
			foreach $key ( keys %{$do->{_optional}} )
			{
				my ( $value ) = ${$do->{'_optional'}}{$key};
				eval $formatopt;
				$~ = 'optional';
				write;
			};
			print "|------------------------------------------------------------------------------|\n";
		};
	};
	return( 0 );
};
##################################################################################
#
# Sub PrintVersion : print version when --version option is used
#
##################################################################################
sub PrintVersion # () -> ()
{
	print "bck version : $version\n";
	print "Copyright (c) 2006 by Bruno Veldeman\n";
	print "|-----------------------------------------------------------------------|\n";
	print "| This program is free software: you can redistribute it and/or modify  |\n";
	print "| it under the terms of the GNU General Public License as published by  |\n";
	print "| the Free Software Foundation, either version 3 of the License, or     |\n";
	print "| (at your option) any later version.                                   |\n";
	print "|                                                                       |\n";
	print "| This program is distributed in the hope that it will be useful,       |\n";
	print "| but WITHOUT ANY WARRANTY; without even the implied warranty or        |\n";
	print "| MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         |\n";
	print "| GNU General Public License for more details.                          |\n";
	print "|                                                                       |\n";
	print "| You should have received a copy of the GNU General Public License     |\n";
	print "| along with this program.  If not, see <http://www.gnu.org/licenses/>. |\n";
	print "|-----------------------------------------------------------------------|\n";
	return( 0 );
};
# NOT USED #################################################################################
#
# Sub CreateConfig : Create configuration file
#
# NOT USED #################################################################################
sub CreateConfig # (configfile) -> ()
{
	my($configfile) = @_;
	print "Creating config file subroutine\n";
	return(0);
};
##################################################################################
#
# Sub Update : Update to new version from ftp server
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub Update # (configfile) -> ()
{
	my( $configfile ) = @_;
	my( $cfg, $name, $path, $result, $url, $user, $pass, $cmd, $mastercfg, $installed, $downloaded );
	use File::Copy;
	use File::Basename;
	use FindBin qw( $Bin $Script );
	$path = $Bin;
	$name = $Script;
	my ( $configfilename ) = $cmdln->GetConfigFileName;
	if ( -e $configfilename )
	{
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
	};
	if ( defined $cfg )
	{
		$url		= $cfg->val('update', 'url');
		$user	= $cfg->val('update', 'user');
		$pass	= $cfg->val('update', 'password');
	};
	if ( -l "$path/$name" )
	{
		my ( $link ) = readlink "$path/$name";
		$path = dirname( $link );
		$name = basename( $link );
	};
	my ( @modules );
	push( @modules, $name );
	my ( $dir ) = $path . "/plugins";
	if ( opendir ( DIR, $dir ) )
	{
		while( ( my $filename = readdir(DIR)))
		{
			push( @modules, "/plugins/$filename") unless !( $filename =~ m/.pm$/);
		}
		closedir(DIR);
	}
	else
	{
		print "Could not read plugins directory.\n";
	};
	foreach my $module ( @modules )
	{
		# Check the installed version.
		undef $installed;
		open FILE, "<$path/$module";
		while ( <FILE>)
		{
			if ( /my.*\$version.*=.*\"(\d+\.\d+\.\d+)\"/ )
			{
				$installed = "$1";
				last;
			};
		};
		close FILE;
		$installed = "0" unless defined $installed;
		print "Preparing to update [$module] version: $installed...\n";
		if ( ( defined $url ) and ( defined $user ) and ( defined $pass ) )
		{
			$cmd = "wget $url/$module --quiet --user=$user --password=$pass --output-document=$path/$module.new";
		}
		elsif( defined $url )
		{
			$cmd = "wget $url/$module --quiet --output-document=$path/$module.new";
		};
		if ( defined $cmd )
		{
			$result = `$cmd`;
			if ( -e  "$path/$module.new" )
			{
				# Check the downloaded version.
				undef $downloaded;
				open FILE, "<$path/$module.new";
				while ( <FILE>)
				{
					if ( /my.*\$version.*=.*\"(\d+\.\d+\.\d+)\"/ )
					{
						$downloaded = "$1";
						last;
					};
				};
				close FILE;
				$downloaded = "0" unless defined $downloaded;
				print "Downloaded [$module] version: $downloaded\n";
				chomp( $downloaded );
				if ( &ConvertVersionString($downloaded) gt &ConvertVersionString($installed) )
				{
					print "Installing new [$module] version: $downloaded\n";
					if ( -e "$path/$module.$installed" )
					{
						unlink ("$path/$module.$installed");
					};
					chmod 0755, "$path/$module.new";
					move ("$path/$module","$path/$module.$installed");
					move ("$path/$module.new","$path/$module");
					print "$module succesfully updated to version $downloaded\n";
				}
				elsif ( &ConvertVersionString($downloaded) lt &ConvertVersionString($installed) )
				{
					print "No updates available for [$module], instaled version ($installed) is newer then downloaded version ($result).\n";
					unlink ("$path/$module.new");
				}
				else
				{
					print "Already up to date [$module].\n";
					unlink ("$path/$module.new");
				};
			}
			else
			{
				print "Update [$module] failed\n";
			};
		}
		else
		{
			print "Update [$module] failed\n";
		};
	};
	return(0);
};
##################################################################################
#
# ConvertVersionString : Convert version string to int.
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub ConvertVersionString # ( $versionstring ) -> ( $versionnum )
{
	my ( $version ) = @_;
	my ( $vernum, $vercount );
	# Clean up the string
	$version = StrCl( $version );
	$version =~ s/^\s+//;
	$version =~ s/\s+$//;
	# Split up in array
	my ( @ver ) = split( /\./, $version );
	$vercount = @ver;
	$vernum = 0;
	# Make an int with version by multiplicating by 1000 every piece.
	for (my $num=0 ; $num lt $vercount ; $num++  )
	{
		$vernum*= 1000;
		$vernum+= $ver[$num];
	};
	return ( $vernum );
};
##################################################################################
#
# Start -> WEB INTERFACE
#
##################################################################################
##################################################################################
##################################################################################
#
# Class HttpServer : Web interface server class
#
##################################################################################
package HttpServer;
#includes
use English;
use Config;
our @ISA = qw( DbFile );	# inherits from DbFile
#constructor
sub new
{	my ($class) = @_;
	my $self =
	{
		_configfile	=> "",
		_html		=> "",
		_htmlheaders => "",
		_method		=> "",
		_uri		=> "",
		_protocol	=> "",
		_headers	=> [],
		_headerlist => {},
		_postdata	=> {}
  	};
	bless $self, $class;
	return $self;
};
#accessor method for html
sub GetHtml
{
	my ( $self ) = shift;
	return $self->{_html};
};
sub AddHtml
{
	my ( $self ) = shift;
	my ( $html ) = @_;
	$self->{_html} .= $html;
};
#accessor method for htmlheaders
sub AddHeaders
{
	my ( $self ) = shift;
	my ( $headers ) = @_;
	$self->{_htmlheaders} .= $headers;
	print "$headers\n";
};
#accessor method for configfile
sub SetConfigfile
{
	my ( $self ) = shift;
	my ( $configfile ) = @_;
	$self->{_configfile} = $configfile;
};
#######################################################################################
#
# Parse request data from browser
#
# Input validation : OK (BV 11/9/2009)
#
#######################################################################################
sub ParseRequest
{
	my ( $self ) = shift;
	my $chunk;
	while ( sysread( STDIN, my $buff, 1 ) )
	{
		last if $buff eq "\n";
		$chunk .= $buff;
	}
	defined($chunk) or return undef;
	$_ = $chunk;
	m/^(\w+)\s+(\S+)(?:\s+(\S+))?\r?$/;
	my $method   = $1 || '';
	my $uri	  = lc($2) || '';
	my $protocol = $3 || '';
	$self->{_method} =  ::StrCl( $method );
	$self->{_uri} =  ::StrCl( $uri );
	$self->{_protocol} =  ::NumNz( $protocol );
	return();
};
#######################################################################################
#
# Handle http requests
#
# Input validation : OK (BV 11/9/2009)
#
#######################################################################################
sub Start # () -> ()
{
	my ( $self ) = shift;
	my ( $type ) = shift;
	$type = ::NumCl( $type );
	$self->ParseRequest();
	# If $type bit 0 = 1, respond to HTTP GET requests
	if ( ( $self->{_method} eq "GET" ) and ( $type & 1 ) )
	{
		if ( $self->{_uri} eq "/" )
		{
			$self->HtmlMain();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/test" )
		{
			$self->HtmlTest();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/logs" )
		{
			$self->HtmlLogs();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} =~ /detail/ )
		{
			$self->HtmlDetail( $self->{_uri} );
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/config" )
		{
			if ( $self->HtmlConfig() == 1 )
			{
			$self->SendHeaders();
			$self->SendBody();
			}
			else
			{
				$self->SendAuthHeaders("Config");
				$self->SendBody();
			};
		}
		else
		{
			$self->HtmlNotfound();
			$self->SendNotFoundHeaders();
			$self->SendBody();
		};
	}
	elsif ( ( $self->{_method} eq "POST" ) and ( $type & 1 ) )
	{
		if ( $self->{_uri} eq "/config" )
		{
			if ( $self->HtmlEditsection() == 1 )
			{
			$self->SendHeaders();
			$self->SendBody();
			}
			else
			{
				$self->SendAuthHeaders("Config");
				$self->SendBody();
			};
		}
		elsif ( $self->{_uri} eq "/" )
		{
			$self->HtmlMain();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/writeconfig" )
		{
			if ( $self->HtmlWriteconfig() == 1 )
			{
			$self->SendHeaders();
			$self->SendBody();
			}
			else
			{
				$self->SendAuthHeaders("Config");
				$self->SendBody();
			};
		}
		elsif ( $self->{_uri} eq "/test" )
		{
			$self->HtmlTest();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/logs" )
		{
			$self->HtmlLogs();
			$self->SendHeaders();
			$self->SendBody();
		}
		else
		{
			$self->HtmlNotfound();
			$self->SendNotFoundHeaders();
			$self->SendBody();
		};
	}
	# If $type bit 1 = 1, respond to bck report server requests
	elsif ( ( lc( $self->{_method} ) eq "bck" ) and ( $type & 2 ) )
	{
		# Create a random seed
		my ( $seed ) = sprintf("%2x", int( rand( 255 ) ) );
		# Get report access password.
		my ( $rsection ) = ReportSection->new();
		my ( $password ) = $rsection->GetServerPassword();
		# Create password string for compare
		my  ( $authstring ) = crypt( $password, $seed );
		# Send the seed
		print "bck" . $seed . "\n";
		# Wait for authentification and report lines
		my ( @report );
		my ( $numreports ) = 0;
		my $fh = select ( STDOUT );
		$| = 1;
		select ( $fh );
		while ( my $line = <STDIN> )
		{
			$line =~ s/\r?\n$//;
			last if $line eq "bck/END/";
			push ( @report, $line );
			$numreports++;
		};
		my ( $auth ) = shift( @report );
		$auth = substr( $auth, 3 );
		print "bck", $numreports - 2 ,"\n";
		my ( $dbfile ) = $cmdln->GetStatusFileName;
		if ( ( $authstring eq $auth ) and ( $password ne "" ) )
		{
			print "bck", $numreports - 2 ,"\n";
			my ( $db ) = DbFile->new();
			$db->SetFile( $gsection->GetDbDir() . '/' . "$dbfile" . '.db' );
			foreach my $line ( @report )
			{
				my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree, $infotext ) = split( /,/,$line );
				if ( !defined $statusbits ) { $statusbits = 24 };
				$section = ::StrCl( $section );
				$name = ::StrCl( $name );
				$timestamp = ::NumCl( $timestamp );
				$statustext = ::StrCl( $statustext );
				$size = ::NumCl( $size );
				$destsize = ::NumCl( $destsize );
				$destfree = ::NumCl( $destfree );
				$infotext = ::StrCl( $infotext );
				$db->{_statusbits} = $statusbits | 128;
				$db->SetSection( $section );
				$db->SetName( $name );
				$db->SetTimeStamp( $timestamp );
				$db->SetStatusText( $statustext );
				$db->SetSize( $size );
				$db->SetDestSize( $destsize );
				$db->SetDestFree( $destfree );
				$db->SetInfoText( $infotext );
				$db->AddLine();
			};
		}
		else
		{
			print "bck00\n";
		};
	}
	else
	{
		print "What are you doing?\r\nYou are not a browser, are you?\r\n";
	};
	return();
};
#######################################################################################
#
# SendHeaders
#
#######################################################################################
sub SendHeaders
{
	my ( $self ) = shift;
	print "HTTP/1.1 200 OK\r\n";
	print "Server: bck-backup/$version\r\n";
	print "Cache-Control: no-cache\r\n";
	print "Connection: close\r\n";
	print "Content-Length: " . length( $self->{_html} ) . "\r\n";
	print "Content-Language: en\r\n";
	print "Content-Type: text/html;charset=utf-8\r\n\r\n";
	return();
};
#######################################################################################
#
# SendChunkedHeaders
#
#######################################################################################
sub SendChunkedHeaders
{
	my ( $self ) = shift;
	print "HTTP/1.1 200 OK\r\n";
	print "Server: bck-backup/$version\r\n";
	print "Cache-Control: no-cache\r\n";
	print "Connection: close\r\n";
	print "Transfer-Encoding: chunked\r\n";
	print "Content-Language: en\r\n";
	print "Content-Type: text/html;charset=utf-8\r\n\r\n";
	return();
};
#######################################################################################
#
# SendAuthHeaders
#
#######################################################################################
sub SendAuthHeaders
{
	my ( $self ) = shift;
	my ( $realm ) = @_;
	$self->HtmlBodyTop();
	$self->AddHtml ( "<br><h1>401 Unauthorized</h1><p>Authorization Required</p>\r\n" );
	$self->AddHtml ( "<p>This server could not verify that you are authorized to access<br>\r\n" );
	$self->AddHtml ( "the document requested. Either you supplied the wrong credentials<br>\r\n" );
	$self->AddHtml ( "(e.g., bad password), or your browser doesn't understand how to<br>\r\n" );
	$self->AddHtml ( "supply the credentials required.</p>\r\n" );
	$self->HtmlBodyBottom();
	print "HTTP/1.1 401 Unauthorized\r\n";
	print "Server: bck-backup/$version\r\n";
	print 'WWW-Authenticate: Basic realm="' . $realm . '"' . "\r\n";
	print "Cache-Control: no-cache\r\n";
	print "Connection: close\r\n";
	print "Content-Length: " . length( $self->{_html} ) . "\r\n";
	print "Content-Language: en\r\n";
	print "Content-Type: text/html;charset=utf-8\r\n\r\n";
	return();
};
#######################################################################################
#
# SendNotFoundHeaders
#
#######################################################################################
sub SendNotFoundHeaders
{
	my ( $self ) = shift;
	print "HTTP/1.1 404 Not Found\r\n";
	print "Server: bck-backup/$version\r\n";
	print "Cache-Control: no-cache\r\n";
	print "Connection: close\r\n";
	print "Content-Length: " . length( $self->{_html} ) . "\r\n";
	print "Content-Language: en\r\n";
	print "Content-Type: text/html;charset=utf-8\r\n\r\n";
	return();
};
#######################################################################################
#
# SendBody
#
#######################################################################################

sub SendBody
{
	my ( $self ) = shift;
	print $self->{_html};
};
#######################################################################################
#
# SendBodyChunk
#
#######################################################################################
sub SendBodyChunk
{
	my ( $self ) = shift;
	printf ( "%x\r\n" , length( $self->{_html} ) );
	print $self->{_html} . "\r\n";
	$self->{_html} = "";
};
#######################################################################################
#
# ParseHeaders
#
# Input validation : PENDING!
#
#######################################################################################
sub ParseHeaders
{
	my ( $self ) = shift;
	my $chunk = '';
	while ( sysread( STDIN, my $buff, 1 ) )
	{
		if ( $buff eq "\n" )
		{
			$chunk =~ s/[\r\l\n\s]+$//;
			if ( $chunk =~ /^([\w\-]+): (.+)/i )
			{
				push @{$self->{_headers}}, $1 => $2;
			}
			last if ( $chunk =~ /^$/ );
			$chunk = '';
		}
		else
		{
			$chunk .= $buff
		}
	};
	my $counter = 0;
	while ( $counter < $#{$self->{_headers}})
	{
		$self->{_headerlist}->{lc( $self->{_headers}->[$counter])} = $self->{_headers}->[$counter+1];
		$counter++;
		$counter++;
	};
	return ();
};
#######################################################################################
#
# ParsePostdata
#
# Input validation : PENDING!
#
#######################################################################################
sub ParsePostdata # (datasize) -> (data)
{
	my ( $self ) = shift;
	my ( $data, @datalist );
	sysread( STDIN, $data, $self->{_headerlist}->{"content-length"} );
	@datalist = split(/&/,$data);
	foreach $data ( @datalist )
	{
		$data =~ s/\+/ /g;
		$data =~ s/%(..)/pack("C",hex($1))/ge;
		$data =~ s/[\'\^\`\;\'&?]//g; #`
		my ( $var, $val ) = split(/=/,$data);
		$self->{_postdata}->{$var} = $val;
	};
	return ( );
};
#######################################################################################
#
# HtmlMain
#
# Input validation : OK (BV 11/07/2009)
#
#######################################################################################
sub HtmlMain # () -> ()
{
	my ( $self ) = shift;
	my ( $dbfile ) = $cmdln->GetStatusFileName;
	$self->ParseHeaders;
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	my ($page ) = $self->{_postdata}->{"page"};
	my ( $gsection ) = GlobalSection->new();
	my ( $hsection ) = HttpSection->new();
	# If not defined, page = 1
	$page = 1 unless $page;
	my ( $lastpage ) = 1;
	if ( -e $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' )
	{
		my ( $db ) = DbFile->new();
		$db->SetFile( $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' );
		$lastpage = int( ( $db->GetNumLines() / $hsection->GetReportlines() ) + 0.5 );
		$lastpage = 1 unless ( $lastpage gt 1 );
	};
	$self->HtmlBodyTop();
	$self->AddHtml( "<tr><th class=\"buttons\">" );
	if ( $page > 1 )
	{
		$self->AddHtml ( "<form class=\"left\" action=\"\" method=\"POST\">\n" );
		$self->AddHtml ( '<input class="button" type="Submit" value="First page" name="group1">' . "\r\n" );
		$self->AddHtml ( '<input type="hidden" name="page" value="' . 1 . '" size="20">' . "\r\n" );
		$self->AddHtml ( "</form>" );
		$self->AddHtml ( "<form class=\"left\" action=\"\" method=\"POST\">\n" );
		$self->AddHtml ( '<input class="button" type="Submit" value="Previous page" name="group1">' . "\r\n" );
		$self->AddHtml ( '<input type="hidden" name="page" value="' . ( $page - 1 ) . '" size="20">' . "\r\n" );
		$self->AddHtml ( "</form>" );
	};
	if ( $page < $lastpage )
	{
		$self->AddHtml ( "<form class=\"right\" action=\"\" method=\"POST\">\n" );
		$self->AddHtml ( '<input class="button" type="Submit" value="Last page" name="group2">' . "\r\n" );
		$self->AddHtml ( '<input type="hidden" name="page" value="' . $lastpage . '" size="20">' . "\r\n" );
		$self->AddHtml ( "</form>" );
		$self->AddHtml ( "<form class=\"right\" action=\"\" method=\"POST\">\n" );
		$self->AddHtml ( '<input class="button" type="Submit" value="Next page" name="group2">' . "\r\n" );
		$self->AddHtml ( '<input type="hidden" name="page" value="' . ( $page + 1 ) . '" size="20">' . "\r\n" );
		$self->AddHtml ( "</form>" );
	};
	$self->AddHtml( "</th></tr><tr><td>" );
	$self->AddHtml( "<table class=\"lines\">\n" );
	$self->AddHtml( "<thead>\n"
	. "<tr>\n"
	. "<th class=\"pages\" colspan=\"5\">"
	. "Backup reports - Page " . $page . " of " . $lastpage . "\n"
	. "</th>\n"
	. "</tr>\n"
	. "<tr>\n"
	. "<th class=\"lines\">Operation\n"
	. "</th>\n"
	. "<th class=\"lines\" width=\"120\">Date/Time\n"
	. "</th>\n"
	. "<th class=\"lines\" width=\"120\">Info\n"
	. "</th>\n"
	. "<th class=\"lines\" width=\"100\">Status\n"
	. "</th>\n"
	. "<th class=\"lines\" width=\"120\">Report\n"
	. "</th></thead><tbody>\n" );
	if ( -e $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' )
	{
		my ( $line, $date, @lines );
		my ( $reportstatus ) = 0;
		my ( $counter ) = 0;
		my ( $db ) = DbFile->new();
		$db->SetFile( $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' );
		@lines = $db->ReadLast( $hsection->GetReportlines(), $page );	
		foreach $line ( @lines )
		{
			chomp( $line );
			$line = ::StrCl( $line );
			my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree, $infotext ,$id ) = split( /,/,$line );
			$statusbits = ::NumCl( $statusbits );
			$section = ::StrCl( $section );
			$name = ::StrCl( $name );
			$timestamp = ::NumCl( $timestamp );
			$statustext = ::StrCl( $statustext );
			$size = ::NumCl( $size );
			$destsize = ::NumCl( $destsize );
			$destfree = ::NumCl( $destfree );
			$id = ::NumCl( $id );
			$infotext = ::StrCl( $infotext );
			my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( $timestamp );
			my ( $date ) =  sprintf( "%02d/%02d/%02d %02d:%02d", $mday, ( $mon + 1 ), ( $year + 1900 ), $hour, $min );
			$self->AddHtml ( "<tr class=" );
			if ( $statusbits & 4 )
			{
				$self->AddHtml( '"header"' );
			}
			elsif ( $statusbits & 128 )
			{
				$self->AddHtml( '"remote"' );
			}
			else
			{
				$self->AddHtml( '"local"' );
			};
			$self->AddHtml ( ">\n" );
			$self->AddHtml ( "<td class=\"lines\"><a class=\"line\" href=\"/detail/$id\">[$section] $name</a>\n" . "</td>\n" );
			$self->AddHtml ( "<td class=\"lines\">$date\n" . "</td>\n" );
			$self->AddHtml ( "<td class=\"blue\">\n" );
			if ( $destsize ne 0 )
			{
				$self->AddHtml ( "<div>\n" );
			};
			$self->AddHtml ( ::HumanBytes( $size ) );
			if ( $destsize ne 0 )
			{
				$self->AddHtml ( "&nbsp;(" . int( 100 - ( $destfree / $destsize ) * 100 ) . "%)\n" );
				$self->AddHtml ( "<div style=\"background: rgb(255,0,0); float: left; color: rgb(255,255,0); overflow: hidden; border: 0px; margin: 0px 0px 0px 0px; height: 4px; padding: 0; width: " . int( 100 - ( $destfree / $destsize ) * 100 )  . "% \"></div>" );
				$self->AddHtml ( "</div>\n" );
			}
			$self->AddHtml ( "</td>\n" );
			$self->AddHtml ( "<td " );
			if ( $statusbits & 24 ) # Invalid
			{
				$self->AddHtml ( "class=\"red\"" );
			}
			elsif ( $statusbits & 16 ) # Error
			{
				$self->AddHtml ( "class=\"red\"" );
			}
			elsif ( $statusbits & 8 ) # Warning
			{
				$self->AddHtml ( "class=\"orange\"" );
			}
			else # OK
			{
				$self->AddHtml ( "class=\"green\"" );
			}
			$self->AddHtml ( " title=\"$infotext\">$statustext</td>\n" );
			$self->AddHtml ( "<td " );
			if ( ( $statusbits & 1 ) and ( $statusbits & 2 ) )
			{
				$self->AddHtml ( "class=\"green\">Mail &amp; Report" );
			}
			elsif ( $statusbits & 2 )
			{
				$self->AddHtml ( "class=\"green\">Report" );
			}
			elsif ( $statusbits & 1 )
			{
				$self->AddHtml ( "class=\"green\">Mail" );
			}
			else
			{
				$self->AddHtml ( "class=\"orange\">Pending" );
			};
			$self->AddHtml ( "</td>\n" . "</tr>\n" );
		};
   	}
	else
	{
		$self->AddHtml ( "<tr><td class=\"orange\" colspan=\"5\">No data</td></tr>" );
	};
	$self->AddHtml ( "</tbody>\n" . "</table>\n" . "\n" );
	$self->HtmlBodyBottom();
	return();
};
#######################################################################################
#
# HtmlDetail : Display detailed info for entry
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlDetail # ( $uri ) -> ()
{
	my ( $self ) = shift;
	my ( $uri ) = shift;
	my ( $dbfile ) = $cmdln->GetStatusFileName;
	$self->ParseHeaders;
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	my ( $gsection ) = GlobalSection->new();
	my ( $hsection ) = HttpSection->new();
	$self->HtmlBodyTop();
	$uri =~ /\/detail\/(.*)/;
	my ( $id ) = $1;
	$self->AddHtml("<br><table class=\"lines\">\n"
	. "<tbody>\n" );
	# content here
	my ( $db ) = DbFile->new();
	$db->SetFile( $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' );
	my ( $line ) = $db->ReadLine( $id );
	$self->AddHtml("Section: " . $db->GetSection() . "<br>\r\n" );
	$self->AddHtml("Name: " . $db->GetName() . "<br>\r\n" );
	$self->AddHtml("Timestamp: " . $db->GetHTimeStamp() . "<br>\r\n" );
	$self->AddHtml("Result: " . $db->GetStatusText() . "<br>\r\n" );
	$self->AddHtml("Size: " . $db->GetSize() . " (bytes) <br>\r\n" );
	$self->AddHtml("Size of destnation: " . $db->GetDestSize() . " (bytes) <br>\r\n" );
	$self->AddHtml("Space free on destnation: " . $db->GetDestFree() . " (bytes) <br>\r\n" );
	$self->AddHtml("Report mailed: " . $db->GetMailrep() . "<br>\r\n" );
	$self->AddHtml("Report sent to server: " . $db->GetCommrep() . "<br>\r\n" );
	$self->AddHtml("More info to come....<br>\r\n");
	$self->AddHtml("<br>Raw status file data: &gt;$line&lt; <br>\r\n" );
	$self->AddHtml("</tbody>\n" . "</table>\n" . "<br>\n");
	$self->HtmlBodyBottom();
	return();
};
#######################################################################################
#
# HtmlLogs :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlLogs # () -> ()
{
	my ( $self ) = shift;
	# If not defined, page = 1
	my ( $dbfile ) = $cmdln->GetStatusFileName;
	$self->ParseHeaders;
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	my ($page ) = $self->{_postdata}->{"page"};
	my ( $gsection ) = GlobalSection->new();
	my ( $hsection ) = HttpSection->new();
	$page = 1 unless $page;
	my ( $lastpage ) = 1;
	if ( -e $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' )
	{
		my ( $db ) = DbFile->new();
		$db->SetFile( $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' );
		$lastpage = int( ( $db->GetNumLines() / $hsection->GetReportlines() ) + 0.5 );
		$lastpage = 1 unless ( $lastpage gt 1 );
	};
	$self->HtmlBodyTop();
	if ( ( $self->{_method} eq "POST" ) and ( defined $self->{_postdata}->{"file"} ) )
	{
		my ( $ext );
		if ( $self->{_postdata}->{"group"} =~ /log/ )
		{
			$ext = "log";
		}
		else
		{
			$ext = "lst";
		};
		if ( -e $gsection->GetLogDir() . "/" . $self->{_postdata}->{"file"} . "." . lc( $ext ) )
		{
			open ( FILEDATA, "<" . $gsection->GetLogDir() . "/" . $self->{_postdata}->{"file"} . "." . lc( $ext ) );
			my ( $line, $size );
			$self->AddHtml( "<br><b>File: </b><i>" . $gsection->GetLogDir() . "/" . $self->{_postdata}->{"file"} . "." . lc( $ext ) . "</i><br>\r\n" );
			foreach $line (<FILEDATA>)
			{
				chomp( $line );
				$self->AddHtml( "$line<br>\r\n" );
			};
			close ( FILEDATA );
		}
		else
		{
			$self->AddHtml( "<br>No data<br>\r\n" );
		};
	};
	if ( ( $self->{_method} eq "GET" ) or ( defined $self->{_postdata}->{"page"} ) )
	{
		$self->AddHtml( "<tr><th class=\"buttons\">" );
		if ( $page > 1 )
		{
			$self->AddHtml ( "<form class=\"left\" action=\"\" method=\"POST\">\n" );
			$self->AddHtml ( '<input class="button" type="Submit" value="First page" name="group">' . "\r\n" );
			$self->AddHtml ( '<input type="hidden" name="page" value="' . 1 . '" size="20">' . "\r\n" );
			$self->AddHtml ( "</form>" );
			$self->AddHtml ( "<form class=\"left\" action=\"\" method=\"POST\">\n" );
			$self->AddHtml ( '<input class="button" type="Submit" value="Previous page" name="group">' . "\r\n" );
			$self->AddHtml ( '<input type="hidden" name="page" value="' . ( $page - 1 ) . '" size="20">' . "\r\n" );
			$self->AddHtml ( "</form>" );
		};
		if ( $page < $lastpage )
		{
			$self->AddHtml ( "<form class=\"right\" action=\"\" method=\"POST\">\n" );
			$self->AddHtml ( '<input class="button" type="Submit" value="Last page" name="group">' . "\r\n" );
			$self->AddHtml ( '<input type="hidden" name="page" value="' . $lastpage . '" size="20">' . "\r\n" );
			$self->AddHtml ( "</form>" );
			$self->AddHtml ( "<form class=\"right\" action=\"\" method=\"POST\">\n" );
			$self->AddHtml ( '<input class="button" type="Submit" value="Next page" name="group">' . "\r\n" );
			$self->AddHtml ( '<input type="hidden" name="page" value="' . ( $page + 1 ) . '" size="20">' . "\r\n" );
			$self->AddHtml ( "</form>" );
		};
		$self->AddHtml( "</th></tr><tr><td>" );
		$self->AddHtml ( "<table class=\"lines\">\n" );
		$self->AddHtml ( "<thead>\n"
		. "<tr>\n"
		. "<th colspan=\"5\" class=\"pages\">"
		. "Logs - Page " . $page . " of " . $lastpage . "\n"
		. "</th>\n"
		. "</tr>\n"
		. "<tr>\n"
		. "<th class=\"lines\">Section<br>\n"
		. "</th>\n"
		. "<th class=\"lines\" width=\"120\">Date/Time<br>\n"
		. "</th>\n"
		. "<th class=\"lines\" width=\"100\">Logfile Size<br>\n"
		. "</th>\n"
		. "<th class=\"lines\" width=\"100\">Listfile Size<br>\n"
		. "</th>\n"
		. "</tr></thead><tbody>\n" );
		if ( -e $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' )
		{
			my ( $line, $date, @lines );
			my ( $reportstatus ) = 0;
			my ( $counter ) = 0;
			my ( $db ) = DbFile->new();
			$db->SetFile( $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' );
			@lines = $db->ReadLast( $hsection->GetReportlines(), $page );	
			foreach $line ( @lines )
			{
				chomp( $line );
				$line = ::StrCl( $line );
				my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree, $infotext, $id ) = split( /,/,$line );
				$statusbits = ::NumCl( $statusbits );
				$section = ::StrCl( $section );
				$name = ::StrCl( $name );
				$timestamp = ::NumCl( $timestamp );
				$statustext = ::StrCl( $statustext );
				$size = ::NumCl( $size );
				$destsize = ::NumCl( $destsize );
				$destfree = ::NumCl( $destfree );
				$infotext = ::StrCl( $infotext );
				$id = ::NumCl( $id );
				my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime( $timestamp );
				my ($date ) = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . sprintf( "%02d:%02d" , $hour, $min );
				$self->AddHtml ( "<tr " );
				if ( $statusbits & 4 )
				{
					$self->AddHtml( "class=\"header\"" );
				}
				elsif ( $statusbits & 128 )
				{
					$self->AddHtml( "class=\"remote\"" );
				}
				else
				{
					$self->AddHtml( "class=\"local\"" );
				};
				$self->AddHtml ( ">\n" . "<td class=\"col\">\r\n" );
				$self->AddHtml( "<form class=\"left\" action=\"logs\" method=\"POST\" >\n" );
				$self->AddHtml( "<label>[$section] $name </label>" );
				if ( -e $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".log" )
				{
					if ( -e $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".lst" )
					{
						$self->AddHtml( '<input class="button" type="Submit" value="Show file list" name="group">' . "\r\n" );
					};
					$self->AddHtml( '<input class="button" type="Submit" value="Show log file" name="group">' . "\r\n" );
					$self->AddHtml( '<input type="hidden" name="file" value="' .  "$section.$timestamp" . '" size="20">' . "\r\n" );
				}
				$self->AddHtml( "</form>" );
				$self->AddHtml( "</td>\n" );
				$self->AddHtml( "<td class=\"lines\">$date\n" . "</td>\n" );
				if ( -e $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".log" )
				{
					$size = -s $gsection->GetLogDir() . "/" . $section . "." . $timestamp . ".log";
					$self->AddHtml( "<td class=\"lines\">" . ::HumanBytes( $size ) . "\n" . "</td>\n" );
				}
				else
				{
					$self->AddHtml( "<td class=\"lines\">n/a\n" . "</td>\n" );
				};
				if ( -e $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".lst" )
				{
					$size = -s $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".lst";
					$self->AddHtml( "<td class=\"lines\">" . ::HumanBytes($size) . "\n" . "</td>\n" );
				}
				else
				{
					$self->AddHtml( "<td class=\"lines\">n/a\n" . "</td>\n" );
				};
				$self->AddHtml( "\r\n</tr>\n" );
			};
		}
		else
		{
			$self->AddHtml( "<tr><td class=\"orange\"  colspan=\"5\">No data</td></tr>" );
		};
	};
	$self->AddHtml( "</tbody>\n" . "</table>\n" . "\n" );
	$self->HtmlBodyBottom();
	return();
};
#######################################################################################
#
# HtmlNotfound :
#
# Input Validation : PENDING!
#
#######################################################################################
sub HtmlNotfound # () -> ()
{
	my ( $self ) = shift;
	$self->ParseHeaders;
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	my ( $var, $val );
	$self->HtmlBodyTop();
	$self->AddHtml( '<br><h1>404 Not Found</h1><p>Page Not Found</p>' );
	$self->AddHtml( '<p>The requested URL ' . $self->{_uri} . ' was not found on this server.</p>' );
	$self->HtmlBodyBottom();
	return();
};
#######################################################################################
#
# HtmlConfig :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlConfig # () -> ()
{
	use MIME::Base64;
	my ( $self ) = shift;
	my ( $var, $val );
	$self->ParseHeaders();
	my ( $hsection ) = HttpSection->new();
	my $authstring = $hsection->GetUser() . ":" . $hsection->GetPassword();
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	if ( ( defined ( $self->{_headerlist}->{"authorization"} ) ) and ( $hsection->GetPassword() ne "" ) and ( $hsection->GetUser() ne "" ) )
	{
		return(0) unless( $self->{_headerlist}->{"authorization"} eq "Basic " . encode_base64( "$authstring","" ) )
	}
	else
	{
		return( 0 );
	};
	$self->HtmlBodyTop();
	if ( -e $self->{_configfile} )
	{
		my ( $cfg, $mastercfg, $chkcfg );
		if ( -r "/etc/bck/bck.default" )
		{
			$mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			$cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
		}
		else
		{
			$cfg = Config::IniFiles->new( -file => $self->{_configfile} );
		};
		$chkcfg = Config::IniFiles->new( -file => $self->{_configfile} );
		$self->AddHtml( '<table class="lines"><thead>' );
		$self->AddHtml( "<tr><th class=\"pages\" colspan=\"3\">Config file: " . $self->{_configfile} . "</th></tr></thead><tbody>" );
		foreach my $section ( $cfg->Sections)
		{
			my @values = $cfg->Parameters($section);
			$self->AddHtml( '<tr><th class="pages" colspan="3"><form class="left" action="config" method="POST">' );
			$self->AddHtml( '<input type="hidden" name="section" value="' .  "$section" . '">' );
			$self->AddHtml( '<input class="button" type="Submit" value="Edit">' );
			$self->AddHtml( "<label> Section : [" . "$section" . "]</label>" );
			$self->AddHtml( '</form></th></tr>' . "\r\n" );
			$self->AddHtml( '<tr><th class="lines" width="200">Setting</th><th class="lines" width="200">Value</th><th class="lines" width="200">Default value</th></tr>' );
			foreach $var ( @values )
			{
				$val = $cfg->val($section, $var);
				$val =~ s/\n/\,/g;
				$val =~ s/\</&lt;/g;
				$val =~ s/\>/&gt;/g;
				$val =~ s/\"/&quot;/g;
				if ( $var =~ m/pass/ )
				{
					$val = "<span title=\"$val\">&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;</span>";
				};
				$self->AddHtml( '<tr class="local">' );
				$self->AddHtml( "<td class=\"setting\">" . $var  . "</td>" );
				if ( defined $chkcfg->val( $section, $var ) )
				{
					$self->AddHtml( '<td class="value">' . $val );
				}
				else
				{
					$self->AddHtml( '<td class="default"><span title="From default">' . $val . '</span>');
				};
				$self->AddHtml( "</td>" );
				if ( ( -r "/etc/bck/bck.default" ) and ( defined $mastercfg->val( $section, $var )  ) )
				{
					if ( $var =~ m/pass/ )
					{
						$self->AddHtml( "<td class=\"default\">" . "<span title=\"" . $mastercfg->val( $section, $var ) . "\">&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;</span>" . "</td></tr>" );
					}
					else
					{
						$self->AddHtml( "<td class=\"default\">" . $mastercfg->val( $section, $var ) . "</td></tr>" );
					};
				}
				else
				{
					$self->AddHtml( "<td class=\"value\">n/a</td></tr>" );
				};
				$self->AddHtml( "\r\n" );
			};
		};
		$self->AddHtml( '</tbody></table>' );
	};
	$self->HtmlBodyBottom();
	return( 1 );
};
#######################################################################################
#
# HtmlEditSection :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlEditsection # () -> () 
{
	my ( $self ) = shift;
	my ( $section, $var, $val );
	my ( $hsection ) = HttpSection->new();
	my $authstring = $hsection->GetUser() . ":" . $hsection->GetPassword();
	$self->ParseHeaders();
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata( );
	};
	$section = $self->{_postdata}->{"section"};
	if ( ( ( defined ( $self->{_headerlist}->{"authorization"} ) ) and ( $hsection->GetPassword() ne "" ) and ( $hsection->GetUser() ne "" ) ))
	{
		return( 0 ) unless( $self->{_headerlist}->{"authorization"} eq ("Basic " . encode_base64("$authstring","")) )
	}
	else
	{
		return( 0 );
	};
	$self->HtmlBodyTop();
	$self->AddHtml( '<br>Editing section <b>' . $section . ':</b>' . "\r\n" . '<br><br>' );
	if (-r $self->{_configfile} )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
		};
		$self->AddHtml( "<b>[" . $section . "]</b>" );
		my @values = $cfg->Parameters($section);
		$self->AddHtml( '<form action="writeconfig" method="POST"><input type="hidden" name="section" value="' .  "$section" . '" size="20">' . "\r\n" );
		$self->AddHtml( '<table border="1">' );
		foreach $var (@values)
		{
			$val = $cfg->val($section, $var);
			$val =~ s/\n/\,/g;
			$val =~ s/\</&lt;/g;
			$val =~ s/\>/&gt;/g;
			$val =~ s/\"/&quot;/g;
			$self->AddHtml( '<tr><td>' . $var . '</td><td>' );
			if ( $var =~ m/pass/ )
			{
				$self->AddHtml( '<input type="password" ' );
			}
			else
			{
				$self->AddHtml( '<input type="text" ' );
			};
			$self->AddHtml( ' name="' . $var  . '" value="' .  $val . '" size="80">' . "\n\r" );
			$self->AddHtml( ' <input type="Submit" value="Delete ' . $var . '" name="del"></td></tr>' . "\r\n" );
		};
		$self->AddHtml( '<tr><td><input type="text" name="newvar" value="" size="20"></td><td><input type="text" name="newval" value="" size="80">' . "\r\n" . '<input type="Submit" value="Add" name="add"></td></tr>' . "\r\n" );
		$self->AddHtml( '</table>' );
		$self->AddHtml( '<input type="Submit" value="OK" name="ok"></form>' . "\r\n" );
	};
	$self->HtmlBodyBottom();
	return( 1 );
};
#######################################################################################
#
# HtmlWriteConfig :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlWriteconfig # () -> ()
{
	my ( $self ) = shift;
	my ( $section, $var, $val );
	$self->ParseHeaders();
	my ( $hsection ) = HttpSection->new();
	my $authstring = $hsection->GetUser() . ":" . $hsection->GetPassword();

	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	$section = $self->{_postdata}->{"section"};
	if (( ( defined ( $self->{_headerlist}->{"authorization"} ) ) and ( $hsection->GetPassword() ne "" ) and ( $hsection->GetUser() ne "" ) ) )
	{
		if ( $self->{_headerlist}->{"authorization"} eq ("Basic " . encode_base64("$authstring","")) )
		{
			#Authentication OK!
		}
		else
		{
			#Autentication NOT OK!
			return(0);
		};
	}
	else
	{
		return(0);
	};
	$self->HtmlBodyTop();
	$self->AddHtml( '<br>Section <b>' . $section . '</b> written.' . "\r\n" . '<br><br>' );
	if (-r $self->{_configfile} )
	{
		if ( defined $self->{_postdata}->{"ok"} )
		{
			my ( $cfg, $mastercfg );
			if ( -r "/etc/bck/bck.default" )
			{
				  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
				  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
			}
			else
			{
				$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
			};
			$self->AddHtml( "<b>[" . $section . "]</b>" );
			my @values = $cfg->Parameters($section);
			$self->AddHtml( '<table border="1">' . "\r\n" );
			while (( $var, $val) = each %{$self->{_postdata}})
			{
				$cfg->setval($section, $var, $val );
			};
			foreach $var (@values)
			{
				$val = $cfg->val($section, $var);
				$val =~ s/\n/\,/g;
				$val =~ s/\</&lt;/g;
				$val =~ s/\>/&gt;/g;
				$val =~ s/\"/&quot;/g;
				if ( $var =~ m/pass/ )
				{
					$val = "&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;";
				};
				$self->AddHtml( '<tr><td>' . $var . ' = </td><td>' .  $val . '</td></tr>' . "\n\r" );
			};
			$self->AddHtml( '</table>' . "\r\n" );
			if ( $cfg->WriteConfig($self->{_configfile}) )
			{
				$self->AddHtml( "<p>Configuration file updated.</p>" );
			}
			else
			{
				$self->AddHtml( "ERROR" );
			};
		}
		elsif ( defined $self->{_postdata}->{'add'} )
		{
			$var = $self->{_postdata}->{'newvar'};
			$val = $self->{_postdata}->{'newval'};
			my ( $cfg, $mastercfg );
			if ( -r "/etc/bck/bck.default" )
			{
				  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
				  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
			}
			else
			{
				$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
			};
			$cfg->newval($section, $var, $val );
			$self->AddHtml( "<b>[" . $section . "]</b>" );
			my @values = $cfg->Parameters($section);
			$self->AddHtml( '<table border="1">' . "\r\n" );
			foreach $var (@values)
			{
				$val = $cfg->val($section, $var);
				$val =~ s/\n/\,/g;
				$val =~ s/\</&lt;/g;
				$val =~ s/\>/&gt;/g;
				$val =~ s/\"/&quot;/g;
				if ( $var =~ m/pass/ )
				{
					$val = "&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;";
				};
				$self->AddHtml( '<tr><td>' . $var . ' = </td><td>' .  $val . '</td></tr>' . "\n\r" );
			};
			$self->AddHtml( '</table>' . "\r\n" );
			if ( $cfg->WriteConfig($self->{_configfile}) )
			{
				$self->AddHtml( "<p>Configuration file updated.</p>" );
			}
			else
			{
				$self->AddHtml( "ERROR" );
			};
		}
		elsif ( defined $self->{_postdata}->{'del'} )
		{
			my ( $dummy );
			( $dummy, $var ) = split( /\s/, $self->{_postdata}->{'del'} );
			my ( $cfg, $mastercfg );
			if ( -r "/etc/bck/bck.default" )
			{
				  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
				  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
			}
			else
			{
				$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
			};
			$cfg->delval($section, $var );
			$self->AddHtml( "<b>[" . $section . "]</b>" );
			my @values = $cfg->Parameters($section);
			$self->AddHtml( '<table border="1">' . "\r\n" );
			foreach $var (@values)
			{
				$val = $cfg->val($section, $var);
				$val =~ s/\n/\,/g;
				$val =~ s/\</&lt;/g;
				$val =~ s/\>/&gt;/g;
				$val =~ s/\"/&quot;/g;
				if ( $var =~ m/pass/ )
				{
					$val = "&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;";
				};
				$self->AddHtml( '<tr><td>' . $var . ' = </td><td>' .  $val . '</td></tr>' . "\n\r" );
			};
			$self->AddHtml( '</table>' . "\r\n" );
			if ( $cfg->WriteConfig($self->{_configfile}) )
			{
				$self->AddHtml( "<p>Configuration file updated.</p>" );
			}
			else
			{
				$self->AddHtml( "ERROR" );
			};
		}
		else
		{
			$self->AddHtml( "ERROR" );
		}
	};
	$self->HtmlBodyBottom();
	return (1);
};
#######################################################################################
#
# Htmltest :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlTest # () -> ()
{
	my ( $self ) = shift;
	my ( $header, $value, $var, $val, $headers );
	$self->ParseHeaders();
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};

	$self->HtmlBodyTop();
	$self->AddHtml( "<br><p><b>Request:</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>" );
	$self->AddHtml( "Method : " . $self->{_method} . "<br>" );
	$self->AddHtml( "URI : " . $self->{_uri} . "<br>");
	$self->AddHtml( "Protocol : " . $self->{_protocol} . "<br>" );
	$self->AddHtml( '<p><b>Headers: </b></p>' );
	while (( $header, $value ) = each ( %{$self->{_headerlist}} ))
	{
		$self->AddHtml( "$header : $value<br>\r\n" );
	};
	if ( $self->{_method} eq "POST" )
	{
		$self->AddHtml( "<p><b>Postdata:</b></p>\r\n" );
		while (( $var, $val) = each ( %{$self->{_postdata}} ) )
		{
			$self->AddHtml( "$var : $val<br>\r\n" );
		};
	};
	$self->AddHtml( '<br>Form submit testing<br>' );
	$self->AddHtml( '<form action="test" method="POST">Data1: <input type="text" name="data1" value="Some data" size="20"><br>Data2: <input type="text" name="data2" value="More data" size="20"><br><input type="submit" value="Submit"></form>' );
	$self->AddHtml( '<form action="test" method="POST"><input type="hidden" name="data4" value="Other data" size="20"><br>Data3: <input type="text" name="data3" value="More data..." size="20"><br><input type="submit" value="Submit"></form>' );
	$self->HtmlBodyBottom();
	return ();
};
#######################################################################################
#
# HtmlBodyTop :
#
# Input validation : NONE
#
#######################################################################################
sub HtmlBodyTop # () -> ()
{
	my ( $self ) = shift;
	my ( $gsection ) = GlobalSection->new();
	$self->AddHtml( '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">' . "\r\n" );
	$self->AddHtml( '<html>' . "\r\n" );
	$self->AddHtml( '<head>' . "\r\n" );
	$self->AddHtml( '<meta http-equiv="Pragma" content="no-cache" >' . "\r\n" );
	$self->AddHtml( '<meta http-equiv="Content-type" content="text/html;charset=UTF-8">' );
	$self->AddHtml( '<meta http-equiv="expires" content="-1" >' . "\r\n" );
	$self->AddHtml( '<meta name="Robots" content="noindex" >' . "\r\n" );
	$self->AddHtml( '<title>bck-backup</title>' . "\r\n" );
	$self->AddHtml( '<style type="text/css">' . "\r\n" );
	$self->AddHtml( '<!--' . "\r\n" );
	$self->AddHtml( 'body {' );
	$self->AddHtml( 'background: #CECECE;' );
	$self->AddHtml( 'color: #000000;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'bar {' );
	$self->AddHtml( 'border-color: rgb(255,0,0);' );
	$self->AddHtml( 'border: 0px;' );
	$self->AddHtml( 'padding: 0;' );
	$self->AddHtml( 'height: 2px;' );
	$self->AddHtml( 'margin: 0 0 0 0px;' );
	$self->AddHtml( 'overflow: hidden;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'a.menu {' );
	$self->AddHtml( 'color: #000099;' );
	$self->AddHtml( 'font-size: 1.3em;' );
	$self->AddHtml( 'font-weight: bold;text-decoration: none;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'a.line {' );
	$self->AddHtml( 'color: #000000;' );
	$self->AddHtml( 'font-size: 1em;' );
	$self->AddHtml( 'padding: 0px 5px 0px 5px;' );
	$self->AddHtml( 'font-weight: bold;text-decoration: none;' );
	$self->AddHtml( 'float: left;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.top {' );
	$self->AddHtml( 'background: #8080FF;' );
	$self->AddHtml( 'color: #000099;' );
	$self->AddHtml( 'padding: 10px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'div.subtitle {' );
	$self->AddHtml( 'font-size: 1.1em;' );
	$self->AddHtml( 'font-style: italic;' );
	$self->AddHtml( 'text-indent: 70px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'div.title {' );
	$self->AddHtml( 'font-size: 3.3em;' );
	$self->AddHtml( 'font-weight: bold;' );
	$self->AddHtml( 'text-indent: 70px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'table.main {' );
	$self->AddHtml( 'table-layout: fixed;' );
	$self->AddHtml( 'width: 100%;' );
	$self->AddHtml( 'border-width: 1px;' );
	#$self->AddHtml( 'border-collapse: collapse;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'table.list {' );
	$self->AddHtml( 'width: 100%;' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'border-color: #CECECE;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'border-collapse: collapse;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'span.menu {' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: top;' );
	$self->AddHtml( 'background: #8080FF;' );
	$self->AddHtml( 'padding: 6px;' );
	$self->AddHtml( 'margin: 6px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'table.lines {' );
	$self->AddHtml( 'width: 100%;' );
	$self->AddHtml( 'border-width: 2px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-collapse: collapse;' );
	$self->AddHtml( 'text-align: left;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'th.buttons {' );
	$self->AddHtml( 'border-width: 0px;' );
	$self->AddHtml( 'display:  block;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'input.button {' );
	$self->AddHtml( 'border-width: 2px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: outset;' );
	$self->AddHtml( 'background: #C0C0C0;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'padding: 0px;' );
	$self->AddHtml( 'margin: 0px;' );
	$self->AddHtml( 'height: 23px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'th.lines {' );
	$self->AddHtml( 'border-width: 2px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'background: #707070;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'font-size: 1em;' );
	$self->AddHtml( 'padding: 2px;' );
	$self->AddHtml( 'margin: 2px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'th.pages {' );
	$self->AddHtml( 'border-width: 2px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'background: rgb(255, 255, 204);' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'font-size: 1.5em;' );
	$self->AddHtml( 'font-weight: bold;' );
	$self->AddHtml( 'padding: 2px;' );
	$self->AddHtml( 'margin: 2px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.lines {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'height: 28px;' );
	$self->AddHtml( 'overflow: hidden;' );
	$self->AddHtml( 'padding: 2px;' );
	$self->AddHtml( 'margin: 2px;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.col {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-indent: 5px;' );
	$self->AddHtml( 'height: 28px;' );
	$self->AddHtml( 'padding: 2px;' );
	$self->AddHtml( 'margin: 2px;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( 'border-collapse: collapse;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'tr.header {' );
	$self->AddHtml( 'background: #F4FA58;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'tr.local {' );
	$self->AddHtml( 'background: #AEAEAE;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'tr.remote {' );
	$self->AddHtml( 'background: #58FAF4;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.green {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background-color: rgb(51, 255, 51);' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.red {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background-color: rgb(255, 0, 0);' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.orange {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background-color: rgb(255, 153, 0);' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.blue {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background-color: rgb(120,120,255);' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.menu {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background: #707070;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'padding: 10px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.footer{' );
	$self->AddHtml( 'color: #202020;' );
	$self->AddHtml( 'background: #B0B0B0;' );
	$self->AddHtml( 'text-align: right;' );
	$self->AddHtml( 'font-size: 0.8em;' );
	$self->AddHtml( 'font-style: italic;' );
	$self->AddHtml( 'padding-right: 40px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.setting{' );
	$self->AddHtml( 'color: #202020;' );
	$self->AddHtml( 'font-weight: bold;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background: #B0B0B0;' );
	#$self->AddHtml( 'text-align: right;' );
	#$self->AddHtml( 'font-size: 0.8em;' );
	#$self->AddHtml( 'font-style: italic;' );
	$self->AddHtml( 'padding-left: 5px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.value{' );
	$self->AddHtml( 'color: #294A20;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background: #B0B0B0;' );
	#$self->AddHtml( 'text-align: right;' );
	#$self->AddHtml( 'font-size: 0.8em;' );
	#$self->AddHtml( 'font-style: italic;' );
	$self->AddHtml( 'padding-left: 5px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.default{' );
	$self->AddHtml( 'color: #1E12B0;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background: #909090;' );
	#$self->AddHtml( 'text-align: right;' );
	#$self->AddHtml( 'font-size: 0.8em;' );
	#$self->AddHtml( 'font-style: italic;' );
	$self->AddHtml( 'padding-left: 5px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'form.left{' );
	$self->AddHtml( 'float: left;' );
	$self->AddHtml( 'padding: 1px 1px 1px 1px;' );
	$self->AddHtml( 'margin: 0px 0px 0px 0px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'form.right{' );
	$self->AddHtml( 'float: right;' );
	$self->AddHtml( 'padding: 1px 1px 1px 1px;' );
	$self->AddHtml( 'margin: 0px 0px 0px 0px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( '-->' . "\r\n" );
	$self->AddHtml( '</style>' . "\r\n" );
	$self->AddHtml( '</head>' . "\r\n" );
	$self->AddHtml( '<body>' . "\r\n" );
	$self->AddHtml( '<table class="main">' . "\r\n" );
	$self->AddHtml( '<tr>' . "\r\n" );
	$self->AddHtml( '<td class="top">' . "\r\n" );
	$self->AddHtml( '<div class="title">bck-backup</div>' . "\r\n" );
	$self->AddHtml( "<div class=\"subtitle\"><b>Version</b> : $version" . "</div>\r\n" );
	$self->AddHtml( "<div class=\"subtitle\"><b>Configfile</b> : $self->{_configfile}" . "</div>\r\n" );
	$self->AddHtml( "<div class=\"subtitle\"><b>Instalation</b> : $gsection->{_client}" . "</div>\r\n" );
	$self->AddHtml( '</td>' . "\r\n" );
	$self->AddHtml( '</tr>' . "\r\n" );
	$self->AddHtml( '<tr>' . "\r\n" );
	$self->AddHtml( '<td class="menu">' . "\r\n" );
	$self->AddHtml( '<span class="menu"><a class="menu" href="/">Reports</a></span>' . "\r\n" );
	$self->AddHtml( '<span class="menu"><a class="menu" href="/logs">Logs</a></span>' . "\r\n" );
	$self->AddHtml( '<span class="menu"><a class="menu" href="/config">Config</a></span>' . "\r\n" );
	#$self->AddHtml( '<span class="menu"><a class="menu" href="/test">Test</a></span>' . "\r\n" );
	$self->AddHtml( '</td></tr>' . "\r\n" );
	$self->AddHtml( '<tr><td>' . "\r\n" );
	return();
}
#######################################################################################
#
# HtmlBodyBottom :
#
# Input validation : NONE
#
#######################################################################################
sub HtmlBodyBottom # () -> ()
{
	my ( $self ) = shift;
	$self->AddHtml( '</td>' . "\r\n" );
	$self->AddHtml( '</tr>' . "\r\n" );
	$self->AddHtml( '<tr><td class="footer">' . "\r\n" );
	$self->AddHtml( 'bck-backup Web interface' . "\r\n" );
	$self->AddHtml( "Running on : " . $Config{'osname'} . " / " . $Config{'osvers'} . " [" . $Config{'archname'} . "] , Perl version : v" . $Config{'PERL_REVISION'} . "." . $Config{'PERL_VERSION'} . "." . $Config{'PERL_SUBVERSION'} . "\r\n" );
	$self->AddHtml( '</td></tr>' . "\r\n" );
	$self->AddHtml( '</table>' . "\r\n" );
	$self->AddHtml( '</body>' . "\r\n" );
	$self->AddHtml( '</html>' . "\r\n" );
	return();
};
##################################################################################
# End Class HttpServer
####################################################################################################################################################################
##################################################################################
#
# Class CommandLine : Command line parameter storage class
#
# Input Validation : OK (Done by Config::Ini)
#
##################################################################################
package CommandLine;
use Getopt::Long;
#constructor
sub new
{	my ($class) = @_;
	my $self =
	{
		_verbose	=> undef,
		_configfile	=> undef,
		_install	=> undef,
		_update		=> undef,
		_check		=> undef,
		_debug		=> undef,
		_do		=> undef,
		_version	=> undef,
		_help		=> undef,
		_http		=> undef,
		_report		=> undef,
		_mail		=> undef,
		_dbfile	=> undef
	};
	bless $self, $class;
	return $self;
};
#accessor method for verbose
sub GetVerboseFlag {
	my ( $self ) = @_;
	return $self->{_verbose};
};
#accessor method for configfile
sub GetConfigFileName {
	my ( $self ) = @_;
	return $self->{_configfile};
};
#accessor method for configfile
sub GetStatusFileName {
	my ( $self ) = @_;
	return $self->{_dbfile};
};
#accessor method for install
sub GetInstallFlag {
	my ( $self ) = @_;
	return $self->{_install};
};
#accessor method for update
sub GetUpdateFlag {
	my ( $self ) = @_;
	return $self->{_update};
};
#accessor method for check
sub GetCheckFlag {
	my ( $self ) = @_;
	return $self->{_check};
};
#accessor method for debug
sub GetDebugFlag {
	my ( $self ) = @_;
	return $self->{_debug};
};
#accessor method for do
sub GetDo {
	my ( $self ) = @_;
	return $self->{_do};
};
#accessor method for version
sub GetVersionFlag {
	my ( $self ) = @_;
	return $self->{_version};
};
#accessor method for help
sub GetHelpFlag {
	my ( $self ) = @_;
	return $self->{_help};
};
#accessor method for http
sub GetHttpFlag {
	my ( $self ) = @_;
	return $self->{_http};
};
#accessor method for report
sub GetReportFlag {
	my ( $self ) = @_;
	return $self->{_report};
};
#accessor method for mail
sub GetMailFlag {
	my ( $self ) = @_;
	return $self->{_mail};
};
#parse command line and fill class
sub ParseCommandLine{ # () -> (ok)
	my ( $self ) = @_;
	my ( $ok, $verbose, $configfile, $langfile, $help, $pluginhelp, $version, $debug, $install, $check, $do, $httpserver, $reportserver, $report, $mail, $update);
	my ( $status ) = 0;
	$ok = @ARGV;
	if ( $ok > 0 )
	{
		GetOptions
		(
			'verbose'	=> \$verbose,
			'config-file=s' => \$configfile,
			'install'	=> \$install,
			'update'	=> \$update,
			'check'	=> \$check,
			'debug'	=> \$debug,
			'do=s'	=> \$do,
			'mail'		=> \$mail,
			'version'	=> \$version,
			'help|?'	=> \$help,
			'pluginhelp' => \$pluginhelp,
			'httpserver'	=> \$httpserver,
			'reportserver' => \$reportserver,
			'report'	=> \$report
		);
	}
	else
	{
		print "No parameters specified, check documentation.\nUse --help option for more information.\n";
		exit(0);
	};
	if (defined $mail)
	{
		$self->{_mail} = 1;
	}
	else
	{
		$self->{_mail} = 0;
	};
	if (defined $verbose)
	{
		$self->{_verbose} = 1;
	}
	else
	{
		$self->{_verbose} = 0;
	};
	if (defined $configfile)
	{
		$self->{_configfile} = $configfile;
		$self->{_dbfile} = $configfile;
		$self->{_dbfile} =~ s/\W//g;
	}
	else
	{
		$self->{_configfile} = "/etc/bck/bck.config";
		$self->{_dbfile} = "status";
	};
	if (defined $install)
	{
		$self->{_install} = 1;
	}
	else
	{
		$self->{_install} = 0;
	};
	if (defined $update)
	{
		$self->{_update} = 1;
	}
	else
	{
		$self->{_update} = 0;
	};
	if (defined $check)
	{
		$self->{_check} = 1;
	}
	else
	{
		$self->{_check} = 0;
	};
	if (defined $debug)
	{
		$self->{_debug} = 1;
		$self->{_verbose} = 0;
	}
	else
	{
		$self->{_debug} = 0;
	};
	if (defined $do)
	{
		$self->{_do} = $do;
	}
	else
	{
		$self->{_do} = undef;
	};
	if (defined $version)
	{
		$self->{_version} = 1;
		return (0);
	}
	else
	{
		$self->{_version} = 0;
	};
	if (defined $help)
	{
		$self->{_help} = 1;
		return (0);
	}
	else
	{
		$self->{_help} = 0;
	};
	if (defined $pluginhelp)
	{
		$self->{_help} = 2;
		return (0);
	}
	else
	{
		$self->{_help} = 0;
	};
	if (defined $httpserver)
	{
		$self->{_http} = 1;
		if ( defined $reportserver )
		{
			$self->{_http} = 3;
		};
		return (0);
	}
	else
	{
		$self->{_http} = 0;
		if ( defined $reportserver )
		{
			$self->{_http} = 2;
		};
	};
	if (defined $report)
	{
		$self->{_report} = 1;
		return (0);
	}
	else
	{
		$self->{_report} = 0;
	};
	if ( not ( -f $self->{_configfile} ) )
	{
		print "Config file (" . $self->{_configfile} . ") does not exist, check documentation.\nUse --help option for more information.\n";
		exit(0);
	};
	if ( not ( -r $self->{_configfile} ) )
	{
		print "Config file (" . $self->{_configfile} . ") cannot be read, check file permissions.\nUse --help option for more information.\n";
		exit(0);
	};
	return($status);
};
##################################################################################
# End Class CommandLine
##################################################################################
##################################################################################
#
# Class GlobalSection : Global configuration file section class
#
##################################################################################
package GlobalSection;
sub new
{
	my ( $class ) = shift;
	my ( $configfilename)  =  $cmdln->GetConfigFileName();
	my ( $lang, $client, $sysloglevel, $ntpserver,$ipwebaddress );
	my ( $logdir,$dbdir,$tempdir, $oktag, $errortag, $warningtag );
	if (-r $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
		unless ($cfg)
		{
			die "Error in loading configuration file `$configfilename'\n Use --check option for detailed information\n";
		}
		$lang		= $cfg->val('global', 'lang');
		$client		= $cfg->val('global', 'client');
		$sysloglevel = $cfg->val('global', 'sysloglevel');
		$ntpserver	= $cfg->val('global', 'ntpserver');
		$ipwebaddress = $cfg->val('global', 'ipwebaddress');
		$logdir		= $cfg->val('global', 'logdir');
		$dbdir		= $cfg->val('global', 'dbdir');
		$tempdir	= $cfg->val('global', 'tempdir');
		$oktag		= $cfg->val('global', 'oktag');
		$errortag	= $cfg->val('global', 'errortag');
		$warningtag	= $cfg->val('global', 'warningtag');
	};
	my $self =
	{
		_lang		=> $lang,
		_client		=> $client,
		_sysloglevel => $sysloglevel,
		_ntpserver	=> $ntpserver,
		_ipwebaddress	=> $ipwebaddress,
		_logdir		=> $logdir,
		_dbdir		=> $dbdir,
		_tempdir	=> $tempdir,
		_oktag		=> $oktag,
		_errortag	=> $errortag,
		_warningtag => $warningtag
	};
	bless $self, $class;
	return $self;
};
#accessor method for oktag
sub GetOktag
{
	my ( $self ) = shift;
	return $self->{_oktag};
};
#accessor method for errortag
sub GetErrortag
{
	my ( $self ) = shift;
	return $self->{_errortag};
};
#accessor method for warningtag
sub GetWarningtag
{
	my ( $self ) = shift;
	return $self->{_warningtag};
};
#accessor method for tempdir
sub GetTempDir
{
	my ( $self ) = shift;
	return $self->{_tempdir};
};
#accessor method for logdir
sub GetLogDir
{
	my ( $self ) = shift;
	return $self->{_logdir};
};
#accessor method for dbdir
sub GetDbDir
{
	my ( $self ) = shift;
	return $self->{_dbdir};
};
#accessor method for lang
sub GetLang
{
	my ( $self ) = shift;
	return $self->{_lang};
};
#accessor method for client
sub GetClient
{
	my ( $self ) = shift;
	return $self->{_client};
};
#accessor method for sysloglevel
sub GetSysLogLevel
{
	my ( $self ) = shift;
	return $self->{_sysloglevel};
};
#accessor method for ntpserver
sub GetNtpServer
{
	my ( $self ) = shift;
	return $self->{_ntpserver};
};
#accessor method for webipaddress
sub GetIpWebAddress
{
	my ( $self ) = shift;
	return $self->{_ipwebaddress};
};
##################################################################################
# End Class GlobalSection
##################################################################################
##################################################################################
#
# Class HttpSection : Http configuration file section class
#
##################################################################################
package HttpSection;
sub new
{
	my ($class) = shift;
	my ($configfilename) =  $cmdln->GetConfigFileName();
	my ($user, $password, $reportlines);
	if (-r $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			$mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			$cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg = Config::IniFiles->new( -file => $configfilename );
		};
		unless ($cfg)
		{
			die "Error in loading configuration file `$configfilename'\n Use --check option for detailed information\n";
		}
		$user			= $cfg->val('http', 'user');
		$password		= $cfg->val('http', 'password');
		$reportlines	= $cfg->val('http', 'reportlines');
	};
	my $self =
	{
		_user			=> $user,
		_password		=> $password,
		_reportlines	=> $reportlines
	};
	bless $self, $class;
	return $self;
};
#accessor method for user
sub GetUser
{
	my ( $self ) = shift;
	return $self->{_user};
};
#accessor method for password
sub GetPassword
{
	my ( $self ) = shift;
	return $self->{_password};
};
#accessor method for reportlines
sub GetReportlines
{
	my ( $self ) = shift;
	return $self->{_reportlines};
};
##################################################################################
# End Class http Section
##################################################################################
##################################################################################
#
# Class ReportSection : Http configuration file section class
#
##################################################################################
package ReportSection;
sub new
{
	my ($class) = shift;
	my ($configfilename) =  $cmdln->GetConfigFileName();
	my ($server, $port, $password, $serverpassword);
	if (-r $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
		unless ($cfg)
		{
			die "Error in loading configuration file `$configfilename'\n Use --check option for detailed information\n";
		}
		$server			= $cfg->val('report', 'server');
		$port			= $cfg->val('report', 'port');
		$password		= $cfg->val('report', 'password');
		$serverpassword		= $cfg->val('report', 'serverpassword');
	};
	my $self =
	{
		_server			=> $server,
		_port			=> $port,
		_password		=> $password,
		_serverpassword		=> $serverpassword
	};
	bless $self, $class;
	return $self;
};
#accessor method for server
sub GetServer
{
	my ( $self ) = shift;
	return $self->{_server};
};
#accessor method for port
sub GetPort
{
	my ( $self ) = shift;
	return $self->{_port};
};
#accessor method for password
sub GetPassword
{
	my ( $self ) = shift;
	return $self->{_password};
};
#accessor method for password
sub GetServerPassword
{
	my ( $self ) = shift;
	return $self->{_serverpassword};
};
##################################################################################
# End Class report Section
##################################################################################
##################################################################################
#
# Class DbFile : Read/Write database file class
#
##################################################################################
#
# status database field def:
#
# |Status bits|,|Section Name|,|Section Description|,|Timestamp|,|Status|,|Size|,|Dest size|,|Dest free|,|infotext|
#      |                                                 |          |       |         |         |             -> Short description of what was done
#      |                                                 |          |       |         |         -> Bytes free on destination
#      |                                                 |          |       |         -> Size of destination in bytes
#      |                                                 |          |       -> Size of setion
#      |                                                 |          -> Text field status [OK, ERROR, Warning]
#      |                                                 -> Internal timestamp format ddmmyyyyhhmm
#      -> 8 bits [7 6 5 4 3 2 1 0]
#         Bit 0 : 0-Not send by mail            1-Send by mail                 (1)
#         Bit 1 : 0-Not send to remote server   1-Send to remote server        (2)
#         Bit 2 : 0-Line                        1-Header                       (4)
#         Bit 3&4 : 00-OK  01-Warning  10-ERROR  11-Not Available [Defines color used in Status column] (8&16)
#         Bit 5 : 0-Finished		1-In progress                                      (32)
#         Bit 6 : 0-No alarm               1-Alarm                                               (64)
#         Bit 7 : 0-Local 1-Remote                                             (128)
#
##################################################################################
package DbFile;
# We use tied arrays as this allows us to modify anywhere in the file
use Tie::File;
sub new
{
	my ( $class ) = shift;
	my $self =
	{
		# Public values
		_file		=> undef, # string :path/filename of database file
		_mailrep	=> 0, # 1 bit  -
		_commrep	=> 0, # 1 bit   |
		_isheader	=> 0, # 1 bit   |-> statusbits [ 8 bits ]
		_status		=> 0, # 2 bits  |
		_alarm		=> 0, # 1 bit   |
		_finished	=> 0, # 1 bit  |
		_isremote	=> 0, # 1 bit  -
		_section	=> "", # string
		_name		=> "", # string
		_timestamp	=> 0, # string : Internal timestamp (will change to unix timestamp)
		_statustext	=> "", # string
		_size		=> 0, # integer
		_destsize	=> 0, # integer
		_destfree	=> 0, # integer
		_infotext	=> 0, # string
		# Private values
		_statusbits	=> 0  # bit array as defined above
	};
	bless $self, $class;
	return $self;
};
#######################################################################################
#
# ReadLast : Read the last n lines and return an array, used for web interface
#
# Input validation : OK (BV 11/07/2009)
#
#######################################################################################
sub ReadLast # ( numlines, page ) -> ( @lines )
{
	my ( $self ) = shift;
	my ( $numlines ) = shift;
	my ( $page ) = shift;
	my ( $line, $date, @lines, @lastlines );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	# Get the number of lines in the file
	my ( $totallines ) = scalar @lines;
	$page = 1 unless $page;
	my ( $firstline ) = ( $page - 1 ) * $numlines;
	my ( $lastline ) = $firstline + $numlines;
	my ( $counter ) = $firstline;
	# Check that we don't get more lines than in file
	if ( $lastline > $totallines )
	{
		$lastline = $totallines;
	};
	# Get the lines from the end of the file
	while ( $counter < $lastline )
	{
		# Get the line
		$line = $lines[ ( $totallines - 1 ) - $counter ];
		# validate the line
		$line = ::StrCl( $line );
		# Split into variables
		my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree, $infotext ) = split( /,/,$line );
		# Validate the file data read
		$line = ::StrCl( $line );
		$statusbits = ::StrCl( $statusbits );
		$section = ::StrCl( $section );
		$name = ::StrCl( $name );
		$timestamp = ::NumCl( $timestamp );
		$statustext = ::StrCl( $statustext );
		$size = ::NumCl( $size );
		$destsize = ::NumCl( $destsize );
		$destfree = ::NumCl( $destfree );
		$infotext = ::StrCl( $infotext );
		# Prepare the variables in one line
		$line = $statusbits . "," . $section . "," . $name . "," . $timestamp . "," . $statustext . "," . $size . "," . $destsize . "," . $destfree . "," . $infotext . "," . ( ( $totallines - 1 ) - $counter );
		# Put them in our array
		push( @lastlines,  $line );
		# Count lines
		$counter++;
	};
	undef $ar;
	untie @lines;
	return( @lastlines );
};
#######################################################################################
#
# GetNumLines : Get the number of lines in the file
#
# Input validation : PENDING!
#
#######################################################################################
sub GetNumLines # ( ) -> ( $numlines )
{
	my ( $self ) = shift;
	my ( @lines );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	# Get the number of lines in the file
	my ( $totallines ) = scalar @lines;
	undef $ar;
	untie @lines;
	return( $totallines );
};
#######################################################################################
#
# AddLine : Add line to end of file
#
# Input validation : OK (BV 23/7/2009)
#
#######################################################################################
sub AddLine # ( ) -> ( )
{
	my ( $self ) = shift;
	my ( $line, @lines );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	$self->{_statusbits} = ::NumCl( $self->{_statusbits} );
	$self->{_section} = ::StrCl( $self->{_section} );
	$self->{_name} = ::StrCl( $self->{_name} );
	$self->{_timestamp} = ::NumCl( $self->{_timestamp} );
	$self->{_statustext} = ::StrCl( $self->{_statustext} );
	$self->{_size} = ::NumCl( $self->{_size} );
	$self->{_destsize} = ::NumCl( $self->{_destsize} );
	$self->{_destfree} = ::NumCl( $self->{_destfree} );
	$self->{_infotext} = ::StrCl( $self->{_infotext} );
	$ar->flock();
	$line = $self->{_statusbits} . "," . $self->{_section} . "," . $self->{_name} . "," . $self->{_timestamp} . "," . $self->{_statustext} . "," . $self->{_size} . "," . $self->{_destsize} . "," . $self->{_destfree} . "," . $self->{_infotext};
	push( @lines, $line );
	undef $ar;
	untie @lines;
	return();
};
#######################################################################################
#
# WriteLine : Write line number $linenum in place
#
# Input validation : PENDING!
#
#######################################################################################
sub WriteLine # ( $linenum  ) -> () 
{
	my ( $self ) = shift;
	my ( $linenum ) = shift;
	my ( @lines );
	# Tie the file to an array
	my ( $line );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	$ar->flock();
	$line = $self->{_statusbits} . "," . $self->{_section} . "," . $self->{_name} . "," . $self->{_timestamp} . "," . $self->{_statustext} . "," . $self->{_size} . "," . $self->{_destsize} . "," . $self->{_destfree} . "," . $self->{_infotext};
	$lines[ $linenum ] = $line;
	undef $ar;
	untie @lines;
	return();
};
#######################################################################################
#
# ReadLine : Read line number "n"
#
# Input validation : OK (BV 11/7/2009)
#
#######################################################################################
sub ReadLine # ( $linenum  ) -> ( $line ) 
{
	my ( $self ) = shift;
	my ( $linenum ) = shift;
	my ( $line, @lines );
	# Tie the file to an array
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	$line = $lines[ $linenum ];
	undef $ar;
	untie @lines;
	chomp( $line );
	# Validate the line read
	$line = ::StrCl( $line );
	( $self->{_statusbits}, $self->{_section}, $self->{_name}, $self->{_timestamp}, $self->{_statustext}, $self->{_size}, $self->{_destsize}, $self->{_destfree}, $self->{_infotext} ) = split( /,/, $line );
	# Validate the file data read
	$self->{_statusbits} = ::StrCl( $self->{_statusbits} );
	$self->{_section} = ::StrCl( $self->{_section} );
	$self->{_name} = ::StrCl( $self->{_name} );
	$self->{_timestamp} = ::NumCl( $self->{_timestamp} );
	$self->{_statustext} = ::StrCl( $self->{_statustext} );
	$self->{_size} = ::NumCl( $self->{_size} );
	$self->{_destsize} = ::NumCl( $self->{_destsize} );
	$self->{_destfree} = ::NumCl( $self->{_destfree} );
	$self->{_infotext} = ::StrCl( $self->{_infotext} );
	return( $line );
};
#######################################################################################
#
# FindLines : Get a list of lines with bit $bit set, added the line number as the first
#             element in the array
#
# Input validation : PENDING!
#
#######################################################################################
sub FindLines # ( $bit, $bitvalue ) -> ( @lines )
{
	my ( $self ) = shift;
	my ( $bit ) = shift;
	my ( $bitvalue ) = shift; # TRUE or FALSE
	# Convert bit position to the byte with bit set
	$bit = ( 2 ** $bit );
	my ( $line, @lines, @pendinglines );
	my ( $counter ) = 0;
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	foreach $line ( @lines )
	{
		# Validate the lines read
		$line = ::StrCl( $line );
		my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree, $infotext ) = split( /,/,$line );
		# Validate the values read
		$statusbits = ::NumCl( $statusbits );
		$section = ::StrCl( $section );
		$name = ::StrCl( $name );
		$timestamp = ::NumCl( $timestamp );
		$statustext = ::StrCl( $statustext );
		$size = ::NumCl( $size );
		$destsize = ::NumCl( $destsize );
		$destfree = ::NumCl( $destfree );
		$infotext = ::StrCl( $infotext );
		if ( ( $statusbits & $bit ) == $bitvalue ) # check if bit 0 set
		{
			push( @pendinglines, ( $counter . "," . $line ) );
		};
		$counter++;
	};
	undef $ar;
	untie @lines;
	return( @pendinglines );
};
#######################################################################################
#
# UpdateStatusBits
#
# Input validation : PENDING!
#
#######################################################################################
sub UpdateStatusBits # ( $bit, $bitvalue, \@lines ) -> ()
{
	my ( $self ) = shift;
	my ( $bit ) = shift;
	my ( $bitvalue ) = shift;
	my ( $updatelines ) = shift;
	my ( @lines );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	$ar->flock();
	$bit = ( 2 ** $bit );
	foreach my $line ( @{$updatelines} )
	{
		my ( $id );
		( $id, $self->{_statusbits}, $self->{_section}, $self->{_name}, $self->{_timestamp}, $self->{_statustext}, $self->{_size}, $self->{_destsize}, $self->{_destfree}, $self->{_infotext} ) = split( /,/, $line );
		if  ( $bitvalue eq 1 )
		{
			$self->{_statusbits} = ( $self->{_statusbits} | $bit );
		}
		else
		{
			$self->{_statusbits} = ( $self->{_statusbits} ^ $bit );
		}
		$line = $self->{_statusbits} . "," . $self->{_section} . "," . $self->{_name} . "," . $self->{_timestamp} . "," . $self->{_statustext} . "," . $self->{_size} . "," . $self->{_destsize} . "," . $self->{_destfree} . "," . $self->{_infotext};
		$lines[ $id ] = $line;	
	};
	undef $ar;
	untie @lines;
	return()
};
sub SetFile
{
	my ( $self ) = shift;
	$self->{_file} = shift;
	return();
};
sub SetMailrep
{
	my ( $self ) = shift;
	$self->{_mailrep} = shift;
	if ( $self->{_mailrep} eq 1 )
	{
		# Set bit 0 to 1
		$self->{_statusbits} = $self->{_statusbits} | 1
	}
	else
	{
		# Set bit 0 to 0
		$self->{_statusbits} = $self->{_statusbits} ^ 1
	};
	return();
};
sub SetCommrep
{
	my ( $self ) = shift;
	$self->{_commrep} = shift;
	if ( $self->{_commrep} eq 1 )
	{
		# Set bit 1 to 1
		$self->{_statusbits} = $self->{_statusbits} | 2
	}
	else
	{
		# Set bit 1 to 0
		$self->{_statusbits} = $self->{_statusbits} ^ 2
	};
	return();
};
sub SetIsHeader
{
	my ( $self ) = shift;
	$self->{_isheader} = shift;
	if ( $self->{_isheader} eq 1 )
	{
		# Set bit 2 to 1
		$self->{_statusbits} = $self->{_statusbits} | 4
	}
	else
	{
		# Set bit 2 to 0
		$self->{_statusbits} = $self->{_statusbits} ^ 4
	};
	return();
};
sub SetStatus
{
	my ( $self ) = shift;
	$self->{_status} = shift;
	# Shift the bits into position
	my ( $var ) = $self->{_status} << 3;
	# Set bits 3 & 4 to 0
	$self->{_statusbits} = $self->{_statusbits} & 231;
	# Set bits 3 & 4
	$self->{_statusbits} = $self->{_statusbits} | $var;
	return();
};
sub SetIsRemote
{
	my ( $self ) = shift;
	$self->{_isremote} = shift;
	if ( $self->{_isremote} eq 1 )
	{
		# Set bit 7 to 1
		$self->{_statusbits} = $self->{_statusbits} | 128
	}
	else
	{
		# Set bit 7 to 0
		$self->{_statusbits} = $self->{_statusbits} ^ 128
	};
	return();
};
sub SetName
{
	my ( $self ) = shift;
	$self->{_name} = shift;
	return();
};
sub SetSection
{
	my ( $self ) = shift;
	$self->{_section} = shift;
	return();
};
sub SetTimeStamp
{
	my ( $self ) = shift;
	$self->{_timestamp} = shift;
	return();
};
sub SetStatusText
{
	my ( $self ) = shift;
	$self->{_statustext} = shift;
	return();
};
sub SetSize
{
	my ( $self ) = shift;
	$self->{_size} = shift;
	return();
};
sub SetDestSize
{
	my ( $self ) = shift;
	$self->{_destsize} = shift;
	return();
};
sub SetDestFree
{
	my ( $self ) = shift;
	$self->{_destfree} = shift;
	return();
};
sub SetInfoText
{
	my ( $self ) = shift;
	$self->{_infotext} = shift;
	return();
};
sub GetFile
{
	my ( $self ) = shift;
	return( $self->{_file} );
};
sub GetMailrep
{
	my ( $self ) = shift;
	return( $self->{_mailrep} );
};
sub GetCommrep
{
	my ( $self ) = shift;
	return( $self->{_commrep} );
};
sub GetIsHeader
{
	my ( $self ) = shift;
	return( $self->{_isheader} );
};
sub GetStatus
{
	my ( $self ) = shift;
	return( $self->{_status} );
};
sub GetIsRemote
{
	my ( $self ) = shift;
	return( $self->{_isremote} );
};
sub GetName
{
	my ( $self ) = shift;
	return( $self->{_name} );
};
sub GetSection
{
	my ( $self ) = shift;
	return( $self->{_section} );
};
sub GetTimeStamp
{
	my ( $self ) = shift;
	return( $self->{_timestamp} );
};
sub GetHTimeStamp
{
	my ( $self ) = shift;
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( $self->{_timestamp} );
	my ($date ) = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . sprintf( "%02d:%02d:%02d" , $hour, $min, $sec );
	return( $date );
};
sub GetStatusText
{
	my ( $self ) = shift;
	return( $self->{_statustext} );
};
sub GetSize
{
	my ( $self ) = shift;
	return( $self->{_size} );
};
sub GetDestSize
{
	my ( $self ) = shift;
	return( $self->{_destsize} );
};
sub GetDestFree
{
	my ( $self ) = shift;
	return( $self->{_destfree} );
};
sub GetInfoText
{
	my ( $self ) = shift;
	return( $self->{_infotext} );
};
##################################################################################
# End Class DbFile
##################################################################################
##################################################################################
#
# Class DoSection : Backup command block class
#
##################################################################################
package DoSection;
use File::Path;
use File::Copy;
use File::Temp qw/ tempfile tempdir /;
our @ISA = qw( DbFile );	# inherits from DbFile
sub new
{
	my ($class) = shift;
	my $self =
	{
		_section	=> undef,
		_type		=> undef,
		_name		=> undef,
		_param		=> {},
		_status   	=> 0,
		_infotext	=> undef,
	   	_size	   	=> 0,
		_flagsize	=> undef,
		_flagfail	=> undef,
		_logdate	=> undef,
		_starttime  => undef,
		_endtime	=> undef,
		_debug	  	=> undef,
		_verbose	=> undef,
		_html		=> "0",
		_destsize	=> 0,
		_destfree	=> 0
	};
	bless $self, $class;
	return $self;
};
#load method for section load from file
sub LoadSection
{
	my ( $self ) = shift;
	my ( $configfilename ) = @_;
	my ( $cfg, $mastercfg );
	if ( -r "/etc/bck/bck.default" )
	{
		  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
		  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
	}
	else
	{
		$cfg 	= Config::IniFiles->new( -file => $configfilename );
	};
	if ($cfg->SectionExists ( $self->{_section} ) )
	{
		#We set these two values for easy accessing
		$self->{_name} = $cfg->val( $self->{_section}, 'name' );
		$self->{_type} = $cfg->val( $self->{_section}, 'type' );
		#Create a hash with parameters and values
		my ( @param )	 = $cfg->Parameters( $self->{_section} );
		foreach my $par ( @param )
		{
			$self->{_param}{$par} = $cfg->val( $self->{_section}, $par );
		}
		return (0);
	}
	else
	{
		return(1);
	};
};
#accessor method for section
sub SetSection
{
	my ( $self ) = shift;
	my ( $section ) = @_;
	$self->{_section} = $section if defined($section);
};
#accessor method for starttime
sub SetStarttime
{
	my ( $self ) = shift;
	my ( $starttime ) = @_;
	$self->{_starttime} = $starttime if defined($starttime);
};
#accessor method for endtime
sub SetEndtime
{
	my ( $self ) = shift;
	my ( $endtime ) = @_;
	$self->{_endtime} = $endtime if defined($endtime);
};
#accessor method for starttime
sub GetStarttime
{
	my ( $self ) = shift;
	return( $self->{_starttime} );
};
#accessor method for endtime
sub GetEndtime
{
	my ( $self ) = shift;
	return( $self->{_endtime} );
};
sub GetName
{
	my ( $self ) = shift;
	return( $self->{_name} );
};
#accessor method for logdate
sub SetLogDate
{
	my ( $self ) = shift;
	my ( $logdate ) = @_;
	$self->{_logdate} = $logdate if defined($logdate);
};
#accessor method for logdate
sub GetLogDate
{
	my ( $self ) = shift;
	return ( $self->{_logdate} );
};
#accessor method for section
sub GetSection
{
	my ( $self ) = shift;
	return $self->{_section};
};
#accessor method for status
sub SetStatus
{
	my ( $self ) = shift;
	my ( $status ) = @_;
	$self->{_status} = $status if defined( $status );
};
#accessor method for status
sub GetStatus
{
	my ( $self ) = shift;
	return $self->{_status};
};
#accessor method for type
sub GetType
{
	my ( $self ) = shift;
	return $self->{_type};
};
#accessor method for size
sub GetDestsize
{
	my ( $self ) = shift;
	return $self->{_destsize};
};
#accessor method for size
sub GetDestfree
{
	my ( $self ) = shift;
	return $self->{_destfree};
};
#accessor method for size
sub GetSize
{
	my ( $self ) = shift;
	return $self->{_size};
};
#accessor method for maxsize
sub DebugPrint
{
	my ( $self ) = shift;
	my ( $string ) = @_;
	if ( $self->{_debug} )
	{
		print $string . "\n";
	};
};
sub VerbosePrint
{
	my ( $self ) = shift;
	my ( $string ) = @_;
	if ( $self->{_verbose} )
	{
		if ( ! $self->{_debug} )
		{
			print $string . "\n";
		};
	};
};
#accessor method for debug
sub SetDebug
{
	my ( $self ) = shift;
	my ( $debug ) = @_;
	$self->{_debug} = $debug;
};
#accessor method for debug
sub SetVerbose
{
	my ( $self ) = shift;
	my ( $verbose ) = @_;
	$self->{_verbose} = $verbose;
};
sub WriteLog
{
	my ( $self ) = shift;
	my ( $text, $lvl ) = @_;
	if ( defined $self->{_logdate} )
	{
		$self->DebugPrint( "[" . time . "] - " . $text );
		if ( $lvl lt "2" )
		{
			$self->VerbosePrint( "[" . time . "] - " . $text );
		};
		open ( LOGFILE, ">>" . $gsection->GetLogDir() . '/' . $self->{_section} . '.' . $self->{_logdate} . ".log" );
	   	print LOGFILE "[" . time . "] - " . $text . "\n";
		close( LOGFILE );
	};
};
sub WriteList
{
	my ( $self ) = shift;
	my ( $text ) = @_;
	if ( defined $self->{_logdate} )
	{
		$self->DebugPrint( "[" . time . "] - " . $text );
		open ( LOGFILE, ">>" . $gsection->GetLogDir() . '/' . $self->{_section} . '.' . $self->{_logdate} . ".lst" );
	   	print LOGFILE $text . "\n";
		close( LOGFILE );
	};
};
sub LabelDir
{
	my ( $self ) = shift;
	my ( $dir, $label ) = @_;
	my ( $filename ) = $dir . "/__LABEL__";
	open ( LABELFILE, ">". $filename );
	print LABELFILE $label;
	close( LABELFILE );
	return(0);
};
##################################################################################
sub WriteDb
{
	my ( $self ) = shift;
	my ( $status, $date );
	my ( $db ) = DbFile->new();
	my ( $dbfile ) =  $cmdln->GetStatusFileName();
	$db->SetFile( $gsection->GetDbDir() . '/'  . "$dbfile" . '.db' );
	$date = $self->GetLogDate();
	if ( defined $self->GetName() )
	{
		$status = "OK";
		$db->SetStatus( 0 );
	}
	else
	{
		$status = "INVALID";
		$self->{_name} = " ";
		$self->{_size} = "0";
		$db->SetStatus( 3 ); # 11
	};
	if ( $self->{_status} == 1 )
	{
		$status = "Warning";
		$db->SetStatus( 1 ); # 01
	};
	if ( $self->{_status} == 2 )
	{
		$status = "ERROR";
		$db->SetStatus( 2 ); # 10
	};
	if ( $self->{_status} == 3 )
	{
		$status = "INVALID";
		$db->SetStatus( 3 ); # 11
	};
	$db->SetSection( $self->GetSection() );
	$db->SetName( $self->GetName() );
	$db->SetTimeStamp( $date );
	$db->SetStatusText( $status );
	$db->SetSize( $self->{_size} );
	$db->SetDestSize( $self->{_destsize} );
	$db->SetDestFree( $self->{_destfree} );
	$db->SetInfoText( $self->{_infotext} );
	$db->AddLine();
	return (0);
};

############################################################################
#
# Sub Run : Call the plugin and run it
#
############################################################################
sub Run
{
	my ( $self ) = shift;
	# Start crono
	use FindBin qw( $Bin $Script );
	use File::Basename;
	$self->{_starttime} = time();
	my ( $path ) = $Bin;
	my ( $name ) = $Script;
		if ( -l "$path/$name" )
	{
		my ( $link ) = readlink "$path/$name";
		$path = dirname( $link );
		$name = basename( $link );
	};
	# We construct the $plugin string based on "type"
	my ( $plugin ) = "$path/plugins/$self->{_type}.pm";
	# If the plugin and plugin folder exist, we continue
	if ( ( -d "$path/plugins" ) and ( -e "$plugin" ) )
	{
		# Set lib folder to find the plugins
		use lib '$path/plugins';
		# Try to load the plugin
		if ( require "$plugin" )
		{
			my( $do ) = Plugin->new( $self->{_section}, sub{$self->WriteLog( $_[0], $_[1] )}, sub{$self->WriteList( $_[0] )}, $self->{_param} );
			foreach my $key ( keys %{$do->{_required}} )
			{
				if ( !defined ${$self->{_param}}{$key} )
				{
					$self->{_status} = 1;
					$self->WriteLog( "ERROR: \"$key\" is required and not defined. ( ${$do->{_required}}{$key} )", 0 );
				}
				else
				{
					$self->WriteLog( " Value of \"$key\" (required) = ${$self->{_param}}{$key}", 5 );
				};
			};
			foreach my $key ( keys %{$do->{_optional}} )
			{
				if ( defined ${$self->{_param}}{$key} )
				{
					$self->WriteLog( " Value of \"$key\" (optional) = ${$self->{_param}}{$key}", 5 );
				};
			};
			if ( $self->{_status} == 0 )
			{
				# Run the plugin and get back the results
				( $self->{_status}, $self->{_infotext}, $self->{_size}, $self->{_destfree}, $self->{_destsize} ) = $do->Run();
			}
		}
		else
		{
			$self->WriteLog( "Error loading plugin $plugin\n", 1 );
		}
		if ( not defined $self->{_status} )
		{
			$self->{_status} = 3;
		};
	};
	# Stop crono
	$self->{_endtime} = time();
	return( $self->{_status}, $self->{_infotext} );
};
##################################################################################
# End Class DoSection
##################################################################################
##################################################################################
#
# Class SysCommand : Command line execution class
#
##################################################################################
package SysCommand;
sub new
{
	my ($class) = shift;
	my $self =
	{
			_cmd		=> undef, #command to execute
			_status		=> 0,	#exit status of command
		};
	bless $self, $class;
	return $self;
};
##################################################################################
#
# Run : Run the command
#
##################################################################################
sub Run # ( $command, $outputparser ) -> ( $status )
{
	my ( $self ) = shift;
	# Get the command line we are going to execute
	$self->{_cmd} = shift;
	# Get a reference to the sub to be called on every line of output
	my ( $outputparser ) = shift;
	# Open a pipe to standard input as a file and read data from it
	open (DATA, "$self->{_cmd} 2>&1 |" ) or $self->{_status} = 1;
	if ( $self->{_status} == 0 )
	{
		while ( defined ( my $line = <DATA> )  )
		{
			chomp($line);
			&$outputparser( $line );
		};
		close DATA;
		$self->{_status} = $? >> 8;
	};
	return( $self->{_status} );
};
sub GetStatus
{
	my ( $self ) = shift;
	return $self->{_status};
};
##################################################################################
# End Class SysCommand
##################################################################################
##################################################################################
#
# Class Report : Report summary class
#
##################################################################################
package Report;
use MIME::QuotedPrint;
use Sys::Syslog;
# Configuration for perl module Mail::Sendmail
our @ISA = qw(TableLine Mail);	# inherits from TableLine, Mail
sub new
{
	my ( $class ) = shift;
	my ( $level );
	my $self =
	{
		_title		=> undef,
		_mail		=> [],
		_table		=> [],
		_ip		=> "",
		_state		=> 0,
	};
	bless $self, $class;
	return $self;
};
#accessor method for ip
sub SetIP
{
	my ( $self ) = shift;
	my ( $ip ) = @_;
	$self->{_ip} = $ip;
};
#accessor method for ip
sub GetIP
{
	my ( $self ) = shift;
	return ( $self->{_ip} );
};
#accessor method for title
sub SetTittle
{
	my ( $self ) = shift;
	my ( $title ) = @_;
	$self->{_title} = $title;
};
#accessor method for state
sub GetState
{
	my ( $self ) = shift;
	return ( $self->{_state} );
};
#accessor method for state
sub SetState
{
	my ( $self ) = shift;
	my ( $state ) = @_;
	if ( $self->{_state} < $state )
	{
		$self->{_state} = $state;
	};
};
#accessor method for table array
sub AddTable
{
	my ( $self ) = shift;
	my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree) = @_;
	if( $section ne "" )
	{
		push( @{$self->{_table}}, TableLine->new( $section, $name, $timestamp, $status, $size, $destsize, $destfree ) );
	};
};
#accessor method for mail array
sub AddMail
{
	my ( $self ) = shift;
	my ( $address, $level, $mode ) = @_;
	push( @{$self->{_mail}}, Mail->new( $address, $level, $mode ) );
};
sub SendReports
{
	my ( $self ) = shift;
	my ( $mail );
	my ( $mailstat ) = 1;
	my ( $subject ) = "[" . $gsection->GetErrortag() . "] Backup report (" . $gsection->GetClient() . ")";
	if ( $self->GetState() == 0 )
	{
		$subject = "[" . $gsection->GetOktag() . "] Backup report (" . $gsection->GetClient() . ")";
	}
	elsif ( $self->GetState() == 1 )
	{
		$subject = "[". $gsection->GetWarningtag() . "] Backup report (" . $gsection->GetClient() . ")";
	}
	elsif ( $self->GetState() == 2 )
	{
		$subject = "[" . $gsection->GetErrortag() . "] Backup report (" . $gsection->GetClient() . ")";
	};
	# Get mailtext from config file, if it points to a file, read it and get the text into $mailtext
	my ( $cfg, $mastercfg );
	my ( $configfilename ) = cmdln->GetConfigFileName();
	if ( -r "/etc/bck/bck.default" )
	{
		  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
		  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
	}
	else
	{
		$cfg 	= Config::IniFiles->new( -file => $configfilename );
	};
	my ( $mailtext ) = $cfg->val('global', 'mailtext');
	if ( not defined $mailtext )
	{
		$mailtext = "";
	}; 
	if ( -e $mailtext )
	{
		if ( (-r $mailtext) && (-T $mailtext) )
		{
			my ( $string );
			local $/=undef;
			open FILE, "<", $mailtext or die $!;
			$string = <FILE>;
			close FILE;
			$mailtext = $string;
		}	
		else
		{
			$mailtext = "...";
		};
	}
	foreach $mail ( @{$self->{_mail}} )
	{
		my ( $address, $level, $mode ) = $mail->Get();
		if ( ( $level > 1 ) or ( $self->GetState() > 1 ) or ( ( $level == 1 ) and ( $self->GetState() == 1 ) ) )
		{
			my ( $tableentry, $html, $plaintext );
			my ( $tablestat ) = 0;
			$plaintext = "----------------------------------------------------------------\n"
			. "| " . sprintf("%-49s","Backup report ( Level : $level )") . "			|\n"
			. "----------------------------------------------------------------\n";
			$html = "<table style=\"width: 80%; text-align: left;\" border=\"2\" cellpadding=\"2\"\n"
			. "cellspacing=\"2\">\n"
			. "<tbody>"
			. "<tr align=\"center\">\n"
			. "<th colspan=\"4\" rowspan=\"1\" style=\"background-color: rgb(255, 255, 204); vertical-align: top;\">"
			. "<font size=\"+2\">Backup report </font>"
			. "<div align=\"right\"><font size=\"-2\" color=\"#888888\"> [ Level : $level - Version: $version - IP: " . $self->GetIP() . " ]</font></div>"
			. "\n"
			. "</th>\n"
			. "</tr>\n"
			. "<tr>\n"
			. "<th style=\"vertical-align: top; text-align: center;\">Operation<br>\n"
			. "</th>\n"
			. "<th style=\"vertical-align: top; width: 130px; text-align: center;\">Date/Time<br>\n"
			. "</th>\n"
			. "<th style=\"vertical-align: top; width: 120px; text-align: center;\">Size (Use%)<br>\n"
			. "</th>\n"
			. "<th style=\"vertical-align: top; width: 100px; text-align: center;\">Status<br>\n"
			. "</th>"
			. "</tr>\n";
			my ( $notempty ) = 0;
			foreach $tableentry ( @{$self->{_table}} )
			{
				$notempty = 1;
				my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree ) = $tableentry->Get();
				my ( $text ) = "[" . $section . "] " . $name;
				my ( $date ) = substr( $timestamp, 0,2 ) . "/" . substr( $timestamp, 2,2 ) . "/" . substr( $timestamp, 4,4 ) . " " . substr( $timestamp, 8,2 ) . ":" . substr( $timestamp, 10,2 );
				$plaintext .= "| " . sprintf("%-35s" ,$text . " Date : " . $date );
				$html .= "<tr>\n" . "<td style=\"vertical-align: top;\">$text<br>\n" . "</td>\n";
				$html .= "<td style=\"vertical-align: top;\">$date<br>\n" . "</td>\n";
				$html .= "<td style=\"vertical-align: middle; margin: 0 0 0 0; border: 1; padding: 0; width: 104px; background: rgb(120,120,255)\">";
				if ( $destsize ne 0 )
				{
					$html .= "<div>\n";
				};
				$html .= ::HumanBytes( $size );
				if ( $destsize ne 0 )
				{
					$html .= "&nbsp;(" . int( 100 - ($destfree / $destsize)*100) . "%)\n";
					$html .= "<div nowrap style=\"background: rgb(255,0,0); color: rgb(255,255,0); overflow: hidden; border: 1; margin: 0px 0px 0px 0px; height: 2px; padding: 0; width: " . int( 100 - ($destfree / $destsize)*100)  . "% \">";
					$html .= "</div>\n</div>\n";
				}
				$html .= "</td>\n";
				if ( $status eq "OK" )
				{
					$html .= "<td style=\"background-color: rgb(51, 255, 51); vertical-align: top; width: 100px; text-align: center;\">OK<br>\n";
					$plaintext .= "| " . sprintf("%11s"," - OK - ") . " |\n"
					. "----------------------------------------------------------------\n";
				}
				elsif ( $status eq "Warning" )
				{
					$html .= "<td style=\"background-color: rgb(255, 153, 0); vertical-align: top; width: 100px; text-align: center;\">Warning<br>\n";
					$plaintext .= "| " . sprintf("%11s","  Warning  ") . " |\n"
					. "----------------------------------------------------------------\n";
				}
				else
				{
					$html .= "<td style=\"background-color: rgb(255, 0, 0); vertical-align: top; width: 100px; text-align: center;\">ERROR<br>\n";
					$plaintext .= "| " . sprintf("%11s"," * ERROR * ") . " |\n"
					. "----------------------------------------------------------------\n"
					. "[ Level : $level - Version: $version - IP: " . $self->GetIP() . " ]";
				};
				$html .= "</td>\n"
				."</tr>\n";
			};
			$plaintext .= "\n";
			$plaintext .= $mailtext;
			$html .= "</tbody>\n" . "</table>\n" . "<br>\n";
			$html .= "<br>\n";
			$html .= "$mailtext<br>\n";
			if ( $mode  eq "html" )
			{
				$plaintext = "Only html reports for this e-mail";
			}
			elsif ( $mode eq "plain" )
			{
				$html = "Only plaintext reports for this e-mail";
			};
			if ( $notempty == 1 )
			{
				$mailstat = $self->MailReport( $address, $subject , $html, $plaintext, $self->GetState(), $level );
			}
			else
			{
				$mailstat = 1;
			};
		};
	};
	return ( $mailstat );
};
sub MailReport
{
	my ( $self ) = shift;
	my ( $mailaddr, $subject, $html, $plain, $state, $level ) = @_;
	my ( $rc );
	my ( $tableentry );
	my ( $configfilename ) =  $cmdln->GetConfigFileName();
	my ( $cfg, $mastercfg );
	if ( -r "/etc/bck/bck.default" )
	{
		  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
		  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
	}
	else
	{
		$cfg 	= Config::IniFiles->new( -file => $configfilename );
	};
	my ( $smtpserver ) = $cfg->val( 'global', 'smtpserver' );
	my ( $smtpuser )	= $cfg->val( 'global', 'smtpuser' );
	my ( $smtppass )	= $cfg->val( 'global', 'smtppass' );
	my ( $smtpfrom ) 	= $cfg->val( 'global', 'smtpfrom' );
	my ( $smtpport )	= $cfg->val( 'global', 'smtpport' );
	my $sm = SendMail->new( $smtpserver, $smtpport );
	#
	#
	# Set SMTP AUTH login profile.
	#
	$sm->setAuth($sm->AUTHLOGIN, $smtpuser , $smtppass);
	#$sm->setAuth($sm->AUTHPLAIN, $smtpuser , $smtppass );
	#
	# We set the debug mode to global debug flag [$cmdln->GetDebugFlag()].
	#
	if ( $cmdln->GetDebugFlag() )
	{
	    $sm->setDebug($sm->ON);
	}
	else
	{
	    $sm->setDebug($sm->OFF);
	}
	#
	# We set the sender.
	#
	$sm->From($smtpfrom);
	#
	# We set the subject.
	#
	$sm->Subject($subject);
	#
	# We set the recipient.
	#
	$sm->To($mailaddr);
	#
	# We set the mail headers
	#
	$sm->setMailHeader('X-Mailer', "bck mailobject " . $sm->version . "");
	$sm->setMailHeader('User-Agent', "bck $version");
	$sm->setMailHeader('Message-Id',"BCK". join("", ('a'..'z','A'..'Z', 0..9)[map rand $_, (62)x25]));
	my ($mytime);
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	$mytime = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . $hour . ":" . $min . ":" . $sec . " (" . ($wday) . ")";
	#$sm->setMailHeader('Date' , $mytime );
	#
	# We set the content of the mail.
	#
	# Set body content
	#
	$html = "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
		."<html>\n"
		."<head>\n"
		."<meta content=\"text/html; charset=ISO-8859-1\"\n"
		."http-equiv=\"content-type\">\n"
		."<title></title>\n"
		."</head>\n"
		."<body>\n"
		."$html"
		."</body>\n"
		."</html>\n";
	my($boundary) = "==__BCK__" . join("", ('a'..'z','A'..'Z', 0..9)[map rand $_, (62)x25]) . "__==";
	my ( $mailbody );
	$mailbody = 'Content-Type: multipart/alternative;';
	$mailbody .= "\r\n boundary=\"$boundary\"\r\n\r\n";
	$mailbody .= "--$boundary\r\n";
	$mailbody .= 'Content-Type: text/plain; charset=ISO-8859-1; format=flowed' . "\r\n";
	$mailbody .= 'Content-Transfer-Encoding: 7bit' . "\r\n\r\n";
	$mailbody .= $plain . "\r\n";
	$mailbody .= "--$boundary\r\n";
	$mailbody .= 'Content-Type: text/html; charset=ISO-8859-1;' . "\r\n";
	$mailbody .= 'Content-Transfer-Encoding: 7bit' . "\r\n\r\n";
	$mailbody .= $html . "\r\n\r\n";
	$mailbody .= "--$boundary--\r\n";
	$sm->setMailBody( $mailbody );
	# Clear attachments
	#$sm->clearAttach();
	#
	# Attach log as a file.
	#
	#$sm->Inline("log.txt", \$test);
	#
	# To attach config file, uncomment this.
	#
	if ( $level > 3 )
	{
		$sm->Inline( $configfilename );
	};
	if ( $level > 1 )
	{
		foreach $tableentry ( @{$self->{_table}} )
		{
			my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree ) = $tableentry->Get();
			$sm->Inline( $gsection->GetLogDir() . '/' . $section . '.' . $timestamp . '.log' );
		};
	};
	if ( $level > 2 )
	{
		foreach $tableentry ( @{$self->{_table}} )
		{
			my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree ) = $tableentry->Get();
			$sm->Attach( $gsection->GetLogDir() . '/' . $section . '.' . $timestamp . '.lst' );
		};
	};
	#
	# Check if the mail sent successfully or not.
	#
	if ($sm->sendMail() != 0)
	{
		$rc = 1;
	}
	else
	{
		$rc = 0;
	};
	return( $rc );
};
##################################################################################
# End Class Report
##################################################################################
##################################################################################
#
# Class Mail : Mail container class
#
##################################################################################
package Mail;
sub new
{
	my ( $class ) = shift;
	my ( $address, $level, $mode) = @_;
	my $self =
	{
		_address	=> $address,
		_lvl		=> $level,
		_mode 		=> $mode,
		};
	bless $self, $class;
	return $self;
};
#accessor method for address
sub Get
{
	my ( $self ) = shift;
	return ( $self->{_address}, $self->{_lvl}, $self->{_mode} );
};
##################################################################################
# End Class Mail
##################################################################################
##################################################################################
#
# Class TableLine : TableLine class
#
##################################################################################
package TableLine;
sub new
{
	my ( $class ) = shift;
	my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree) = @_;
	my $self =
	{
		_section	=> $section,
		_name		=> $name,
		_timestamp	=> $timestamp,
		_status		=> $status,
		_size		=> $size,
		_destsize	=> $destsize,
		_destfree	=> $destfree
		};
	bless $self, $class;
	return $self;
};
#accessor method for tableline
sub Get
{
	my ( $self ) = shift;
	return ( $self->{_section}, $self->{_name}, $self->{_timestamp}, $self->{_status}, $self->{_size}, $self->{_destsize}, $self->{_destfree} );
};
##################################################################################
# End Class TableLine
##################################################################################
##################################################################################
#
# Class SendMail : Sendmail object
#
##################################################################################
#
#
##################################################################################
#
# Code taken from perl modules below this line!
#
##################################################################################
package SendMail;
#===============================================================================
#
# Constructor:
#	$obj = new SendMail;
#	$obj = new SendMail($smtpserver);
#	$obj = new SendMail($smtpserver, $smtpport);
#
# Methods:
#	$obj->Attach($filename, [\$data]);
#	$obj->Bcc($bccemailadd1, [$bccemailadd2, ...]);
#	$obj->Cc($ccemailadd1, [$ccemailadd2, ...]);
#	$obj->ErrorsTo($errorstoadd1, [$errorstoadd2, ...]);
#	$obj->From($sender);
#	$obj->Inline($filename, [\$data]);
#	$obj->AUTHLOGIN;
#	$obj->AUTHPLAIN;
#	$obj->OFF;
#	$obj->ON;
#	$obj->ReplyTo($replytoadd1, [$replytoadd2, ...]);
#	$obj->Subject($subject);
#	$obj->To($recipient1, [$recipient2, ...]);
#	$obj->attach(\%hash);
#	$obj->clearAttach();
#	$obj->clearBcc();
#	$obj->clearCc();
#	$obj->clearTo();
#	$obj->createMailData();
#	$obj->getEmailAddress($emailaddstr);
#	$obj->getRcptLists();
#	$obj->isMailReady();
#	$obj->receiveFromServer(\*SOCKET);
#	$obj->reset();
#	$obj->sendMail();
#	$obj->sendToServer(\*SOCKET, $message);
#	$obj->setAuth($authtype, $userid, $password);
#	$obj->setDebug($obj->ON);
#	$obj->setError($errormessage);
#	$obj->setMailBody($htmlbody, $plainbody);
#	$obj->setMailHeader($mailheader, $mailheadervalue);
#	$obj->setSMTPPort($smtpport);
#	$obj->setSMTPServer($smtpserver);
#	$obj->version;
#
# *p/s: For more details, please refer to the description below.
#
#===============================================================================

#
# We are using Socket.pm to connect to the SMTP port.
#
use Socket;

#
# We are using MIME::Base64 and MIME::QuotedPrint to encode MIME data.
#
use MIME::Base64;
use MIME::QuotedPrint;

#use Exporter;
use strict;
#use vars qw($_LOCALHOST $VERSION $_MAILER @ISA @EXPORT @EXPORT_OK $_ERR);
#use vars qw($_DEFAULT_SMTP_PORT);
#@EXPORT = qw();
#@EXPORT_OK = qw();
my ($_LOCALHOST, $ver, $_MAILER,$_ERR,$_DEFAULT_SMTP_PORT);


#===============================================================================
#
# CONSTRUCTOR:	$obj = new SendMail;
#		$obj = new SendMail($smtpserver);
#		$obj = new SendMail($smtpserver, $smtpport);
#
# DESCRIPTION:	This is the constructor of the SendMail object.
#
#===============================================================================
sub new {
	my($pkg) 		= shift;
	my($smtpserver) 	= shift;
	my($smtpport) 	= shift;
	my($self) 		= {};
	bless $self, $pkg;
	$ver = "2.09";
	$_DEFAULT_SMTP_PORT = 25;
	$_MAILER  = "Bck Sendmail($ver)";
	#
	# The mail server.
	#
	$self->{'smtpserver'}  = ($smtpserver && $smtpserver !~ /^\s*$/) ? $smtpserver : "localhost";
	#
	# The port number for smtp.
	#
	$self->{'smtpport'}	= ($smtpport && $smtpport =~ /^\d+$/) ? $smtpport :
		$_DEFAULT_SMTP_PORT;
	#
	# The default debug mode is "OFF".
	#
	$self->{'debugmode'}   = $self->OFF;
	#
	# Set the default mailer.
	#
	$self->setMailHeader("X-MAILER", $_MAILER);
	#
	# Create empty attachment array.
	#
	$self->{'attachmentArr'} = [];
	#
	# SMTP AUTH
	#
	$self->{'authtype'} = "";
	$self->{'authuserid'} = "";
	$self->{'authpassword'} = "";
	$self->{'log'} = "";
	#
	# Some of the SMTP server needs to say "HELO domain.address".
	#
	eval {
		require Sys::Hostname;
		$_LOCALHOST = Sys::Hostname::hostname();
	};
	$_LOCALHOST = $_MAILER if $@;
	return $self;
}

#===============================================================================
#
# METHOD:	$obj->Attach($filename, [\$data]);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of
#		reading from the file.
#
#===============================================================================
sub Attach ($;$) {
	my($self) = shift;
	my($filename) = shift;
	my($dataRef) = shift;
	my(%hash, $dump);
	return $self->setError("No attachment has been specified.")
	if $filename =~ /^\s*$/;
	if ($filename =~ /(\\|\/)/) {
	  ($hash{'filename'}) = $filename =~ /^.*[\\\/]([^\\\/]+)$/;
	}
	else {
	  $hash{'filename'} = $filename;
	}
	$hash{'filepath'} = $filename;
	$hash{'dataref'} = $dataRef if ref($dataRef) !~ /^\s*$/;
	$hash{'attachtype'} = "attachment";
	return $self->attach(\%hash);
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->Bcc($bccemailadd1, [$bccemailadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the blind carbon copy
#		list.
#
#===============================================================================
sub Bcc ($) {
	my($self)	  = shift;
	my(@bcc)	   = @_;
	my($currEmail) = undef;
	for $currEmail (@bcc) {
	  push(@{$self->{'mailheaders'}->{'BCC'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->Cc($ccemailadd1, [$ccemailadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the carbon copy list.
#
#===============================================================================
sub Cc ($) {
	my($self)	  = shift;
	my(@cc)		= @_;
	my($currEmail) = undef;
	for $currEmail (@cc) {
	  push(@{$self->{'mailheaders'}->{'CC'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->ErrorsTo($errorstoadd1, [$errorstoadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address into the "Errors-To" list.
#
#===============================================================================
sub ErrorsTo ($) {
	my($self)	  = shift;
	my(@errorsto)  = @_;
	my($currEmail) = undef;
	for $currEmail (@errorsto) {
	  push(@{$self->{'mailheaders'}->{'ERRORS-TO'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->From($sender);
#
# DESCRIPTION:	Set the sender of the email.
#
#===============================================================================
sub From ($) {
	my($self) = shift;
	my($from) = shift;
	$self->{'mailheaders'}->{'FROM'} = $from;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->Inline($filename, [\$data]);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of
#		reading from the file.
#
#===============================================================================
sub Inline ($;$) {
	my($self) = shift;
	my($filename) = shift;
	my($dataRef) = shift;
	my(%hash, $dump);
	return $self->setError("No attachment has been specified.")
	if $filename =~ /^\s*$/;
	if ($filename =~ /(\\|\/)/) {
	  ($hash{'filename'}) = $filename =~ /^.*[\\\/]([^\\\/]+)$/;
	}
	else {
	  $hash{'filename'} = $filename;
	}
	$hash{'filepath'} = $filename;
	$hash{'dataref'} = $dataRef if ref($dataRef) !~ /^\s*$/;
	$hash{'attachtype'} = "inline";
	return $self->attach(\%hash); print $hash{'dataref'};
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->OFF;
#
# DESCRIPTION:	Will return 0. Basically, it is used to set the debug mode OFF.
#		Eg. $obj->setDebug($obj->OFF);
#
#===============================================================================
sub OFF () {
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->ON;
#
# DESCRIPTION:	Will return 1. Basically, it is used to set the debug mode ON.
#		Eg. $obj->setDebug($obj->ON);
#
#===============================================================================
sub ON () {
	return 1;
}
#===============================================================================
#
# METHOD:	$obj->AUTHLOGIN;
#
# DESCRIPTION:	Will return string 'AUTH LOGIN'.
#		Eg. $obj->setAuth($obj->AUTHLOGIN, $userid, $password);
#
#===============================================================================
sub AUTHLOGIN () {
  return 'AUTH LOGIN';
}
#===============================================================================
#
# METHOD:	$obj->AUTHPLAIN;
#
# DESCRIPTION:	Will return string 'AUTH PLAIN'.
#		Eg. $obj->setAuth($obj->AUTHPLAIN, $userid, $password);
#
#===============================================================================
sub AUTHPLAIN () {
  return 'AUTH PLAIN';
}
#===============================================================================
#
# METHOD:	$obj->ReplyTo($replytoadd1, [$replytoadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address into the "Reply-To" list.
#
#===============================================================================
sub ReplyTo ($;@) {
	my($self)	  = shift;
	my(@replyto)   = @_;
	push(@{$self->{'mailheaders'}->{'REPLY-TO'}}, @replyto);
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->Subject($subject);
#
# DESCRIPTION:	Set the subject of the email.
#
#===============================================================================
sub Subject ($) {
	$_[0]->{'mailheaders'}->{'SUBJECT'} = $_[1];
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->To($recipient1, [$recipient2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the recipient list.
#
#===============================================================================
sub To ($;@) {
	my($self)	  = shift;
	my(@to)		= @_;
	for (@to) {
	  my($currEmail) = $_;
	  push(@{$self->{'mailheaders'}->{'TO'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->attach(\%hash);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of
#		reading from the file.
#
#===============================================================================
sub attach ($) {
	my($self) = shift;
	my($dataRef) = shift;
	return $self->setError("No attachment has been specified.")
	if $dataRef->{'filename'} =~ /^\s*$/;
	push(@{$self->{'attachmentArr'}}, $dataRef);
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->clearAttach();
#
# DESCRIPTION:	This method will clear the attachment stack.
#
#===============================================================================
sub clearAttach () {
	my($self) = shift;
	$self->{'attachmentArr'} = [];
}
#===============================================================================
#
# METHOD:	$obj->clearBcc();
#
# DESCRIPTION:	This method will clear the email addresses specified for Bcc:.
#
#===============================================================================
sub clearBcc () {
	my($self) = shift;
	$self->{'mailheaders'}->{'BCC'} = [];
}
#===============================================================================
#
# METHOD:	$obj->clearCc();
#
# DESCRIPTION:	This method will clear the email addresses specified for Cc:.
#
#===============================================================================
sub clearCc () {
	my($self) = shift;
	$self->{'mailheaders'}->{'CC'} = [];
}
#===============================================================================
#
# METHOD:	$obj->clearTo();
#
# DESCRIPTION:	This method will clear the email addresses specified for To:.
#
#===============================================================================
sub clearTo () {
	my($self) = shift;
	$self->{'mailheaders'}->{'TO'} = [];
}
#===============================================================================
#
# METHOD:	$obj->createMailData();
#
# DESCRIPTION:	This method will create the mail data which will be sent to the
#		SMTP server. It will contain some mail headers and mail body.
#
#===============================================================================
sub createMailData () {
	my($self) = shift;
	my($currHeader) = undef;
	return -1 if $self->isMailReady() != 0;
	$self->{'maildata'} = undef;
	$self->{'maildata'} = "To: ";
	$self->{'maildata'} .= join(",\r\n\t", @{$self->{'mailheaders'}->{'TO'}});
	$self->{'maildata'} .= "\r\nFrom: ".$self->{'mailheaders'}->{'FROM'}."\r\n";
	if (defined $self->{'mailheaders'}->{'CC'} &&
		@{$self->{'mailheaders'}->{'CC'}} > 0) {
	  $self->{'maildata'} .= "Cc: ";
	  $self->{'maildata'} .= join(",\r\n\t", @{$self->{'mailheaders'}->{'CC'}});
	  $self->{'maildata'} .= "\r\n";
	}
	if (defined $self->{'mailheaders'}->{'REPLY-TO'} &&
		@{$self->{'mailheaders'}->{'REPLY-TO'}} > 0) {
	  $self->{'maildata'} .= "Reply-To: ";
	  $self->{'maildata'} .= join(",\r\n\t",
		@{$self->{'mailheaders'}->{'REPLY-TO'}})."\r\n";
	}
	if (defined $self->{'mailheaders'}->{'ERRORS-TO'} &&
		@{$self->{'mailheaders'}->{'ERRORS-TO'}} > 0) {
	  $self->{'maildata'} .= "Errors-To: ";
	  $self->{'maildata'} .= join(",\r\n\t",
		@{$self->{'mailheaders'}->{'ERRORS-TO'}})."\r\n";
	}
	for $currHeader (sort keys %{$self->{'mailheaders'}->{'OTHERS'}}) {
	  my($currMailHeader) = undef;
	  ($currMailHeader = $currHeader) =~ s/\b(\w)(\w+)\b/$1\L$2/g;
	  $self->{'maildata'} .= "$currMailHeader: ";
	  $self->{'maildata'} .= $self->{'mailheaders'}->{'OTHERS'}->{$currHeader};
	  $self->{'maildata'} .= "\r\n";
	};
	$self->{'maildata'} .= "Subject: ".$self->{'mailheaders'}->{'SUBJECT'};
	if (scalar(@{$self->{'attachmentArr'}}) > 0) {
	  my($currHash);
	  srand(time ^ $$);
	  my($boundary) = "==__BCK__".
		join("", ('a'..'z','A'..'Z', 0..9)[map rand $_, (62)x25]).
		"__==";
	  $self->{'maildata'} .= "\r\nMIME-Version: 1.0\r\n";
	  $self->{'maildata'} .= "Content-Type: multipart/mixed; ";
	  $self->{'maildata'} .= "boundary=\"$boundary\"\r\n";
	  $self->{'maildata'} .= "\r\n";
	  if (defined $self->{'mailbody'}) {
		$self->{'maildata'} .= "\-\-$boundary\r\n";
		#$self->{'maildata'} .= "Content-Type: text/plain; charset=\"iso-8859-1\"\r\n";
		#$self->{'maildata'} .= "Content-Transfer-Encoding: base64\r\n\r\n";
		$self->{'maildata'} .= $self->{'mailbody'} . "\r\n\r\n";
	  }
	  for $currHash (@{$self->{'attachmentArr'}}) {
		$currHash->{'content-type'} =
		$self->getMIMEType($currHash->{'filename'});
		$self->{'maildata'} .= "\-\-$boundary\r\n";
		$self->{'maildata'} .= "Content-Type: $currHash->{'content-type'}; name=\"$currHash->{'filename'}\"\r\n";
		$self->{'maildata'} .= "Content-Transfer-Encoding: base64\r\n";
		$self->{'maildata'} .= "Content-Disposition: $currHash->{'attachtype'}; filename=\"$currHash->{'filename'}\"\r\n";
		$self->{'maildata'} .= "\r\n";
	if (defined $currHash->{'dataref'}) {
	  if (ref($currHash->{'dataref'}) eq "SCALAR") {
		$self->{'maildata'} .= encode_base64(${$currHash->{'dataref'}}, "\r\n");
	  }
	  else {
		my($data) = undef;
		my($buff) = "";
		my($pos) = 0;
		(defined ($pos = tell($currHash->{'dataref'}))) ||
			return $self->setError("Error in tell(): $!");
		while (read($currHash->{'dataref'}, $buff, 1024)) {
		  $data .= $buff;
			}
		$self->{'maildata'} .= encode_base64($data, "\r\n");
		seek($currHash->{'dataref'}, $pos, 0) ||
			return $self->setError("Error in seek(): $!");
	  }
	}
	elsif (-f $currHash->{'filepath'}) {
		  my($data) = undef;
	  my($buff) = "";
		  open(FILE, $currHash->{'filepath'});
	  # In Windows platform, non-text file should use binmode() function.
	  if (! -T $currHash->{'filepath'}) {
		binmode(FILE);
	  }
	  while (sysread(FILE, $buff, 1024)) {
		$data .= $buff;
		  }
		  close(FILE);
		  $self->{'maildata'} .= encode_base64($data, "\r\n");
	}
	else {
	  $self->{'maildata'} .= encode_base64("", "\r\n");
	}
		$self->{'maildata'} .= "\r\n";
	  }
	  $self->{'maildata'} .= "\-\-${boundary}\-\-\r\n";
	}
	else {
	  my($tmpbody) = $self->{'mailbody'};
	  #$tmpbody =~ s/([^\r])\n/$1\r\n/g;
	  $self->{'maildata'} .= "\r\n";
	  $self->{'maildata'} .= "$tmpbody\r\n";
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->getEmailAddress($emailaddstr);
#
# DESCRIPTION:	Get the email address from the email address string which might
#		contain email account owner's name, what we want is the email
#		address only.
#
#===============================================================================
sub getEmailAddress ($) {
	my($self)  = shift;
	my($value) = shift;
	my($retvalue) = undef;
	if ($value =~ /^\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/) {
	  ($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
	  return $retvalue;
	}
	if ($value =~ /^[^\<]+\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/) {
	  ($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
	  return $retvalue;
	}
	return "" if $value =~ /\s+/;
	$value =~ tr/[A-Z]/[a-z]/;
	return $value if $value =~ /^[^\@]+\@[\w\-]+(\.[\w\-]+)+$/;
	return "";
}
#===============================================================================
#
# METHOD:	$obj->getMIMEType($filename);
#
# DESCRIPTION:	This will return MIME type for $filename.
#
#===============================================================================
sub getMIMEType ($) {
	my($self) = shift;
	my($filename) = shift;
	my($ext, %MIMEHash);
	%MIMEHash = (
	'au'	=> 'audio/basic',
	'avi'	=> 'video/x-msvideo',
	'class'	=> 'application/octet-stream',
	'cpt'	=> 'application/mac-compactpro',
	'dcr'	=> 'application/x-director',
	'dir'	=> 'application/x-director',
	'doc'	=> 'application/msword',
	'exe'	=> 'application/octet-stream',
	'gif'	=> 'image/gif',
	'gtx'	=> 'application/x-gentrix',
	'jpeg'	=> 'image/jpeg',
	'jpg'	=> 'image/jpeg',
	'js'	=> 'application/x-javascript',
	'log'	=> 'text/plain',
	'lst'	=> 'text/plain',
	'hqx'	=> 'application/mac-binhex40',
	'htm'	=> 'text/html',
	'html'	=> 'text/html',
	'mid'	=> 'audio/midi',
	'midi'	=> 'audio/midi',
	'mov'	=> 'video/quicktime',
	'mp2'	=> 'audio/mpeg',
	'mp3'	=> 'audio/mpeg',
	'mpeg'	=> 'video/mpeg',
	'mpg'	=> 'video/mpeg',
	'pdf'	=> 'application/pdf',
	'pm'	=> 'text/plain',
	'pl'	=> 'text/plain',
	'ppt'	=> 'application/powerpoint',
	'ps'	=> 'application/postscript',
	'qt'	=> 'video/quicktime',
	'ram'	=> 'audio/x-pn-realaudio',
	'rtf'	=> 'application/rtf',
	'tar'	=> 'application/x-tar',
	'tif'	=> 'image/tiff',
	'tiff'	=> 'image/tiff',
	'txt'	=> 'text/plain',
	'wav'	=> 'audio/x-wav',
	'xbm'	=> 'image/x-xbitmap',
	'zip'	=> 'application/zip',
	);
	($ext) = $filename =~ /\.([^\.]+)$/;
	$ext =~ tr/[A-Z]/[a-z]/;
	return defined $MIMEHash{$ext} ? $MIMEHash{$ext} : "application/octet-stream";
}
#===============================================================================
#
# METHOD:	$obj->getRcptLists();
#
# DESCRIPTION:	This will generate an array of the recipients' email address.
#		Basically, this method only called by $obj->sendMail() method,
#		which needs to send "RCPT TO:" request to the SMTP server.
#
#===============================================================================
sub getRcptLists () {
	my($self) = shift;
	my(@rcptLists) = ();
	my($currEmail) = undef;
	for $currEmail (@{$self->{'mailheaders'}->{'TO'}}) {
	  my($currEmail) = $self->getEmailAddress($currEmail);
	  push(@rcptLists, $currEmail) if
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
	}
	if (defined $self->{'mailheaders'}->{'BCC'} &&
		@{$self->{'mailheaders'}->{'BCC'}} > 0) {
	  for $currEmail (@{$self->{'mailheaders'}->{'BCC'}}) {
		my($currEmail) = $self->getEmailAddress($currEmail);
		push(@rcptLists, $currEmail) if
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
	  }
	}
	if (defined $self->{'mailheaders'}->{'CC'} &&
		@{$self->{'mailheaders'}->{'CC'}} > 0) {
	  for $currEmail (@{$self->{'mailheaders'}->{'CC'}}) {
		my($currEmail) = $self->getEmailAddress($currEmail);
		push(@rcptLists, $currEmail) if
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
	  }
	}
	return \@rcptLists;
}
#===============================================================================
#
# METHOD:	$obj->isMailReady();
#
# DESCRIPTION:	Check if the basic mail headers and the mail body have been set
#		or not.
#		p/s: The "From:", "To:" and "Subject:" mail headers are required
#		here, I feel that a mail should contain these headers. It is
#		just a personal opinion, if you do not think so, just comment
#		them out.
#
#===============================================================================
sub isMailReady () {
	my($self) = shift;
	return $self->setError("No sender has been specified.") if
	! defined $self->{'mailheaders'}->{'FROM'};
	return $self->setError("No recipient has been specified.") if
	((! defined $self->{'mailheaders'}->{'TO'}) ||
		(defined @{$self->{'mailheaders'}->{'TO'}} &&
		 @{$self->{'mailheaders'}->{'TO'}} < 1));
	return $self->setError("No subject has been specified.") if
	! defined $self->{'mailheaders'}->{'SUBJECT'};
	return $self->setError("No mail body has been set.") if
	((! defined $self->{'mailbody'}) &&
		(scalar(@{$self->{'attachmentArr'}}) < 1));
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->receiveFromServer(\*SOCKET);
#
# DESCRIPTION:	This will receive the data replied from the server.
#
#===============================================================================
sub receiveFromServer ($) {
	my($self) = shift;
	my($socket) = shift;
	my($reply);
	#
	# We keep receiveing the data from the server until
	# it waits for next command.
	#
	while ($socket && ($reply = <$socket>)) {
	  return $self->setError($reply) if $reply =~ /^5/;
	  print $reply if $self->{'debugmode'};
	  $self->{'log'} .= $reply;
	  last if $reply =~ /^\d+ /;
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->reset();
#
# DESCRIPTION:	This will clear the data that have been set before.
#
#===============================================================================
sub reset () {
	my($self) = shift;
	$self->{'debugmode'} = $self->OFF;
	$self->{'mailbody'} = undef;
	$self->{'maildata'} = undef;
	$self->{'mailheaders'} = undef;
	$self->{'sender'} = undef;
	$self->{'attachmentArr'} = [];
	$self->{'authtype'} = "";
	$self->{'authuserid'} = "";
	$self->{'authpassword'} = "";
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->sendMail();
#
# DESCRIPTION:	This will use the Socket to connect to the SMTP port to send the
#		mail.
#
#===============================================================================
sub sendMail () {
	my($self) = shift;
	my($iaddr, $paddr, $proto, $rcptlistRef, $currEmail) = undef;
	#
	# Get the sender's email address, this will be used in "MAIL FROM:" request.
	#
	$self->{'sender'} = $self->getEmailAddress($self->{'mailheaders'}->{'FROM'});
	#
	# Invalid email address format.
	#
	return $self->setError("Please check the sender's email address setting.")
	if $self->{'sender'} =~ /^\s*$/;
	#
	# We create the mail data here.
	#
	return -1 if $self->createMailData() != 0;
	#
	# We get the recipients' email addresses.
	#
	$rcptlistRef = $self->getRcptLists();
	#
	# If no recipient has been specified, this is an error.
	#
	return $self->setError("No recipient has been specified.") if
		@{$rcptlistRef} == 0;
	#
	# Please refer to Socket module manual. (perldoc Socket)
	#
	$iaddr = inet_aton($self->{'smtpserver'}) ||
		return $self->setError("no host: $self->{'smtpserver'}, please specify SMTP server with \"\$obj = new SendMail('your.smtp.server');\"");
	$paddr = sockaddr_in($self->{'smtpport'}, $iaddr);
	$proto = getprotobyname('tcp');
	socket(SOCK, PF_INET, SOCK_STREAM, $proto) ||
		return $self->setError("Socket error: $!");
	connect(SOCK, $paddr) ||
	return $self->setError("Error in connecting to $self->{'smtpserver'} at port $self->{'smtpport'}: $!");
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	return -1 if $self->sendToServer(\*SOCK, "EHLO $_LOCALHOST") != 0;
	if ($self->receiveFromServer(\*SOCK) != 0) {
	  return -1 if $self->sendToServer(\*SOCK, "HELO $_LOCALHOST") != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	}
	#
	# SMTP AUTH LOGIN type.
	#
	if ($self->{'authtype'} eq $self->AUTHLOGIN) {
	  return -1 if $self->sendToServer(\*SOCK, $self->{'authtype'});
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	  return -1 if $self->sendToServer(\*SOCK,
		encode_base64($self->{'authuserid'}, "")) != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	  return -1 if $self->sendToServer(\*SOCK,
		encode_base64($self->{'authpassword'}, "")) != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	}
	#
	# SMTP AUTH PLAIN type.
	#
	if ($self->{'authtype'} eq $self->AUTHPLAIN) {
	  return -1 if $self->sendToServer(\*SOCK,
		$self->{'authtype'}." ".
		encode_base64(
			join("\0", "", $self->{'authuserid'},
			$self->{'authpassword'}), "")) != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	}
	return -1 if $self->sendToServer(\*SOCK, "MAIL FROM: <$self->{'sender'}>") != 0;
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	for $currEmail (@{$rcptlistRef}) {
	  return -1 if $self->sendToServer(\*SOCK, "RCPT TO: <$currEmail>") != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	}
	return -1 if $self->sendToServer(\*SOCK, "DATA") != 0;
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	return -1 if $self->sendToServer(\*SOCK, "$self->{'maildata'}\r\n.") != 0;
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	return -1 if $self->sendToServer(\*SOCK, "QUIT") != 0;
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	eof(SOCK) || close(SOCK) ||
	return $self->setError("Fail close connectiong socket: $!");
	print "The mail has been sent to ".scalar(@{$rcptlistRef}) if
		$self->{'debugmode'};
	$self->{'log'} .= "The mail has been sent to ".scalar(@{$rcptlistRef});
	print " person/s successfully.\n" if $self->{'debugmode'};
	$self->{'log'} .= " person/s successfully.";
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setAuth($authtype, $userid, $password);
#
# DESCRIPTION:	This will set the authentication information.
#		$obj->setAuth($obj->AUTHLOGIN, $userid, $password);
#		$obj->setAuth($obj->AUTHPLAIN, $userid, $password);
#
#===============================================================================
sub setAuth ($$$) {
	my($self) = shift;
	$self->{'authtype'} = shift;
	$self->{'authuserid'} = shift;
	$self->{'authpassword'} = shift;
}
#===============================================================================
#
# METHOD:	$obj->sendToServer(\*SOCKET, $message);
#
# DESCRIPTION:	This will send the message to the SMTP server.
#
#===============================================================================
sub sendToServer ($$) {
	my($self) = shift;
	my($socket) = shift;
	my($message) = shift;
	print "$message\r\n" if $self->{'debugmode'};
	#$self->{'log'} .= "$message\r\n";
	# Fix BareLf problem.
	$message =~ s/\n/\r\n/g;
	$message =~ s/\r\r\n/\r\n/g;
	#
	# Sending data to the server.
	#
	send($socket, "$message\r\n", 0) ||
		return $self->setError("Fail to send $message: $!");
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setDebug($obj->ON);
#		$obj->setDebug($obj->OFF);
#
# DESCRIPTION:	Set the debug mode as ON/OFF.
#		Also see: $obj->ON and $obj->OFF methods.
#
#===============================================================================
sub setDebug ($) {
	my($self) = shift;
	$self->{'debugmode'} = shift;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setError($errormessage);
#
# DESCRIPTION:	This will set the error message to "error" attribute in the
#		object and return -1 value.
#
#===============================================================================
sub setError ($) {
	my($self)	 = shift;
	my($errorMsg) = shift;
	$self->{'error'} = $errorMsg if $errorMsg !~ /^\s*$/;
	return -1;
}
#===============================================================================
#
# METHOD:	$obj->setMailBody($htmlbody, $plainbody);
#
# DESCRIPTION:	Set the mail body content.
#
#===============================================================================
sub setMailBody ($) {
	my($self)	  = shift;
	my($mailbody) = shift;
	$self->{'mailbody'} = $mailbody;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setMailHeader($mailheader, $mailheadervalue);
#
# DESCRIPTION:	This method is used for setting custom email headers.
#
#===============================================================================
sub setMailHeader ($$) {
	my($self)	  	 = shift;
	my($mailheader)	 = shift;
	my($mailheadervalue) = shift;
	$mailheader =~ tr/[a-z]/[A-Z]/;
	$self->{'mailheaders'}->{'OTHERS'}->{$mailheader} = $mailheadervalue;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setSMTPPort($smtpport);
#
# DESCRIPTION:	Set the SMTP port.
#
#===============================================================================
sub setSMTPPort ($) {
	my($self)	 = shift;
	my($smtpport) = shift;
	$self->{'smtpport'} = $smtpport if $smtpport =~ /^\d+$/;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setSMTPServer($smtpserver);
#
# DESCRIPTION:	Set the SMTP server.
#
#===============================================================================
sub setSMTPServer ($) {
	my($self)	   = shift;
	my($smtpserver) = shift;
	$smtpserver =~ s/\s*//g;
	$self->{'smtpserver'} = $smtpserver if $smtpserver !~ /^\s*$/;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->version;
#
# DESCRIPTION:	Get the version of the module.
#
#===============================================================================
sub version () {
	my($self) = shift;
	return $ver;
}
#===============================================================================
#
# END of the module.
#
#===============================================================================
package Config::IniFiles;

use vars qw($VERSION);

$VERSION = "2.52";

require 5.004;
use strict;
use Carp;
use Symbol 'gensym','qualify_to_ref';   # For the 'any data type' hack

@Config::IniFiles::errors = ( );

sub new {
  my $class = shift;
  my %parms = @_;

  my $errs = 0;
  my @groups = ( );

  my $self = bless {
	default => '',
	imported =>undef,
	v =>{},
	cf => undef,
	firstload => 1,
  }, $class;

  if( ref($parms{-import}) && ($parms{-import}->isa('Config::IniFiles')) ) {
    $self->{imported}=$parms{-import}; # ReadConfig will load the data
    $self->{negativedeltas}=1;
  } elsif( defined $parms{-import} ) {
    carp "Invalid -import value \"$parms{-import}\" was ignored.";
  } # end if
  delete $parms{-import};

  # Copy the original parameters so we 
  # can use them when we build new sections 
  %{$self->{startup_settings}} = %parms;

  # Parse options
  my($k, $v);
  local $_;
  $self->{nocase} = 0;

  # Handle known parameters first in this order, 
  # because each() could return parameters in any order
  if (defined ($v = delete $parms{'-file'})) {
    # Should we be pedantic and check that the file exists?
    # .. no, because now it could be a handle, IO:: object or something else
    $self->{cf} = $v;
  }
  if (defined ($v = delete $parms{'-nocase'})) {
    $self->{nocase} = $v ? 1 : 0;
  }  
  if (defined ($v = delete $parms{'-default'})) {
    $self->{default} = $self->{nocase} ? lc($v) : $v;
  }
  if (defined ($v = delete $parms{'-reloadwarn'})) {
    $self->{reloadwarn} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-allowcontinue'})) {
    $self->{allowcontinue} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-allowempty'})) {
	  $self->{allowempty} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-negativedeltas'})) {
	  $self->{negativedeltas} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-commentchar'})) {
    if(!defined $v || length($v) != 1) {
      carp "Comment character must be unique.";
      $errs++;
    }
    elsif($v =~ /[\[\]=\w]/) {
      # must not be square bracket, equal sign or alphanumeric
      carp "Illegal comment character.";
      $errs++;
    } 
    else {
      $self->{comment_char} = $v;
    }
  }
  if (defined ($v = delete $parms{'-allowedcommentchars'})) {
    # must not be square bracket, equal sign or alphanumeric
    if(!defined $v || $v =~ /[\[\]=\w]/) {
      carp "Illegal value for -allowedcommentchars.";
      $errs++;
    }
    else {
      $self->{allowed_comment_char} = $v;
    }
  }
  $self->{comment_char} = '#' unless exists $self->{comment_char};
  $self->{allowed_comment_char} = ';' unless exists $self->{allowed_comment_char};
  # make sure that comment character is always allowed
  $self->{allowed_comment_char} .= $self->{comment_char};

  $self->{_comments_at_end_of_file} = [];

  # Any other parameters are unkown
  while (($k, $v) = each %parms) {
    carp "Unknown named parameter $k=>$v";
    $errs++;
  }

  return undef if $errs;
  
  if ($self->ReadConfig) {
    return $self;
  } else {
    return undef;
  }
}

sub val {
  my ($self, $sect, $parm, $def) = @_;

  # Always return undef on bad parameters
  return if not defined $sect;
  return if not defined $parm;
  
  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }
  
  my $val = defined($self->{v}{$sect}{$parm}) ?
    $self->{v}{$sect}{$parm} :
    $self->{v}{$self->{default}}{$parm};
  
  # If the value is undef, make it $def instead (which could just be undef)
  $val = $def unless defined $val;
  
  # Return the value in the desired context
  if (wantarray) {
    if (ref($val) eq "ARRAY") {
      return @$val;
    } elsif (defined($val)) {
      return $val;
    } else {
      return;
    }
  } elsif (ref($val) eq "ARRAY") {
  	if (defined ($/)) {
	    return join "$/", @$val;
	} else {
		return join "\n", @$val;
	}
  } else {
    return $val;
  }
}

sub exists {
	my ($self, $sect, $parm)=@_;

    if ($self->{nocase}) {
        $sect = lc($sect);
        $parm = lc($parm);
    }
    
	return (exists $self->{v}{$sect}{$parm});
}

sub push {
  my ($self, $sect, $parm, @vals)=@_;

  return undef if not defined $sect;
  return undef if not defined $parm;

  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }

  return undef if (! defined($self->{v}{$sect}{$parm}));

  return 1 if (! @vals);

  $self->_touch_parameter($sect, $parm);

  $self->{EOT}{$sect}{$parm} = 'EOT' if
	(!defined $self->{EOT}{$sect}{$parm});

  $self->{v}{$sect}{$parm} = [$self->{v}{$sect}{$parm}] unless
     (ref($self->{v}{$sect}{$parm}) eq "ARRAY");

  CORE::push @{$self->{v}{$sect}{$parm}}, @vals;
  return 1;
}

sub setval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  my @val  = @_;

  return undef if not defined $sect;
  return undef if not defined $parm;

  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }

  if (defined($self->{v}{$sect}{$parm})) {
	$self->_touch_parameter($sect, $parm);
    if (@val > 1) {
      $self->{v}{$sect}{$parm} = \@val;
	  $self->{EOT}{$sect}{$parm} = 'EOT';
    } else {
      $self->{v}{$sect}{$parm} = shift @val;
    }
    return 1;
  } else {
    return undef;
  }
}

sub newval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  my @val  = @_;
  
  return undef if not defined $sect;
  return undef if not defined $parm;

  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }

  $self->AddSection($sect);

  CORE::push(@{$self->{parms}{$sect}}, $parm) 
      unless (grep {/^\Q$parm\E$/} @{$self->{parms}{$sect}} );

  $self->_touch_parameter($sect, $parm);
  if (@val > 1) {
    $self->{v}{$sect}{$parm} = \@val;
    $self->{EOT}{$sect}{$parm} = 'EOT' unless defined $self->{EOT}{$sect}{$parm};
  } else {
    $self->{v}{$sect}{$parm} = shift @val;
  }
  return 1
}

sub delval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  
  return undef if not defined $sect;
  return undef if not defined $parm;

  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }

  @{$self->{parms}{$sect}} = grep !/^\Q$parm\E$/, @{$self->{parms}{$sect}};
  $self->_touch_parameter($sect, $parm);
  delete $self->{v}{$sect}{$parm};
  return 1
}

# Auxillary function to make deep (aliasing-free) copies of data
# structures.  Ignores blessed objects in tree (could be taught not
# to, if needed)
sub _deepcopy {
  my $ref=shift;

  if (! ref($ref)) { return $ref; }

  local $_;

  if (UNIVERSAL::isa($ref, "ARRAY")) {
          return [map {_deepcopy($_)} @$ref];
  }

  if (UNIVERSAL::isa($ref, "HASH")) {
          my $return={};
          foreach my $k (keys %$ref) {
                  $return->{$k}=_deepcopy($ref->{$k});
          }
          return $return;
  }

  carp "Unhandled data structure in $ref, cannot _deepcopy()";
}

# Internal method, gets the next line, taking proper care of line endings.
sub _nextline {
	my ($self, $fh)=@_;
	local $_;
	if (!exists $self->{line_ends}) {
		# no $self->{line_ends} is a hint set by caller that we are at
		# the first line (kludge kludge).
		do {
			local $/=\1; my $nextchar=<$fh>;
			return undef if (!defined $nextchar);
			$_ .= $nextchar;
		} until (m/(\015\012?|\012|\025|\n)$/s);
		$self->{line_ends}=$1;

		# If there's a UTF BOM (Byte-Order-Mark) in the first
		# character of the first line then remove it before processing
		# (http://www.unicode.org/unicode/faq/utf_bom.html#22)
		s/^//;

		return $_;
	} else {
		local $/=$self->{line_ends};
		return scalar <$fh>;
	}
}

# Internal method, closes or resets the file handle. To be called
# whenever ReadConfig() returns.
sub _rollback {
	my ($self, $fh)=@_;
  # Only close if this is a filename, if it's
  # an open handle, then just roll back to the start
  if( !ref($self->{cf}) ) {
    close($fh);
  } else {
    # Attempt to rollback to beginning, no problem if this fails (e.g. STDIN)
    seek( $fh, 0, 0 );
  } # end if
}


sub ReadConfig {
  my $self = shift;

  my($lineno, $sect);
  my($group, $groupmem);
  my($parm, $val);
  my @cmts;

  @Config::IniFiles::errors = ( );

  # Initialize (and clear out) storage hashes
  $self->{sects}  = [];
  $self->{parms}  = {};
  $self->{group}  = {};
  $self->{v}      = {};
  $self->{sCMT}   = {};
  $self->{pCMT}   = {};
  $self->{EOT}    = {};
  $self->{mysects} = []; # A pair of hashes to remember which params are loaded
  $self->{myparms} = {}; # or set using the API vs. imported - useful for
  # import shadowing, see below, and WriteConfig(-delta=>1)

  if( defined $self->{imported} ) {
      # Run up the import tree to the top, then reload coming
      # back down, maintaining the imported file names and our 
      # file name.
      # This is only needed on a re-load though
	  $self->{imported}->ReadConfig() unless ($self->{firstload});

	  foreach my $field (qw(sects parms group v sCMT pCMT EOT)) {
		  $self->{$field} = _deepcopy($self->{imported}->{$field});
	  }
  } # end if
  
  return 1 if (
    (not exists $self->{cf}) or
    (not defined $self->{cf}) or
    ($self->{cf} eq '')
  );
  
  my $nocase = $self->{nocase};

  # If this is a reload and we want warnings then send one to the STDERR log
  unless( $self->{firstload} || !$self->{reloadwarn} ) {
    my ($ss, $mm, $hh, $DD, $MM, $YY) = (localtime(time))[0..5];
    printf STDERR
      "PID %d reloading config file %s at %d.%02d.%02d %02d:%02d:%02d\n",
      $$, $self->{cf}, $YY+1900, $MM+1, $DD, $hh, $mm, $ss;
  }
  
  # Turn off. Future loads are reloads
  $self->{firstload} = 0;

  # Get a filehandle, allowing almost any type of 'file' parameter
  my $fh = $self->_make_filehandle( $self->{cf} );
  if (!$fh) {
    carp "Failed to open $self->{cf}: $!";
    return undef;
  }
  
  # Get mod time of file so we can retain it (if not from STDIN)
  if (ref($fh) ne "IO::Scalar")
  {
    my @stats = stat $fh;
    $self->{file_mode} = sprintf("%04o", $stats[2]) if defined $stats[2];
  }
  
  
  # The first lines of the file must be blank, comments or start with [
  my $first = '';
  my $allCmt = $self->{allowed_comment_char};
  
  local $_;
  delete $self->{line_ends}; # Marks start of parsing for _nextline()
  while ( defined($_ = $self->_nextline($fh)) ) {
    s/(\015\012?|\012|\025|\n)$//;				# remove line ending char(s)
    $lineno++;
    if (/^\s*$/) {				# ignore blank lines
      next;
    }
    elsif (/^\s*[$allCmt]/) {			# collect comments
		if ($self->{negativedeltas} &&
			m/^$self->{comment_char} (.*) is deleted$/) {
			my $todelete=$1;
			if ($todelete =~ m/^\[(.*)\]$/) {
				$self->DeleteSection($1);
			} else {
				$self->delval($sect, $todelete);
			}
		} else {
			CORE::push(@cmts, $_);
		}
		next;
    }
    elsif (/^\s*\[\s*(\S|\S.*\S)\s*\]\s*$/) {		# New Section
      $sect = $1;
      if ($self->{nocase}) {
        $sect = lc($sect);
      }
      $self->AddSection($sect);
      $self->SetSectionComment($sect, @cmts);
      @cmts = ();
    }
    elsif (($parm, $val) = /^\s*([^=]*?[^=\s])\s*=\s*(.*)$/) {	# new parameter
		if (!defined $sect) {
			CORE::push(@Config::IniFiles::errors, sprintf('%d: %s', $lineno,
				qq#parameter found outside a section#));
			$self->_rollback($fh);
			return undef;
		}

      $parm = lc($parm) if $nocase;
      my @val = ( );
      my $eotmark;
      if ($val =~ /^<<(.*)$/) {			# "here" value
	   $eotmark  = $1;
	my $foundeot = 0;
	my $startline = $lineno;
	while ( defined($_=$self->_nextline($fh)) ) {
	  s/(\015\012?|\012|\025|\n)$//;				# remove line ending char(s)
	  $lineno++;
	  if ($_ eq $eotmark) {
	    $foundeot = 1;
	    last;
	  } else {
		# Untaint
		/(.*)/ms; 
        CORE::push(@val, $1);
	  }
	}
	if (! $foundeot) {
	  CORE::push(@Config::IniFiles::errors, sprintf('%d: %s', $startline,
			      qq#no end marker ("$eotmark") found#));
      $self->_rollback();
	  return undef;
    }
      } else { # no here value

        # process continuation lines, if any
        while($self->{allowcontinue} && $val =~ s/\\$//) {
          $_ = $self->_nextline($fh);
	  s/(\015\012?|\012|\025|\n)$//; # remove line ending char(s)
	  $lineno++;
          $val .= $_;
        }
		@val = $val;
      }
		# Now load value
		if (exists $self->{v}{$sect}{$parm} && 
			exists $self->{myparms}{$sect} && 
			grep( /^\Q$parm\E$/, @{$self->{myparms}{$sect}}) ) {
			$self->push($sect, $parm, @val);
		} else {
	        # Loaded parameters shadow imported ones, instead of appending
			# to them
			$self->newval($sect, $parm, @val);
		}
		$self->SetParameterComment($sect, $parm, @cmts);
		@cmts = ( );
		$self->SetParameterEOT($sect,$parm,$eotmark) if (defined $eotmark);

    } else {
      CORE::push(@Config::IniFiles::errors, sprintf("Line \%d in file " . $self->{cf} . " is mal-formed:\n\t\%s", $lineno, $_));
    }
  } # End main parsing loop

  # Special case: return undef if file is empty. (suppress this line to
  # restore the more intuitive behaviour of accepting empty files)
  if (! keys %{$self->{v}} && ! $self->{allowempty}) {
	  CORE::push @Config::IniFiles::errors, "Empty file treated as error";
	  $self->_rollback($fh);
	  return undef;
  }

  if( defined (my $defaultsect=$self->{startup_settings}->{-default}) ) {
	  $self->AddSection($defaultsect);
  } # end if

  $self->_SetEndComments(@cmts);

  $self->_rollback($fh);
  @Config::IniFiles::errors ? undef : 1;
}

sub Sections {
  my $self = shift;
  return @{$self->{sects}} if ref $self->{sects} eq 'ARRAY';
  return ();
}

sub SectionExists {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	return undef() if not defined $sect;
	return 1 if (grep {/^\Q$sect\E$/} @{$self->{sects}});
	return 0;
}

sub AddSection {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	return if $self->SectionExists($sect);
	CORE::push @{$self->{sects}}, $sect unless
	  grep /^\Q$sect\E$/, @{$self->{sects}};
	$self->_touch_section($sect);

	$self->SetGroupMember($sect);
	
	# Set up the parameter names and values lists
    $self->{parms}{$sect} = [] unless ref $self->{parms}{$sect} eq 'ARRAY';
	if (!defined($self->{v}{$sect})) {
		$self->{sCMT}{$sect} = [];
		$self->{pCMT}{$sect} = {};		# Comments above parameters
		$self->{parms}{$sect} = [];
		$self->{v}{$sect} = {};
	}
}

# Marks a section as modified by us (this includes deleted by us).
sub _touch_section {
	my ($self, $sect)=@_;

	$self->{mysects} ||= [];
	CORE::push @{$self->{mysects}}, $sect unless
	  grep /^\Q$sect\E$/, @{$self->{mysects}};
}

# Marks a parameter as modified by us (this includes deleted by us).
sub _touch_parameter {
	my ($self, $sect, $parm)=@_;

	$self->_touch_section($sect);
	return if (!exists $self->{v}{$sect});
	$self->{myparms}{$sect} ||= [];
	CORE::push @{$self->{myparms}{$sect}}, $parm unless
	  grep /^\Q$parm\E$/, @{$self->{myparms}{$sect}};
}

sub DeleteSection {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}

	# This is done the fast way, change if data structure changes!!
	delete $self->{v}{$sect};
	delete $self->{sCMT}{$sect};
	delete $self->{pCMT}{$sect};
	delete $self->{EOT}{$sect};
	delete $self->{parms}{$sect};
	delete $self->{myparms}{$sect};

	@{$self->{sects}} = grep !/^\Q$sect\E$/, @{$self->{sects}};
	$self->_touch_section($sect);

	if( $sect =~ /^(\S+)\s+\S+/ ) {
		my $group = $1;
		if( defined($self->{group}{$group}) ) {
			@{$self->{group}{$group}} = grep !/^\Q$sect\E$/, @{$self->{group}{$group}};
		} # end if
	} # end if

	return 1;
} # end DeleteSection

sub Parameters {
  my $self = shift;
  my $sect = shift;
  
  return undef if not defined $sect;
  
  if ($self->{nocase}) {
    $sect = lc($sect);
  }
  
  return @{$self->{parms}{$sect}} if ref $self->{parms}{$sect} eq 'ARRAY';
  return ();
}

sub Groups	{
  my $self = shift;
  return keys %{$self->{group}} if ref $self->{group} eq 'HASH';
  return ();
}

sub SetGroupMember {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	return(1) unless $sect =~ /^(\S+)\s+\S+/;
	
	my $group = $1;
	if (not exists($self->{group}{$group})) {
		$self->{group}{$group} = [];
	}
	if (not grep {/^\Q$sect\E$/} @{$self->{group}{$group}}) {
		CORE::push @{$self->{group}{$group}}, $sect;
	}
}

sub RemoveGroupMember {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	return(1) unless $sect =~ /^(\S+)\s+\S+/;
	
	my $group = $1;
	return unless exists $self->{group}{$group};
	@{$self->{group}{$group}} = grep {!/^\Q$sect\E$/} @{$self->{group}{$group}};
}

sub GroupMembers {
  my $self  = shift;
  my $group = shift;
  
  return undef if not defined $group;
  
  if ($self->{nocase}) {
  	$group = lc($group);
  }
  
  return @{$self->{group}{$group}} if ref $self->{group}{$group} eq 'ARRAY';
  return ();
}

sub SetWriteMode
{
	my $self = shift;
	my $mode = shift;
	return undef if not defined ($mode);
	return undef if not ($mode =~ m/[0-7]{3,3}/);
	$self->{file_mode} = $mode;
	return $mode;
}

sub GetWriteMode
{
	my $self = shift;
	return undef if not exists $self->{file_mode};
	return $self->{file_mode};
}

sub WriteConfig {
  my ($self, $file, %parms)=@_;
  %parms = () unless %parms;
  
  return undef unless defined $file;
  
  
  # If we are using a filename, then do mode checks and write to a 
  # temporary file to avoid a race condition
  if( !ref($file) ) {
    if (-e $file) {
          if (not (-w $file))
          {
                  #carp "File $file is not writable.  Refusing to write config";
                  return undef;
          }
          my $mode = (stat $file)[2];
          $self->{file_mode} = sprintf "%04o", ($mode & 0777);
          #carp "Using mode $self->{file_mode} for file $file";
    } elsif (defined($self->{file_mode}) and not (oct($self->{file_mode}) & 0222)) {
          #carp "Store mode $self->{file_mode} prohibits writing config";
    }
  
    my $new_file = $file . "-new";
    local(*F);
    open(F, "> $new_file") || do {
      carp "Unable to write temp config file $new_file: $!";
      return undef;
    };
    my $oldfh = select(F);
    $self->OutputConfig($parms{-delta});
    close(F);
    select($oldfh);
    rename( $new_file, $file ) || do {
      carp "Unable to rename temp config file ($new_file) to $file: $!";
      return undef;
    };
    if (exists $self->{file_mode}) {
      chmod oct($self->{file_mode}), $file;
    }
  
  } # Otherwise, reset to the start of the file and write, unless we are using STDIN
  else {
    # Get a filehandle, allowing almost any type of 'file' parameter
    ## NB: If this were a filename, this would fail because _make_file 
    ##     opens a read-only handle, but we have already checked that case
    ##     so re-using the logic is ok [JW/WADG]
    my $fh = $self->_make_filehandle( $file );
    if (!$fh) {
      carp "Could not find a filehandle for the input stream ($file): $!";
      return undef;
    }
    
    
    # Only roll back if it's not STDIN (if it is, Carp)
    if( $fh == \*STDIN ) {
      carp "Cannot write configuration file to STDIN.";
    } else {
      seek( $fh, 0, 0 );
      my $oldfh = select($fh);
      $self->OutputConfig($parms{-delta});
      seek( $fh, 0, 0 );
      select($oldfh);
    } # end if

  } # end if (filehandle/name)
  
  return 1;
  
}

sub RewriteConfig {
  my $self = shift;
  
  return undef if (
    (not exists $self->{cf}) or
    (not defined $self->{cf}) or
    ($self->{cf} eq '')
  );
  
  # Return whatever WriteConfig returns :)
  $self->WriteConfig($self->{cf});
}

sub GetFileName
{
	my $self = shift;
	my $filename;
	if (exists $self->{cf}) {
		$filename = $self->{cf};
	} else {
		undef $filename;
	}
	return $filename;
}

sub SetFileName {
  my $self = shift;
  my $newfile = shift;
  
  return undef if not defined $newfile;
  
  if ($newfile ne "") {
    $self->{cf} = $newfile;
    return $self->{cf};
  }
  return undef;
}

sub OutputConfig {
    my ($self, $delta) = @_;

    my($sect, $parm, @cmts);
    my $ors = $self->{line_ends} || $\ || "\n"; # $\ is normally unset, but use input by default
    my $notfirst = 0;
    local $_;
    SECT:
    foreach $sect (@{$self->{$delta ? "mysects" : "sects"}}) {
        if (!defined $self->{v}{$sect}) {
            if ($delta) {
                print "$self->{comment_char} [$sect] is deleted$ors";
            } else {
                warn "Weird unknown section $sect" if $^W;
            }
            next SECT;
        }
        next unless defined $self->{v}{$sect};
        print $ors if $notfirst;
        $notfirst = 1;
        if ((ref($self->{sCMT}{$sect}) eq 'ARRAY') &&
            (@cmts = @{$self->{sCMT}{$sect}})) {
            foreach (@cmts) {
                print "$_$ors";
            }
        }
        print "[$sect]$ors";
        next unless ref $self->{v}{$sect} eq 'HASH';

        PARM:
        foreach $parm (@{$self->{$delta ? "myparms" : "parms"}{$sect}}) {
            if (!defined $self->{v}{$sect}{$parm}) {
                if ($delta) {
                    print "$self->{comment_char} $parm is deleted$ors";
                } else {
                    warn "Weird unknown parameter $parm" if $^W;
                }
                next PARM;
            }
            if ((ref($self->{pCMT}{$sect}{$parm}) eq 'ARRAY') &&
                (@cmts = @{$self->{pCMT}{$sect}{$parm}})) {
                foreach (@cmts) {
                    print "$_$ors";
                }
            }

            my $val = $self->{v}{$sect}{$parm};
            next if ! defined ($val); # No parameter exists !!
            if (ref($val) eq 'ARRAY') {
                my $eotmark = $self->{EOT}{$sect}{$parm} || 'EOT';
                print "$parm= <<$eotmark$ors";
                foreach (@{$val}) {
                    print "$_$ors";
                }
                print "$eotmark$ors";
            } elsif( $val =~ /[$ors]/ ) {
                # The FETCH of a tied hash is never called in 
                # an array context, so generate a EOT multiline
                # entry if the entry looks to be multiline
                my @val = split /[$ors]/, $val, -1;
                if( @val > 1 ) {
                    my $eotmark = $self->{EOT}{$sect}{$parm} || 'EOT';

                    # Make sure the $eotmark does not occur inside the string.
                    my @letters = ('A' .. 'Z');
                    while (index($val, $eotmark) >= 0)
                    {
                        $eotmark .= $letters[rand(@letters)];
                    }

                    print "$parm= <<$eotmark$ors";
                    print map "$_$ors", @val;
                    print "$eotmark$ors";
                } else {
                    print "$parm=$val[0]$ors";
                } # end if
            } else {
                print "$parm=$val$ors";
            }
        }
    }
    foreach my $comment ($self->_GetEndComments()) {
        print "$comment$ors";
    }
    return 1;
}

sub SetSectionComment
{
	my $self = shift;
	my $sect = shift;
	my @comment = @_;

	return undef if not defined $sect;
	return undef unless @comment;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	$self->_touch_section($sect);
	$self->{sCMT}{$sect} = [];
	# At this point it's possible to have a comment for a section that
	# doesn't exist. This comment will not get written to the INI file.
	
	CORE::push @{$self->{sCMT}{$sect}}, $self->_markup_comments(@comment);
	return scalar @comment;
}

# this helper makes sure that each line is preceded with the correct comment
# character
sub _markup_comments 
{
  my $self = shift;
  my @comment = @_;

  my $allCmt = $self->{allowed_comment_char};
  my $cmtChr = $self->{comment_char};
  foreach (@comment) {
    m/^\s*[$allCmt]/ or ($_ = "$cmtChr $_");
  }
  @comment;
}

sub GetSectionComment
{
	my $self = shift;
	my $sect = shift;

	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	if (exists $self->{sCMT}{$sect}) {
		my @ret = @{$self->{sCMT}{$sect}};
        if (wantarray()) {
            return @ret;
        }
        else {
            if (defined ($/)) {
                return join "$/", @ret;
            } else {
                return join "\n", @ret;
            }
        }
	} else {
		return undef;
	}
}

sub DeleteSectionComment
{
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	$self->_touch_section($sect);

	delete $self->{sCMT}{$sect};
}

sub SetParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	my @comment = @_;

	defined($sect) || return undef;
	defined($parm) || return undef;
	@comment || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	}
	
	$self->_touch_parameter($sect, $parm);
	if (not exists $self->{pCMT}{$sect}) {
		$self->{pCMT}{$sect} = {};
	}
	
	$self->{pCMT}{$sect}{$parm} = [];
	# Note that at this point, it's possible to have a comment for a parameter,
	# without that parameter actually existing in the INI file.
	CORE::push @{$self->{pCMT}{$sect}{$parm}}, $self->_markup_comments(@comment);
	return scalar @comment;
}

sub _SetEndComments
{
    my $self = shift;
    my @comments = @_;

    $self->{_comments_at_end_of_file} = \@comments;

    return 1;
}

sub _GetEndComments {
    my $self = shift;

    return @{$self->{_comments_at_end_of_file}};
}

sub GetParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	
	defined($sect) || return undef;
	defined($parm) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};
	
	exists($self->{pCMT}{$sect}) || return undef;
	exists($self->{pCMT}{$sect}{$parm}) || return undef;
	
	my @comment = @{$self->{pCMT}{$sect}{$parm}};
	return wantarray() ? @comment : join((defined $/ ? $/ : "\n"), @comment);
}

sub DeleteParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	
	defined($sect) || return undef;
	defined($parm) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};
	
	# If the parameter doesn't exist, our goal has already been achieved
	exists($self->{pCMT}{$sect}) || return 1;
	exists($self->{pCMT}{$sect}{$parm}) || return 1;

	$self->_touch_parameter($sect, $parm);
	delete $self->{pCMT}{$sect}{$parm};
	return 1;
}

sub GetParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;

	defined($sect) || return undef;
	defined($parm) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};

	if (not exists $self->{EOT}{$sect}) {
		$self->{EOT}{$sect} = {};
	}

	if (not exists $self->{EOT}{$sect}{$parm}) {
		return undef;
	}
	return $self->{EOT}{$sect}{$parm};
}

sub SetParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	my $EOT = shift;

	defined($sect) || return undef;
	defined($parm) || return undef;
	defined($EOT) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};

	$self->_touch_parameter($sect, $parm);
    if (not exists $self->{EOT}{$sect}) {
        $self->{EOT}{$sect} = {};
    }

    $self->{EOT}{$sect}{$parm} = $EOT;
}

sub DeleteParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	
	defined($sect) || return undef;
	defined($parm) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	}

	$self->_touch_parameter($sect, $parm);
	delete $self->{EOT}{$sect}{$parm};
}

sub Delete {
	my $self = shift;

	foreach my $section ($self->Sections()) {
		$self->DeleteSection($section);
	}

	return 1;
} # end Delete

############################################################
#
# TIEHASH Methods
#
# Description:
# These methods allow you to tie a hash to the 
# Config::IniFiles object. Note that, when tied, the 
# user wants to look at thinks like $ini{sec}{parm}, but the 
# TIEHASH only provides one level of hash interace, so the 
# root object gets asked for a $ini{sec}, which this 
# implements. To further tie the {parm} hash, the internal 
# class Config::IniFiles::_section, is provided, below.
#
############################################################
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub TIEHASH {
  my $class = shift;
  my %parms = @_;

  # Get a new object
  my $self = $class->new( %parms );

  return $self;
} # end TIEHASH


# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub FETCH {
  my $self = shift;
  my( $key ) = @_;

  $key = lc($key) if( $self->{nocase} );
  return if (! $self->{v}{$key});

  my %retval;
  tie %retval, 'Config::IniFiles::_section', $self, $key;
  return \%retval;

} # end FETCH

# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000Jun14 Fixed bug where wrong ref was saved           JW
# 2000Oct09 Fixed possible but in %parms with defaults    JW
# 2001Apr04 Fixed -nocase problem in storing              JW
# ----------------------------------------------------------
sub STORE {
  my $self = shift;
  my( $key, $ref ) = @_;

  return undef unless ref($ref) eq 'HASH';

  $key = lc($key) if( $self->{nocase} );

  $self->AddSection($key);
  $self->{v}{$key} = {%$ref};
  $self->{parms}{$key} = [keys %$ref];
  $self->{myparms}{$key} = [keys %$ref];
  1;
} # end STORE


# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# 2000Dec17 Now removes comments, groups and EOTs too     JW
# 2001Arp04 Fixed -nocase problem                         JW
# ----------------------------------------------------------
sub DELETE {
  my $self = shift;
  my( $key ) = @_;

  my $retval=$self->FETCH($key);
  $self->DeleteSection($key);
  return $retval;
} # end DELETE


# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub CLEAR {
  my $self = shift;

  return $self->Delete();
} # end CLEAR

# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub FIRSTKEY {
  my $self = shift;

  $self->{tied_enumerator}=0;
  return $self->NEXTKEY();
} # end FIRSTKEY


# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub NEXTKEY {
  my $self = shift;
  my( $last ) = @_;

  my $i=$self->{tied_enumerator}++;
  my $key=$self->{sects}[$i]; 
  return if (! defined $key);
  return wantarray ? ($key, $self->FETCH($key)) : $key;
} # end NEXTKEY


# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# 2001Apr04 Fixed -nocase bug and false true bug          JW
# ----------------------------------------------------------
sub EXISTS {
  my $self = shift;
  my( $key ) = @_;
  return $self->SectionExists($key);
} # end EXISTS


# ----------------------------------------------------------
# DESTROY is used by TIEHASH and the Perl garbage collector,
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub DESTROY {
  # my $self = shift;
} # end if


# ----------------------------------------------------------
# Sub: _make_filehandle
#
# Args: $thing
#	$thing	An input source
#
# Description: Takes an input source of a filehandle, 
# filehandle glob, reference to a filehandle glob, IO::File
# object or scalar filename and returns a file handle to 
# read from it with.
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 06Dec2001 Added to support input from any source        JW
# ----------------------------------------------------------
sub _make_filehandle {
  my $self = shift;

  #
  # This code is 'borrowed' from Lincoln D. Stein's GD.pm module
  # with modification for this module. Thanks Lincoln!
  #
  
  no strict 'refs';
  my $thing = shift;

  if (ref($thing) eq "SCALAR") {
	  if (eval { require IO::Scalar; $IO::Scalar::VERSION >= 2.109; }) {
		  return new IO::Scalar($thing);
	  } else {
		  warn "SCALAR reference as file descriptor requires IO::stringy ".
			"v2.109 or later" if ($^W);
		  return;
	  }
  }

  return $thing if defined(fileno $thing);
#  return $thing if defined($thing) && ref($thing) && defined(fileno $thing);
  
  # otherwise try qualifying it into caller's package
  my $fh = qualify_to_ref($thing,caller(1));
  return $fh if defined(fileno $fh);
#  return $fh if defined($thing) && ref($thing) && defined(fileno $fh);
  
  # otherwise treat it as a file to open
  $fh = gensym;
  open($fh,$thing) || return;
  
  return $fh;
} # end _make_filehandle

############################################################
#
# INTERNAL PACKAGE: Config::IniFiles::_section
#
# Description:
# This package is used to provide a single-level TIEHASH
# interface to the sections in the IniFile. When tied, the 
# user wants to look at thinks like $ini{sec}{parm}, but the 
# TIEHASH only provides one level of hash interace, so the 
# root object gets asked for a $ini{sec} and must return a 
# has reference that accurately covers the '{parm}' part.
#
# This package is only used when tied and is inter-woven 
# between the sections and their parameters when the TIEHASH
# method is called by Perl. It's a very simple implementation
# of a tied hash object that simply maps onto the object API.
#
############################################################
# Date        Modification                            Author
# ----------------------------------------------------------
# 2000.May.09 Created to excapsulate TIEHASH interface    JW
############################################################
package Config::IniFiles::_section;

use strict;
use Carp;
use vars qw( $VERSION );

$Config::IniFiles::_section::VERSION = 2.16;

# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::TIEHASH
#
# Args: $class, $config, $section
#	$class	  The class that this is being tied to.
#   $config   The parent Config::IniFiles object
#   $section  The section this tied object refers to
#
# Description: Builds the object that implements accesses to
# the tied hash.
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub TIEHASH {
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my ($config, $section)=@_;

  # Make a new object
  return bless {config=>$config, section=>$section}, $class;
} # end TIEHASH


# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::FETCH
#
# Args: $key
#	$key	The name of the key whose value to get
#
# Description: Returns the value associated with $key. If
# the value is a list, returns a list reference.
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000Jun15 Fixed bugs in -default handler                JW
# 2000Dec07 Fixed another bug in -deault handler          JW
# 2002Jul04 Returning scalar values (Bug:447532)          AS
# ----------------------------------------------------------
sub FETCH {
	my ($self, $key)=@_;
	my @retval=$self->{config}->val($self->{section}, $key);
	return (@retval <= 1) ? $retval[0] : \@retval;
} # end FETCH


# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::STORE
#
# Args: $key, @val
#	$key	The key under which to store the value
#	@val	The value to store, either an array or a scalar
#
# Description: Sets the value for the specified $key
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug                             JW
# ----------------------------------------------------------
sub STORE {
	my ($self, $key, @val)=@_;
	return $self->{config}->newval($self->{section}, $key, @val);
} # end STORE


# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::DELETE
#
# Args: $key
#	$key	The key to remove from the hash
#
# Description: Removes the specified key from the hash and
# returns its former value.
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug                              JW
# ----------------------------------------------------------
sub DELETE {
	my ($self, $key)=@_;
	my $retval=$self->{config}->val($self->{section}, $key);
	$self->{config}->delval($self->{section}, $key);
	return $retval;
} # end DELETE

# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::CLEAR
#
# Args: (None)
#
# Description: Empties the entire hash
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub CLEAR    {
  my ($self) = @_;
  return $self->{config}->DeleteSection($self->{section});
} # end CLEAR

# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::EXISTS
#
# Args: $key
#	$key	The key to look for
#
# Description: Returns whether the key exists
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug                             JW
# ----------------------------------------------------------
sub EXISTS   {
  my ($self, $key)=@_;
  return $self->{config}->exists($self->{section},$key);
} # end EXISTS

# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::FIRSTKEY
#
# Args: (None)
#
# Description: Returns the first key in the hash
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub FIRSTKEY {
  my $self = shift;

  $self->{tied_enumerator}=0;
  return $self->NEXTKEY();
} # end FIRSTKEY

# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::NEXTKEY
#
# Args: $last
#	$last	The last key accessed by the interator
#
# Description: Returns the next key in line
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub NEXTKEY  {
  my $self = shift;
  my( $last ) = @_;

  my $i=$self->{tied_enumerator}++;
  my @keys = $self->{config}->Parameters($self->{section});
  my $key=$keys[$i];
  return if (! defined $key);
  return wantarray ? ($key, $self->FETCH($key)) : $key;
} # end NEXTKEY


# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::DESTROY
#
# Args: (None)
#
# Description: Called on cleanup
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub DESTROY  {
  # my $self = shift
} # end DESTROY

