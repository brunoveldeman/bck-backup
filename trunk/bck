#! /usr/bin/perl --
# bck-backup.
# Written by : Bruno Veldeman
#
# To simplify use, some modules have been copied, this way no extra modules have to be installed.
# I'll check these modules from time to time to ensure they stay more or less up to date.
#
############################################################################
#                                                                          #
#   This program is free software: you can redistribute it and/or modify   #
#   it under the terms of the GNU General Public License as published by   #
#   the Free Software Foundation, either version 3 of the License, or      #
#   (at your option) any later version.                                    #
#                                                                          #
#   This program is distributed in the hope that it will be useful,        #
#   but WITHOUT ANY WARRANTY; without even the implied warranty or         #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          #
#   GNU General Public License for more details.                           #
#                                                                          #
#   You should have received a copy of the GNU General Public License      #
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.  #
#                                                                          #
############################################################################
#
#
use warnings;
use strict;
use English;

# Version del programma
my($version) = "2.0.8";
my($state);
my $cmdln =  eval { new CommandLine(); }  or die ($@);
$cmdln->ParseCommandLine();

# Look for flags
if ($cmdln->GetHelpFlag)
{
	&PrintHelp;
	exit(0);
};
if ($cmdln->GetVersionFlag)
{
	&PrintVersion;
	exit(0);
};
if ($cmdln->GetCheckFlag)
{
	&CheckConfig($cmdln->GetConfigFileName);
	exit(0);
};
if ($cmdln->GetInstallFlag)
{
	&CreateConfig($cmdln->GetConfigFileName);
	exit(0);
};
my $gsection = eval { new GlobalSection(); } or die ($@);
$state = &Main;
exit($state);
##################################################################################
#
# Sub Main
#
##################################################################################
sub Main
{
	my $report = Report->new();
	$report->SetTittle("Backup report.");
	$report->SetVerbose( $cmdln->GetVerboseFlag );
	$report->SetDebug( $cmdln->GetDebugFlag );
	my ( $cfg ) = undef;
	my ( $lang ) = undef;
	my $publicip;
	my $starttime = time();
#	$publicip  = `wget "http://www.girona.com/ip" -q -O - | grep "<BR>" | cut -d"<" -f1`;  # For testing
	$publicip = &GetIP();
	$report->AddEntry( "START ************ bck version " . $version . " *************", 2 );
	$report->AddEntry( "Start time : " . &GetTime() , 2 );
	$report->AddEntry( "Running on : " . $OSNAME . " , Perl version : " . $PERL_VERSION*1000 , 2 );
	$report->AddEntry( "Public IP Address : $publicip", 2 );
#	$gsection->CheckConfig();
	if ( -e $cmdln->GetConfigFileName )
	{
		$report->AddEntry("Using configuration from " . $cmdln->GetConfigFileName, 3);
		$cfg = Config::IniFiles->new( -file => $cmdln->GetConfigFileName );
	};
	if ( defined $cfg)
	{
		$report->AddEntry("Configuration sucsessfuly loaded ", 3);
		my ( @mails ) = $cfg->Parameters ("mail");
		my ( $mail );
		foreach $mail (@mails )
		{
			my ( $maillvl, $mailmode ) = split( /,/, $cfg->val( "mail", $mail ) );
			if ( not defined $mailmode )
			{
				$mailmode = "html and plain";
			};
			$report->AddMail( $mail , $maillvl, $mailmode);
			$report->AddEntry( "Mail " . $mail . " added with level " . $maillvl . " to receive " . $mailmode . " reports.", 3 );
		};
		my ( @dolist ) = split(/,/,$cmdln->GetDo());
		#my @all_sections = $cfg->Sections(); # For testing
		my $entry;
		foreach $entry (@dolist)
		{
			my $section = eval { new DoSection(); } or die ($@);
			$section->SetSection( $entry );
        		if ( $section->LoadSection( $cmdln->GetConfigFileName() ) == 0 )
			{
				$report->AddEntry( "Section [" . $section->GetSection() . "] loaded sucsessfuly", 3 );
				my $sectionstarttime = time();
				if ($section->CalcSize() == 0)
				{
					$report->AddEntry( " Total size of section : " . $section->GetSize() . " bytes.", 3 );
					$report->AddEntry( " Starting backup process, type = " . $section->GetType() . ".", 3 );
					my ( $status ) = $section->Backup();
					$report->AddTable( $section->GetName() . " [" . $section->GetSection() . "]", $status );
					if ( $status == 0 )
					{
						$report->AddEntry( " Section [" . $section->GetSection() . "] sucsessfully executed.", 3 );
					}
					else
					{
						$report->AddEntry( " Section [" . $section->GetSection() . "] exited with status " . $section->GetStatus . ".", 0 );
						$report->SetState( 2 );
					};
				}
				else
				{
					$report->AddEntry( " Section [" . $section->GetSection() . "] skipped, too much data for destination, " . $section->GetSize . " bytes, max " . $section->GetMaxSize . " bytes capacity.", 0 );
					$report->AddTable( $section->GetName() . " [" . $section->GetSection() . "]", 1 );
					$report->SetState( 2 );
				};
				$report->AddEntry( " Section time elapsed : " . (time() - $sectionstarttime) . " seconds" , 2 );
				$report->AddEntry( " Detailed log :", 4 );
				my @log = $section->GetLog();
				my ( $logline );
				foreach $logline (@log)
				{
					my ( $loglevel ) = 4;
					my ( $string ) = $logline;
					# loglevel string filtering
					if ( $section->GetType() eq 'sg2' )
					{
						if ($string =~ m/gbak: ERROR:/) { $loglevel = 0;};
						if ($string =~ m/gbak: readied database/) { $loglevel = 3;};
						if ($string =~ m/gbak: creating file/) { $loglevel = 3;};
						if ($string =~ m/gbak: closing file/) { $loglevel = 2;};
					};
					if ( $section->GetType() eq 'samba' )
					{
						if ($string =~ m/rsync error/) { $loglevel = 0;};
						if ($string =~ m/rsync:/) { $loglevel = 3;};
						if ($string =~ m/bytes received/) { $loglevel = 3;};
						if ($string =~ m/total size/) { $loglevel = 3;};
						if ($string =~ m/failed/) { $loglevel = 0;};
						if ($string =~ m/skipping/) { $loglevel = 3;};
					};
					if ( $section->GetType() eq 'local')
					{
						if ($string =~ m/rsync error/) { $loglevel = 0;};
						if ($string =~ m/rsync:/) { $loglevel = 3;};
						if ($string =~ m/bytes received/) { $loglevel = 3;};
						if ($string =~ m/total size/) { $loglevel = 3;};
						if ($string =~ m/failed/) { $loglevel = 0;};
						if ($string =~ m/skipping/) { $loglevel = 3;};
					};
					if ( $section->GetType() eq 'part' )
					{
						if ($string =~ m/rsync error/) { $loglevel = 0;};
						if ($string =~ m/rsync:/) { $loglevel = 3;};
						if ($string =~ m/bytes received/) { $loglevel = 3;};
						if ($string =~ m/total size/) { $loglevel = 3;};
						if ($string =~ m/failed/) { $loglevel = 0;};
						if ($string =~ m/skipping/) { $loglevel = 3;};
					};
					if ( $section->GetType() eq 'rsync' )
					{
						if ($string =~ m/rsync error/) { $loglevel = 0;};
						if ($string =~ m/rsync:/) { $loglevel = 3;};
						if ($string =~ m/bytes received/) { $loglevel = 3;};
						if ($string =~ m/total size/) { $loglevel = 3;};
						if ($string =~ m/failed/) { $loglevel = 0;};
						if ($string =~ m/skipping/) { $loglevel = 3;};
					};
					if ( $section->GetType() eq 'tape' )
					{
						if ($string =~ m/Cannot open: Permision denied/) { $loglevel = 0;};
						if ($string =~ m/No such file or directory/) { $loglevel = 0;};
					};
					if ( $section->GetType() eq 'optical' )
					{
						if ($string =~ m/unable to find or open device/) { $loglevel = 0;};
						if ($string =~ m/unable to open/) { $loglevel = 0;};
						if ($string =~ m/Current Write Speed/) { $loglevel = 3;};
						if ($string =~ m/extents written/) { $loglevel = 3;};
						if ($string =~ m/media/) { $loglevel = 3;};
						if ($string =~ m/Executing/) { $loglevel = 3;};
					};
					$report->AddEntry( $logline, $loglevel );
				};
				$report->AddEntry("End section [" . $section->GetSection() . "].", 3 );
			}
			else
			{
					$report->AddTable( " Section [" . $section->GetSection() . "] does not exist", 1 );
					$report->AddEntry( " Section [" . $section->GetSection() . "] does not exist.", 0 );
					$report->SetState( 2 );
			};
		};
	}
	else
	{
		$report->AddEntry( "Configuration file error", 0 );
		$report->SetState( 2 );
	};
	my ( $subject ) = "[backup error] Backup report (" . $gsection->GetClient() . ")";
	if ( $report->GetState() == 0 )
	{
		$subject =  "[backup] Backup report (" . $gsection->GetClient() . ")";
	}
	elsif ( $report->GetState() == 1 )
	{
		$subject =  "[backup warning] Backup report (" . $gsection->GetClient() . ")";
	}
	elsif ( $report->GetState() == 2 )
	{
		$subject =  "[backup error] Backup report (" . $gsection->GetClient() . ")";
	};
	$report->AddEntry( "Public IP Address : $publicip", 4 );				
	$report->AddEntry( "End time : " . &GetTime() , 2 );
	$report->AddEntry( "Total time elapsed : " . (time() - $starttime) . " seconds" , 2 );
	$report->AddEntry( "END ************ bck version " . $version . " *************", 2 );
	$report->SendReports( $subject, $report->GetState() );
	return ( $report->GetState() );
};
##################################################################################
#
# Sub GetIP :
#
##################################################################################
sub GetIP # () -> (myip)
{
	use Socket;
	my ($response, $myip);
	my $peer = sockaddr_in(80,inet_aton('www.girona.com'));
	socket( S, PF_INET, SOCK_STREAM, getprotobyname('tcp') );
	connect( S, $peer )or die "Couldn't connect!";
	select(S);
	$|=1;
	print S "GET /ip/ HTTP/1.0\n\n";
	select STDOUT;
	{
		while ( defined ( my $line = <S> )  )
			{
			chomp($line);
			$response .= $line;
			}
		close S;
	};
	$response =~ m/([\d]+\.[\d]+\.[\d]+\.[\d]+)/;
	if (defined ( $1 ) )
	{
		$myip = $1;
	}
	else
	{
		if (defined ($2))
		{
			$myip = $2;
		}
		else
		{
			$myip = "---.---.---.---";
		};
	};
	return ($myip);
};
##################################################################################
#
# Sub GetTime :
#
##################################################################################
sub GetTime # () -> (mytime)
{
	my ($mytime);
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	$mytime = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . $hour . ":" . $min . ":" . $sec . " (" . ($wday) . ")";
	return ($mytime);
};
##################################################################################
#
# Sub CheckConfig :
#
##################################################################################
sub CheckConfig # ($configfilename) -> ()
{
	my ( $configfile ) = @_;
	my ( $line );
	use Socket;
	print "bck version : $version\n";
	print "   Checking configuration file...\n";
	if (-r $configfile )
	{
		my $cfg = Config::IniFiles->new( -file => $configfile );
		unless ($cfg)
		{
		    print "   Error in loading configuration file `$configfile'\n";
		    foreach $line ( @Config::IniFiles::errors )
		    {
			print "      $line .\n";
		    };
		}
		else
		{
		    print "   Configuration file structure OK.\n";
		    print "   Checking configuration.\n";
		    print "   Global variables :\n";
			my ($lang)		= $cfg->val('global', 'lang');
			
			my ($client)		= $cfg->val('global', 'client');
			my ($sysloglevel)	= $cfg->val('global', 'sysloglevel');
			my ($winmsg)		= $cfg->val('global', 'winmsg');
			my ($mt)		= $cfg->val('global', 'mt');
			my ($tar)		= $cfg->val('global', 'tar');
			my ($smbmount)	= $cfg->val('global', 'smbmount');
			my ($smbumount)	= $cfg->val('global', 'smbumount');
			my ($smbclient)	= $cfg->val('global', 'smbclient');
			my ($sudo)		= $cfg->val('global', 'sudo');
			my ($rsync)		= $cfg->val('global', 'rsync');
			my ($dvdrecord)	= $cfg->val('global', 'dvdrecord');
			my ($dvdformat)	= $cfg->val('global', 'dvdformat');
			my ($cdrecord)	= $cfg->val('global', 'cdrecord');
			my ($gpg)		= $cfg->val('global', 'gpg');
			my ($smtpserver)	= $cfg->val('global', 'smtpserver');
			my ($smtpuser)	= $cfg->val('global', 'smtpuser');
			my ($smtppass)	= $cfg->val('global', 'smtppass');
			my ($smtpfrom) 	= $cfg->val('global', 'smtpfrom');
			# Tests			
			if ( defined $lang)
			{
				print "     lang ok.\n";
			}
			else	
			{
				print "    #lang not defined\n";
			};
			if ( defined $client)
			{
				print "     client ok.\n";
			}
			else	
			{
				print "    #client not defined\n";
			};
			if ( defined $sysloglevel)
			{
				if ( ($sysloglevel >= 0) and ($sysloglevel <= 5) )
				{
					print "     sysloglevel ok.\n";
				}
				else
				{
					print "    #sysloglevel out of range\n";
				}
			}
			else	
			{
				print "    #sysloglevel not defined\n";
			};
			if ( defined $winmsg)
			{
				if ( ($winmsg eq "yes") or ($winmsg eq "no") )
				{
					print "     winmsg ok.\n";
				}
				else
				{
					print "    #winmsg out of range\n";
				}
			}
			else	
			{
				print "    #winmsg not defined\n";
			};
			if ( defined $mt)
			{
				if ( -x ($mt) )
				{
					print "     mt ok.\n";
				}
				else
				{
					print "    #mt path/permission error\n";
				}
			}
			else	
			{
				print "    #mt not defined\n";
			};
			if ( defined $tar )
			{
				if ( -x ($tar) )
				{
					print "     tar ok.\n";
				}
				else
				{
					print "    #tar path/permission error\n";
				}
			}
			else	
			{
				print "    #tar not defined\n";
			};
			if ( defined $smbmount ) 
			{
				if ( -x ($smbmount) )
				{
					print "     smbmount ok.\n";
				}
				else
				{
				print "    #smbmount path/permission error\n";
				}
			}
			else	
			{
				print "    #smbmount not defined\n";
			};
			if ( defined $smbumount ) 
			{
				if ( -x ($smbumount) )
				{
					print "     smbumount ok.\n";
				}
				else
				{
					print "    #smbumount path/permission error\n";
				}
			}
			else	
			{
				print "    #smbumount not defined\n";
			};
			if ( defined $smbclient ) 
			{
				if ( -x ($smbclient) )
				{
					print "     smbclient ok.\n";
				}
				else
				{
					print "    #smbclient path/permission error\n";
				}
			}
			else	
			{
				print "    #smbclient not defined\n";
			};
			if ( defined $sudo)
			{
				if ( -x ($sudo) )
				{
					print "     sudo ok.\n";
				}
				else
				{
					print "    #sudo path/permission error\n";
				}
			}
			else	
			{
				print "    #sudo not defined\n";
			};
			if ( defined $rsync )
			{
				if ( -x ($rsync) )
				{
					print "     rsync ok.\n";
				}
				else
				{
					print "    #rsync path/permission error\n";
				}
			}
			else	
			{
				print "    #rsync not defined\n";
			};
			if ( defined $cdrecord )
			{
				if ( -x ($cdrecord) )
				{
					print "     cdrecord ok.\n";
				}
				else
				{
					print "    #cdrecord path/permission error\n";
				}
			}
			else	
			{
				print "    #cdrecord not defined\n";
			};
			if ( defined $dvdrecord )
			{
				if ( -x ($dvdrecord) )
				{
					print "     dvdrecord ok.\n";
				}
				else
				{
					print "    #dvdrecord path/permission error\n";
				}
			}
			else	
			{
				print "    #dvdrecord not defined\n";
			};
			if ( defined $dvdformat )
			{
				if ( -x ($dvdformat) )
				{
					print "     dvdformat ok.\n";
				}
				else
				{
					print "    #dvdformat path/permission error\n";
				}
			}
			else	
			{
				print "    #dvdformat not defined\n";
			};
			if ( defined $gpg )
			{
				if ( -x ($gpg) )
				{
					print "     gpg ok.\n";
				}
				else
				{
					print "    #gpg path/permission error\n";
				}
			}
			else	
			{
				print "    #gpg not defined\n";
			};
			if ( defined $smtpserver )
			{
				my ( $iaddr, $paddr, $proto );
			    if ( $iaddr  = inet_aton($smtpserver) )
				{
					#It worked
					$paddr = sockaddr_in(25, $iaddr);
					$proto = getprotobyname('tcp');
					if ( socket(SOCK, PF_INET, SOCK_STREAM, $proto) )
					{
						#It worked
						if ( connect(SOCK, $paddr) )
						{
							print "     smtpserver ok.\n";
						}
						else
						{
							print "    #Error in connecting to $smtpserver at port 25: $!\n";
						}
						close(SOCK);
					}
					else
					{
						print "    #Socket error: $!\n";
					};
				}
				else
				{
					print "    #host $smtpserver not responding, check your config file.\n";
				};
			}
			else	
			{
				print "    #smtpserver not defined\n";
			};
			if ( defined $smtpuser)
			{
				print "     smtpuser ok.\n";
			}
			else	
			{
				print "    #smtpuser not defined\n";
			};
			if ( defined $smtppass)
			{
				print "     smtppass ok.\n";
			}
			else	
			{
				print "    #smtppass not defined\n";
			};
			if ( defined $smtpfrom)
			{
				print "     smtpfrom ok.\n";
			}
			else	
			{
				print "    #smtpfrom not defined\n";
			};
		};
	};
};

##################################################################################
#
# Sub PrintHelp :
#
##################################################################################
sub PrintHelp # () -> ()
{
	print "bck version : $version\n";
	print "Options :\n";
	print "    --verbose				: Verbose\n";
	print "    --config-file=/mypath/myconfig.file]\n";
#	print "    --systemcheck			: Include system check in report\n";
#	print "    --install				: Create config file mode\n";
	print "    --check				: Check configuration file\n";
	print "    --debug 				: Debugging verbosity\n";
	print "    --version				: Show version\n";
	print "    --do=[block1[,block2...]]		: Execute block1, block2...\n";
	print "    --help|?				: Show this help\n\n";
};
##################################################################################
#
# Sub PrintVersion :
#
##################################################################################
sub PrintVersion # () -> ()
{
	print "bck version : $version\n";
};
##################################################################################
#
# Sub CreateConfig : Crear y guardar archivo de configuracion
#
##################################################################################
sub CreateConfig{ # (configfile) -> ()
	my($configfile) = @_;
	my($line);
	print "Creating config file subroutine\n";
	return(0);
};
##################################################################################
#
# Class CommandLine : Command line parameter storage class
#
##################################################################################
package CommandLine;
use Getopt::Long;
#constructor
sub new
{	my ($sysloglevel,$winmsg,$mt,$tar,$smbmount,$smbumount,$smbclient,
		$sudo,$rsync,$dvdrecord,$dvdformat,$cdrecord);

	my ($class) = @_;
	my $self =
	{
       	_verbose 	=> undef,
       	_configfile  	=> undef,
	_install	=> undef,
	_check		=> undef,
	_debug		=> undef,
	_do		=> undef,
       	_version   	=> undef,
       	_help       	=> undef
   	};
	bless $self, $class;
	return $self;
};
#accessor method for verbose
sub GetVerboseFlag {
	my ( $self ) = @_;
	return $self->{_verbose};
};
#accessor method for configfile
sub GetConfigFileName {
	my ( $self ) = @_;
	return $self->{_configfile};
};
#accessor method for install
sub GetInstallFlag {
	my ( $self ) = @_;
	return $self->{_install};
};
#accessor method for check
sub GetCheckFlag {
	my ( $self ) = @_;
	return $self->{_check};
};
#accessor method for debug
sub GetDebugFlag {
	my ( $self ) = @_;
	return $self->{_debug};
};
#accessor method for do
sub GetDo {
	my ( $self ) = @_;
	return $self->{_do};
};
#accessor method for version
sub GetVersionFlag {
	my ( $self ) = @_;
	return $self->{_version};
};
#accessor method for help
sub GetHelpFlag {
	my ( $self ) = @_;
	return $self->{_help};
};
#parse command line and fill class
sub ParseCommandLine{ # () -> (ok)
	my ( $self ) = @_;
	my ( $ok, $verbose, $configfile, $langfile, $help, $version, $debug, $install, $check, $do);
	my ( $status ) = 0;
	$ok = @ARGV;
	if ( $ok > 0 )
	{
		GetOptions(
			'verbose' => \$verbose,
			'config-file=s' => \$configfile,
			'install' => \$install,
			'check' => \$check,
			'debug' => \$debug,
			'do=s' => \$do,
			'version' => \$version,
			'help|?' => \$help);
	}
	else
	{
		print "No parameters specified, check documentation.\nUse --help option for more information.\n";		
		exit(0);
	};
	if (defined $verbose)
	{
		$self->{_verbose} = 1;
	}
	else
	{
		$self->{_verbose} = 0;
	};
	if (defined $configfile)
	{
		$self->{_configfile} = $configfile;
	}
	else
	{
		$self->{_configfile} = "/etc/bck/bck.config";
	};
	if (defined $install)
	{
		$self->{_install} = 1;
	}
	else
	{
		$self->{_install} = 0;
	};
	if (defined $check)
	{
		$self->{_check} = 1;
	}
	else
	{
		$self->{_check} = 0;
	};
	if (defined $debug)
	{
		$self->{_debug} = 1;
		$self->{_verbose} = 0;
	}
	else
	{
		$self->{_debug} = 0;
	};
	if (defined $do)
	{
		$self->{_do} = $do;
	}
	else
	{
		$self->{_do} = 0;
	};
	if (defined $version)
	{
		$self->{_version} = 1;
		return (0);
	}
	else
	{
		$self->{_version} = 0;
	};
	if (defined $help)
	{
		$self->{_help} = 1;
		return (0);
	}
	else
	{
		$self->{_help} = 0;
	};
	if ( not ( -f $self->{_configfile} ) )
	{
		print "Config file (" . $self->{_configfile} . ") does not exist, check documentation.\nUse --help option for more information.\n";		
		exit(0);
	};
	if ( not ( -r $self->{_configfile} ) )
	{
		print "Config file (" . $self->{_configfile} . ") cannot be read, check file permissions.\nUse --help option for more information.\n";		
		exit(0);
	};
	return($status);
};
##################################################################################
# End Class CommandLine
##################################################################################
##################################################################################
#
# Class GlobalSection : Global configuration file section class
#
##################################################################################
package GlobalSection;
sub new
{
	my ($class) = shift;
	my ($configfilename) =  $cmdln->GetConfigFileName();
	my ($lang,$client,$sysloglevel,$winmsg,$mt,$tar,$smbmount,$smbumount,$smbclient,
		$sudo,$rsync,$dvdrecord,$dvdformat,$cdrecord,$gpg);
	if (-r $configfilename )
	{
		my $cfg 	= Config::IniFiles->new( -file => $configfilename );
		unless ($cfg)
		{
		    die "Error in loading configuration file `$configfilename'\n Use --check option for detailed information\n";
		}
		$lang		= $cfg->val('global', 'lang');
		$client		= $cfg->val('global', 'client');
		$sysloglevel	= $cfg->val('global', 'sysloglevel');
		$winmsg		= $cfg->val('global', 'winmsg');
		$mt		= $cfg->val('global', 'mt');
		$tar		= $cfg->val('global', 'tar');
		$smbmount	= $cfg->val('global', 'smbmount');
		$smbumount	= $cfg->val('global', 'smbumount');
		$smbclient	= $cfg->val('global', 'smbclient');
		$sudo		= $cfg->val('global', 'sudo');
		$rsync		= $cfg->val('global', 'rsync');
		$dvdrecord	= $cfg->val('global', 'dvdrecord');
		$dvdformat	= $cfg->val('global', 'dvdformat');
		$cdrecord	= $cfg->val('global', 'cdrecord');
		$gpg		= $cfg->val('global', 'gpg');
	};
	my $self =
	{
		_lang		=> $lang,
		_client		=> $client,
		_sysloglevel	=> $sysloglevel,
		_winmsg		=> $winmsg,
		_mt			=> $mt,
		_tar			=> $tar,
		_smbmount	=> $smbmount,
		_smbumount	=> $smbumount,
		_smbclient	=> $smbclient,
		_sudo		=> $sudo,
		_rsync		=> $rsync,
		_cdrecord		=> $cdrecord,
		_dvdrecord	=> $dvdrecord,
		_dvdformat	=> $dvdformat,
		_gpg		=> $gpg,
	};
	bless $self, $class;
	return $self;
};
#accessor method for lang
sub GetLang 
{
	my ( $self ) = shift;
	return $self->{_lang};
};
#accessor method for client
sub GetClient 
{
	my ( $self ) = shift;
	return $self->{_client};
};
#accessor method for sysloglevel
sub GetSysLogLevel 
{
	my ( $self ) = shift;
	return $self->{_sysloglevel};
};
#accessor method for winmsg
sub GetWinMsg 
{
	my ( $self ) = shift;
	return $self->{_winmsg};
};
#accessor method for mt
sub GetMt 
{
	my ( $self ) = shift;
	return $self->{_mt};
};
#accessor method for tar
sub GetTar 
{
	my ( $self ) = shift;
	return $self->{_tar};
};
#accessor method for smbmount
sub GetSmbMount 
{
	my ( $self ) = shift;
	return $self->{_smbmount};
};
#accessor method for smbumount
sub GetSmbUmount 
{
	my ( $self ) = shift;
	return $self->{_smbumount};
};
#accessor method for smbclient
sub GetSmbClient 
{
	my ( $self ) = shift;
	return $self->{_smbclient};
};
#accessor method for sudo
sub GetSudo 
{
	my ( $self ) = shift;
	return $self->{_sudo};
};
#accessor method for rsync
sub GetRsync 
{
	my ( $self ) = shift;
	return $self->{_rsync};
};
#accessor method for dvdrecord
sub GetDvdRecord 
{
	my ( $self ) = shift;
	return $self->{_dvdrecord};
};
#accessor method for dvdformat
sub GetDvdFormat 
{
	my ( $self ) = shift;
	return $self->{_dvdformat};
};
#accessor method for cdrecord
sub GetCdRecord 
{
	my ( $self ) = shift;
	return $self->{_cdrecord};
};
#accessor method for gpg
sub GetGpg 
{
	my ( $self ) = shift;
	return $self->{_gpg};
};
##################################################################################
# End Class GlobalSection
##################################################################################
##################################################################################
#
# Class DoSection : Backup command block class
#
##################################################################################
package DoSection;
use File::Path;
use File::Temp qw/ tempfile tempdir /;
sub new
{
	my ($class) = shift;
	my $self =
	{
    		_section 	=> undef,
		_name 	 	=> undef,
		_type		=> undef,
		_sourcelist	=> undef,
		_excludelist 	=> undef,
		_dest		=> undef,
		_cmd		=> undef,
		_maxsize	=> undef,
		_user		=> undef,
		_pass		=> undef,
		_log		=> [],
           	_status   	=> undef,
		_medium 	=> undef,
	   	_size       	=> 0,
		_flagsize	=> undef,
		_flagfail	=> undef
    	};
	bless $self, $class;
	return $self;
};
#load method for section load from file
sub LoadSection
{
	my ( $self ) = shift;
	my ( $configfilename ) = @_;
	my $cfg = Config::IniFiles->new( -file => $configfilename );
	if ($cfg->SectionExists ( $self->{_section} ) )
	{
		$self->{_name}		= $cfg->val($self->{_section}, 'name');
		$self->{_type}		= $cfg->val($self->{_section}, 'type');
		$self->{_sourcelist}	= $cfg->val($self->{_section}, 'sourcelist');
		$self->{_excludelist} 	= $cfg->val($self->{_section}, 'excludelist');
		$self->{_dest}		= $cfg->val($self->{_section}, 'dest');
		$self->{_maxsize}	= $cfg->val($self->{_section}, 'maxsize');
		$self->{_cmd}		= $cfg->val($self->{_section}, 'cmd');
		$self->{_user}		= $cfg->val($self->{_section}, 'user');
		$self->{_pass}		= $cfg->val($self->{_section}, 'pass');
		$self->{_medium} 	= $cfg->val($self->{_section}, 'medium');
		return (0);
	}
	else
	{
		return(1);
	};
};
#accessor method for section
sub SetSection
{
	my ( $self ) = shift;
	my ( $section ) = @_;
	$self->{_section} = $section if defined($section);
};
#accessor method for section
sub GetSection
{
	my ( $self ) = shift;
	return $self->{_section};
};
#accessor method for medium
sub GetMedium
{
	my ( $self ) = shift;
	return $self->{_medium};
};
#accessor method for name
sub GetName
{
	my ( $self ) = shift;
	return $self->{_name};
};
#accessor method for user
sub GetUser
{
	my ( $self ) = shift;
	return $self->{_user};
};
#accessor method for pass
sub GetPass
{
	my ( $self ) = shift;
	return $self->{_pass};
};
#accessor method for log
sub GetLog
{
	my ( $self ) = shift;
	return @{$self->{_log}};
};
#accessor method for status
sub SetStatus
{
	my ( $self ) = shift;
	my ( $status ) = @_;
	$self->{_status} = $status if defined($status);
};
#accessor method for status
sub GetStatus
{
	my ( $self ) = shift;
	return $self->{_status};
};
#accessor method for type
sub GetType
{
	my ( $self ) = shift;
	return $self->{_type};
};
#accessor method for size
sub GetSize
{
	my ( $self ) = shift;
	return $self->{_size};
};
#accessor method for maxsize
sub GetMaxSize
{
	my ( $self ) = shift;
	return $self->{_maxsize};
};
sub CalcSize
{
	my ( $self ) = shift;
	if ( defined $self->{_sourcelist} )
	{
		my ( $excludelist ) = ' ';
		if ( defined $self->{_excludelist} )
		{
			my (@excludes ) = split(/,/,$self->{_excludelist});
			my ( $exclude );
			foreach $exclude (@excludes)
			{
				$excludelist = $excludelist . ' --exclude=' . $exclude;
			};
		};
		my ( @sources ) = split(/,/,$self->{_sourcelist});
		my ( $source );
		my ( $size ) = 0;
		foreach $source (@sources)
		{
			if (-e $source)
			{
				my $cmd = SysCommand->new();
				my ( $cmdline );
				$cmdline = 'du -s --dereference -c ' . $excludelist . ' ' . $source;
				$cmd->Exec( $cmdline );
				if ($cmd->GetStatus() == 0)
				{
					my ( $line ) = $cmd->GetLog();
					my ( @retval ) = split(/\t/,$line);
					$self->{_size} += ( $retval[0] * 1024 );
				};
			};
		};
	};
	if ( defined $self->{_maxsize} )
	{
		$self->{_flagsize} = ( $self->{_size} > $self->{_maxsize} );
	}
	else
	{
		$self->{_flagsize} = 0;
		$self->{_size} = 0;
	};
	return ( $self->{_flagsize} );
};
sub Backup
{
	my ( $self ) = shift;
	my ( @sources ) = split(/,/,$self->{_sourcelist} );
	my ( $source );
	#local copy
	if ( $self->{_type} eq 'local' )
	{
		foreach $source (@sources)
		{
			if ( -e $source )
			{
				my $cmd = SysCommand->new();
				my ( $excludelist ) = ' ';
				if ( defined $self->{_excludelist} )
				{
					my (@excludes ) = split(/,/,$self->{_excludelist});
					my ( $exclude );
					foreach $exclude (@excludes)
					{
						$excludelist = $excludelist . ' --exclude=' . $exclude;
					};
				};
				my $cmdline = 'rsync --recursive --copy-links --verbose --delete --relative ' . $excludelist . ' ' . $source . ' ' . $self->{_dest};
				$cmd->Exec($cmdline);
				my $status = $cmd->GetStatus();
				$self->{_status} += $status;
				my @log = $cmd->GetLog();
				foreach (@log)
				{
					push( @{$self->{_log}}, "  " . $_ );
				};
			}
			else
			{
				$self->{_status} += 1 ;
				push( @{$self->{_log}}, " Source " . $source . " does not exist." );
			};
		};
	};
	#copy to samba share
	if ( $self->{_type} eq 'samba' )
	{
		my $tmpdir = tempdir("/var/tmp/BCKXXXXXX");
		my $cmd = SysCommand->new();
		my $cmdline = "smbclient " . $self->{_dest} . " " . $self->GetPass() . " -E --command='exit' --user=" . $self->GetUser();
		$cmd->Exec($cmdline);
		my $status = $cmd->GetStatus();
		$self->{_status} += $status;
		my @log = $cmd->GetLog();
		foreach (@log)
		{
			push( @{$self->{_log}}, "  " . $_ );
		};
		if ( $status == 0 )
		{
			my ( $smbd ) = $self->{_dest};
			$smbd =~ m/\/\/(.*)\//i;
			my $cmd = SysCommand->new();
			my $cmdline = "smbmount " . $smbd . " " . $tmpdir . " -o lfs,rw,username=" . $self->GetUser() . ",password=" . $self->GetPass();
			$cmd->Exec($cmdline);
			my $status = $cmd->GetStatus();
			$self->{_status} += $status;
			my @log = $cmd->GetLog();
			foreach (@log)
			{
				push( @{$self->{_log}}, "  " . $_ );
			};
			if ( $status == 0 )
			{
				foreach $source (@sources)
				{
					if ( -e $source )
					{
						my $cmd = SysCommand->new();
						my ( $excludelist ) = ' ';
						if ( defined $self->{_excludelist} )
						{
							my (@excludes ) = split(/,/,$self->{_excludelist});
							my ( $exclude );
							foreach $exclude (@excludes)
							{
								$excludelist = $excludelist . ' --exclude=' . $exclude;
							};
						};
						my $cmdline = 'rsync --recursive --copy-links --verbose --delete --relative ' . $excludelist . ' ' . $source . ' ' . $tmpdir;
						$cmd->Exec($cmdline);
						my $status = $cmd->GetStatus();
						$self->{_status} += $status;
						my @log = $cmd->GetLog();
						foreach (@log)
						{
							push( @{$self->{_log}}, "  " . $_ );
						};
					}
					else
					{
						$self->{_status} += 1 ;
						push( @{$self->{_log}}, " Source " . $source . " does not exist." );
					};
				};
				my $cmd = SysCommand->new();
				my $cmdline = "umount " . $self->{_dest};
				$cmd->Exec($cmdline);
				my $status = $cmd->GetStatus();
				$self->{_status} += $status;
				my @log = $cmd->GetLog();
				foreach (@log)
				{
					push( @{$self->{_log}}, "  " . $_ );
				};
			};
		}
		else
		{
			$self->{_status} += 1 ;
			push( @{$self->{_log}}, " Samba share " . $self->{_dest} . " could not be mounted." );
		};
		rmtree( $tmpdir );
	};
	#copy to partition
	if ( $self->{_type} eq 'part' )
	{
		my ( @daynames ) = qw( Domingo Lunes Martes Miercoles Jueves Viernes Sabado );
		my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
		my ( $wdname ) = $daynames[$wday];
		my $cmd = SysCommand->new();
		my $tmpdir = tempdir("/var/tmp/BCKXXXXXX");
		my $cmdline = "mount " . $self->{_dest} . " " . $tmpdir;
		$cmd->Exec($cmdline);
		my $status = $cmd->GetStatus();
		$self->{_status} += $status;
		my @log = $cmd->GetLog();
		foreach (@log)
		{
			push( @{$self->{_log}}, "  " . $_ );
		};
		if ( $status == 0 )
		{
			foreach $source (@sources)
			{
				if ( -e $source )
				{
					my $cmd = SysCommand->new();
					my ( $excludelist ) = ' ';
					if ( defined $self->{_excludelist} )
					{
						my (@excludes ) = split(/,/,$self->{_excludelist});
						my ( $exclude );
						foreach $exclude (@excludes)
						{
							$excludelist = $excludelist . ' --exclude=' . $exclude;
						};
					};
					my $destdir = $tmpdir . "/" . $wdname;
					my $cmdline = 'rsync --recursive --copy-links --verbose --delete --relative ' . $excludelist . ' ' . $source . ' ' . $destdir . '/';
					$cmd->Exec($cmdline);
					my $status = $cmd->GetStatus();
					$self->{_status} += $status;
					my @log = $cmd->GetLog();
					foreach (@log)
					{
						push( @{$self->{_log}}, "  " . $_ );
					};
				}
				else
				{
					$self->{_status} += 1 ;
					push( @{$self->{_log}}, " Source " . $source . " does not exist." );
				};
			};
			my $cmd = SysCommand->new();
			my $cmdline = "umount " . $tmpdir;
			$cmd->Exec($cmdline);
			my $status = $cmd->GetStatus();
			$self->{_status} += $status;
			my @log = $cmd->GetLog();
			foreach (@log)
			{
				push( @{$self->{_log}}, "  " . $_ );
			};
		}
		else
		{
			$self->{_status} += 1 ;
			push( @{$self->{_log}}, " Partition " . $self->{_dest} . " could not be mounted." );
		};
		rmtree( $tmpdir );
	};
	# tape copy
	if ( $self->{_type} eq 'tape' )
	{
		my ( $sourcelist ) = "";
		foreach $source (@sources)
		{
			if ( -e $source )
			{
				$sourcelist = $sourcelist . "  " . $source;
			}
			else
			{
				$self->{_status} += 1 ;
				push( @{$self->{_log}}, " Source " . $source . " does not exist." );
			};
		};
		my $cmd = SysCommand->new();
		#mt status
		my $cmdline = "mt -f " . $self->{_dest} . " status";
		#mt -f /dev/st0 status with 20/40GB tape in DAT72
		#drive type = Generic SCSI-2 tape
		#drive status = 637534208
		#sense key error = 0
		#residue count = 0
		#file number = 0
		#block number = 0
		#Tape block size 0 bytes. Density code 0x26 (unknown).
		#Soft error count since last status=0
		#General status bits on (41010000):
		# BOT ONLINE IM_REP_EN
		#mt -f /dev/st0 status with 36/72GB tape in DAT72
		#drive type = Generic SCSI-2 tape
		#drive status = 1191182336
		#sense key error = 0
		#residue count = 0
		#file number = 0
		#block number = 0
		#Tape block size 0 bytes. Density code 0x47 (unknown).
		#Soft error count since last status=0
		#General status bits on (41010000):
		# BOT ONLINE IM_REP_EN

		$cmd->Exec($cmdline);
		my $status = $cmd->GetStatus();
		$self->{_status} += $status;
		my @log = $cmd->GetLog();
		foreach (@log)
		{
			push( @{$self->{_log}}, "  " . $_ );
		};
		if ( $status == 0 )
		{
			push( @{$self->{_log}}, " Tape status ok." );
			#tar
			{
				my $cmd = SysCommand->new();
				my ( $excludelist ) = ' ';
				if ( defined $self->{_excludelist} )
				{
					my (@excludes ) = split(/,/,$self->{_excludelist});
					my ( $exclude );
					foreach $exclude (@excludes)
					{
						$excludelist = $excludelist . ' --exclude=' . $exclude;
					};
				};
				my $cmdline = 'tar --create  --dereference --verbose --totals ' . $excludelist . ' --file ' . $self->{_dest} . ' ' . $sourcelist;
				$cmd->Exec($cmdline);
				my $status = $cmd->GetStatus();
				$self->{_status} += $status;
				my @log = $cmd->GetLog();
				foreach (@log)
				{
					push( @{$self->{_log}}, "  " . $_ );
				};
			};
			# mt rewoffl
			{
				my $cmd = SysCommand->new();
				my $cmdline = "mt -f " . $self->{_dest} . " rewoffl";
				$cmd->Exec($cmdline);
				my $status = $cmd->GetStatus();
				$self->{_status} += $status;
				my @log = $cmd->GetLog();
				foreach (@log)
				{
					push( @{$self->{_log}}, "  " . $_ );
				};
			};
		}
		else
		{
			push( @{$self->{_log}}, " Tape status error, no tape found in device or wrong/defective tape." );
		};
	};
	# exec section
	if ( $self->{_type} eq 'exec' )
	{
		foreach $source (@sources)
		{
			if ( -e $source )
			{
				my $cmd = SysCommand->new();
				my $cmdline = "cd " . $source . " ; " . $self->{_cmd};
				$cmd->Exec($cmdline);
				my $status = $cmd->GetStatus();
				$self->{_status} += $status;
				my @log = $cmd->GetLog();
				foreach (@log)
				{
					push( @{$self->{_log}}, "  " . $_ );
				};
			}
			else
			{
				$self->{_status} += 1 ;
				push( @{$self->{_log}}, " Source " . $source . " does not exist." );
			};
		};
	};
	# sg2 section
	if ( $self->{_type} eq 'sg2' )
	{
		foreach $source (@sources)
		{
			my ( @daynames ) = qw( backupsg2_7 backupsg2_1 backupsg2_2 backupsg2_3 backupsg2_4 backupsg2_5 backupsg2_6  );
			my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
			my ( $wdname ) = $daynames[$wday];
			my $cmd = SysCommand->new();
			my $cmdline = $self->{_cmd} . " " . $source . " " . $self->{_dest} . "/" . $wdname . ".gbk";
			$cmd->Exec($cmdline);
			my $status = $cmd->GetStatus();
			$self->{_status} += $status;
			my @log = $cmd->GetLog();
			foreach (@log)
			{
				push( @{$self->{_log}}, "  " . $_ );
			};
			system ( "cp " . $self->{_dest} . "/" . $wdname . ".gbk " . $self->{_dest}. "/copy.gbk" )
		};
	};
	# rsync section
	if ( $self->{_type} eq 'rsync' )
	{
		foreach $source (@sources)
		{
			if ( -e $source )
			{
				my $cmd = SysCommand->new();
				my ( $excludelist ) = ' ';
				if ( defined $self->{_excludelist} )
				{
					my (@excludes ) = split(/,/,$self->{_excludelist});
					my ( $exclude );
					foreach $exclude (@excludes)
					{
						$excludelist = $excludelist . ' --exclude=' . $exclude;
					};
				};
				my $cmdline = 'rsync --recursive --copy-links --verbose --delete --relative ' . $excludelist . ' ' . $source . ' ' . $self->{_dest};
				$cmd->Exec($cmdline);
				my $status = $cmd->GetStatus();
				$self->{_status} += $status;
				my @log = $cmd->GetLog();
				foreach (@log)
				{
					push( @{$self->{_log}}, "  " . $_ );
				};
			}
			else
			{
				$self->{_status} += 1 ;
				push( @{$self->{_log}}, " Source " . $source . " does not exist." );
			};
		};
	};	
	# cipher section
	if ( $self->{_type} eq 'cipher' )
	{
		foreach $source (@sources)
		{
			if ( -e $source )
			{
				my $cmd = SysCommand->new();
				my ( $excludelist ) = ' ';
				if ( -d $self->{_dest} )
				{
				    rmtree( $self->{_dest} );
				}
				if ( defined $self->{_excludelist} )
				{
					my (@excludes ) = split(/,/,$self->{_excludelist});
					my ( $exclude );
					foreach $exclude (@excludes)
					{
						$excludelist = $excludelist . ' --exclude=' . $exclude;
					};
				};
				my ( $cmdline );
				my ( $status ) = 0;
				$cmdline = 'du --all --dereference ' . $excludelist . ' ' . $source;
				#print "$cmdline\n";
				open (DATA, "$cmdline 2>&1 |") or $status = 1;
				if ( $status == 0 )
				{
				    while ( defined ( my $line = <DATA> )  )
				    {
					chomp($line);
					my ( $size, $file ) = split(/\t/, $line);
					if ( -f qq($file) )
					{
					    #print '#### File -> "' .qq($file) .'"'."\n";
					    my ( $dest ) = ($self->{_dest} . $file . '.gpg');
					    my ( $path ) = $dest;
					    my ( $dir, $filename ) = $path =~ m/(.*\/)(.*)$/;
					    mkpath( $dir );
					    my ( $cmdline ) = 'gpg --yes -z 9 -r BCKKEY --output "'. qq($dest) . '" --encrypt "' . qq($file) . '"';
					    #print "$cmdline\n";
					    $cmd->Exec($cmdline);
					    $status = $cmd->GetStatus();
					    $self->{_status} += $status;
					    #my @log = $cmd->GetLog();
					    #foreach (@log)
					    #{
					    #    push( @{$self->{_log}}, "  " . $_ );
					    #};
					};
				    };
				    close DATA;
				};
				
			}
			else
			{
				$self->{_status} += 1 ;
				push( @{$self->{_log}}, " Source " . $source . " does not exist." );
			};
		};
	};	
	# optical section
	if ( $self->{_type} eq 'optical' )
	{
		my ( $sourcelist ) = "";
		foreach $source (@sources)
		{
			if ( -e $source )
			{
				$source =~ s/^\s+//; # Remove leading spaces
				$source =~ s/\s+$//;  # Remove trailing spaces
				$sourcelist = $sourcelist . "  " . $source . "=" . $source; # Building filelist for mkisofs
			}
			else
			{
				$self->{_status} += 1 ;
				push( @{$self->{_log}}, " Source " . $source . " does not exist." );
			};
		};
	# [DVD|CD|DVDRW|CDRW|DVD9|DVD9RW]
	if($self->{_medium} eq "DVD")
		{
		$self->CloseTray();
		$self->WriteDvd($sourcelist);
		$self->OpenTray();
		}
	elsif($self->{_medium} eq "CD")
		{
		$self->CloseTray();
		$self->WriteCd($sourcelist);
		$self->OpenTray();
		}
	elsif($self->{_medium} eq "DVDRW")
		{
		$self->CloseTray();
		$self->FormatDvd();
		$self->WriteDvd($sourcelist);
		$self->OpenTray();
		}
	elsif($self->{_medium} eq "CDRW")
		{
		$self->CloseTray();
		$self->FormatCd();
		$self->WriteCd($sourcelist);
		$self->OpenTray();
		}
	elsif($self->{_medium} eq "DVD9")
		{
		# No implementado
		}
	elsif($self->{_medium} eq "DVD9RW")
		{
		# No implementado
		}
	else
		{
		};
	};	
	if ( not defined $self->{_status} )
	{
		$self->{_status} = -1;
	};
	return $self->{_status}
};

############################################################################
##
## Sub OpenTray : Open Tray
##
############################################################################
sub OpenTray
{
	my ( $self ) = shift;
	my $cmd = SysCommand->new();
	my $cmdline = $gsection->GetCdRecord() . " -eject -dev=" . $self->{_dest};
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	my @log = $cmd->GetLog();
	foreach (@log)
	{
		push( @{$self->{_log}}, "  " . $_ );
	};
	return(0);
};
############################################################################
##
## Sub CloseTray : Close tray
##
############################################################################
sub CloseTray
{
	my ( $self ) = shift;
	my $cmd = SysCommand->new();
	my ( $cmdline ) = $gsection->GetCdRecord() . " -load -dev=" . $self->{_dest};
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	my @log = $cmd->GetLog();
	foreach (@log)
	{
		push( @{$self->{_log}}, "  " . $_ );
	};
	return(0);
};
############################################################################
##
## Sub FormatDvd : Format DVD
##
############################################################################
sub FormatDvd
{
	my ( $self ) = shift;
	my $cmd = SysCommand->new();
	my $cmdline = $gsection->GetDvdFormat() . " -force " . $self->{_dest};
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	my @log = $cmd->GetLog();
	foreach (@log)
	{
		push( @{$self->{_log}}, "  " . $_ );
	};
	return(0);
};
############################################################################
##
## Sub FormatCd : Format CD
##
############################################################################
sub FormatCd
{
	my ( $self ) = shift;
	my $cmd = SysCommand->new();
	my $cmdline = $gsection->GetCdRecord() . " -blank=fast -dev=" . $self->{_dest};
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	my @log = $cmd->GetLog();
	foreach (@log)
	{
		push( @{$self->{_log}}, "  " . $_ );
	};
	return(0);
};
############################################################################
##
## Sub WriteDvd : Write DVD
##
############################################################################
sub WriteDvd
{
	my ( $self ) = shift;
	my ( $filelist ) = @_;
	my ( @daynames ) = qw( sunday monday tuesday wednesday thursday friday saturday );
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	my ( $wdname ) = $daynames[$wday];
	my $cmd = SysCommand->new();
	my ( $excludelist ) = ' ';
	if ( defined $self->{_excludelist} )
	{
		my (@excludes ) = split(/,/,$self->{_excludelist});
		my ( $exclude );
		foreach $exclude (@excludes)
		{
			$excludelist = $excludelist . ' -m ' . $exclude;
		};
	};
	my $cmdline = $gsection->GetDvdRecord() . ' -Z ' . $self->{_dest} . ' -joliet-long  -J ' . $excludelist . ' -R -V "' . $gsection->GetClient() . " " . $wdname . '" -graft-points '. $filelist;
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	my @log = $cmd->GetLog();
	foreach (@log)
	{
		push( @{$self->{_log}}, "  " . $_ );
	};
};
############################################################################
##
## Sub WriteCd : Write CD
##
############################################################################
sub WriteCd
{
	my ( $self ) = shift;
	my ( $filelist ) = @_;
	my ( @daynames ) = qw( sunday monday tuesday wednesday thursday friday saturday );
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	my ( $wdname ) = $daynames[$wday];
	my $tmpdir = tempdir("/var/tmp/BCKXXXXXX");
	my $cmd = SysCommand->new();
	my ( $excludelist ) = ' ';
	if ( defined $self->{_excludelist} )
	{
		my (@excludes ) = split(/,/,$self->{_excludelist});
		my ( $exclude );
		foreach $exclude (@excludes)
		{
			$excludelist = $excludelist . ' -m ' . $exclude;
		};
	};
	my $cmdline = 'mkisofs -joliet-long -o ' . $tmpdir . '/cd.iso -J ' . $excludelist . ' -R -V "' . $gsection->GetClient() . ' ' . $wdname . '" -graft-points '. $filelist;
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	my @log = $cmd->GetLog();
	foreach (@log)
	{
		push( @{$self->{_log}}, "  " . $_ );
	};
	my $cmd2 = SysCommand->new();
	$cmdline = "cdrecord -v -speed=8 -dev=" . $self->{_dest} . " " . $tmpdir . "/cd.iso";
	$cmd2->Exec($cmdline);
	$status = $cmd2->GetStatus();
	$self->{_status} += $status;
	@log = $cmd2->GetLog();
	foreach (@log)
	{
		push( @{$self->{_log}}, "  " . $_ );
	};
	rmtree( $tmpdir );
}
##################################################################################
# End Class DoSection
##################################################################################
##################################################################################
#
# Class ParseOutput : Command output error parsing and filtering for various
#
##################################################################################
package ParseOutput;
sub new
{
	my ($class) = shift;
	my $self =
	{
        	_cmd 	 => undef,
			_log		=> [],
			_errorlog => [],
        	_status   	=> 0,
    	};
	bless $self, $class;
	return $self;
};
##################################################################################
# End Class ParseOutput
##################################################################################
##################################################################################
#
# Class SysCommand : Command line execution class
#
##################################################################################
package SysCommand;
sub new
{
	my ($class) = shift;
	my $self =
	{
        	_cmd 	 => undef,
			_log		=> [],
        	_status   	=> 0,
    	};
	bless $self, $class;
	return $self;
};
sub Exec
{
	my ( $self ) = shift;
	$self->{_cmd} = shift;
	my($data,$status,$cmd);
	$cmd = $self->{_cmd};
	open (DATA, "$cmd 2>&1 |" ) or $self->{_status} = 1;
	if ( $self->{_status} == 0 )
	{
		while ( defined ( my $line = <DATA> )  )
			{
			chomp($line);
			push(@{$self->{_log}},$line);
			}
		close DATA;
		$self->{_status} = $? >> 8;
	};
	push(@{$self->{_log}},"***Command : " . $cmd);
};
sub GetStatus
{
	my ( $self ) = shift;
	return $self->{_status};
};
sub GetLog
{
	my ( $self ) = shift;
	return @{$self->{_log}};
};
##################################################################################
# End Class SysCommand
##################################################################################
##################################################################################
#
# Class Report : Report summary class
#
##################################################################################
package Report;
use MIME::QuotedPrint;
use Sys::Syslog;
# Configuracion para el perl module Mail::Sendmail
our @ISA = qw(ReportLine TableLine Mail);    # inherits from ReportLine, TableLine, Mail
sub new
{
	my ( $class ) = shift;
	my ( $level );
	my $self =
	{
        	_title			=> undef,
		_entry 	 	=> [],
		_mail		=> [],
		_table		=> [],
		_verbose		=> undef,
		_debug		=> undef,
		_state		=> 0,
    	};
	bless $self, $class;
	return $self;
};
#accessor method for title
sub SetTittle
{
	my ( $self ) = shift;
	my ( $title ) = @_;
	$self->{_title} = $title;
};
#accessor method for verbose
sub SetVerbose
{
	my ( $self ) = shift;
	my ( $verbose ) = @_;
	$self->{_verbose} = $verbose;
};
#accessor method for debug
sub SetDebug
{
	my ( $self ) = shift;
	my ( $debug ) = @_;
	$self->{_debug} = $debug;
};
#accessor method for report array
sub AddEntry
{
	my ( $self ) = shift;
	my ( $text, $level) = @_;
	if( $text ne "" )
	{
		$text =~ s/[^a-zA-Z0-9_\n\s\*\[\]:.\-\+\/\@\&]\'\"//g;
		push( @{$self->{_entry}}, ReportLine->new( $text, $level ) );
		if ( $level < 4 ) { $self->VerbosePrint( $text ); };
		$self->DebugPrint( $text );
		if ( $level <= $gsection->GetSysLogLevel() ) 
		{
			$self->SysLog( $text );
		};
	};
};
#accessor method for state
sub GetState
{
	my ( $self ) = shift;
	return ( $self->{_state} );
};
#accessor method for state
sub SetState
{
	my ( $self ) = shift;
	my ( $state ) = @_;
	if ( $self->{_state} < $state )
	{
		$self->{_state} = $state;
	};
};
#accessor method for table array
sub AddTable
{
	my ( $self ) = shift;
	my ( $text, $status) = @_;
	if( $text ne "" )
	{
		push( @{$self->{_table}}, TableLine->new( $text, $status ) );
	};
};
#accessor method for mail array
sub AddMail
{
	my ( $self ) = shift;
	my ( $address, $level, $mode ) = @_;
	push( @{$self->{_mail}}, Mail->new( $address, $level, $mode ) );
};
sub SendReports
{
	my ( $self ) = shift;
	my ( $subject, $state ) = @_;
	my ( $mail );
	foreach $mail ( @{ $self->{_mail}} )
	{
		my ( $address, $level, $mode ) = $mail->Get();
		my ( @log, $logentry, $tableentry, $html, $plaintext );
		my ( $log ) = "";
		my ( $logstat ) = 0;
		my ( $tablestat ) = 0;
		$plaintext = "----------------------------------------------------\n" 
		. "| " . sprintf("%-49s","Backup report ( Level : $level )") . "|\n" 
		. "----------------------------------------------------\n";
		$html = "<table style=\"width: 80%; text-align: left;\" border=\"2\" cellpadding=\"2\"\n"
		. "cellspacing=\"2\">\n"
		. "<tbody>\n"
		. "<tr align=\"center\">\n"
		. "<th colspan=\"2\" rowspan=\"1\" style=\"background-color: rgb(255, 255, 204); vertical-align: top;\">"
		. "<fontsize=\"+2\">Backup report ( Level : $level )</font><br>\n"
		. "</th>\n"
		. "</tr>\n"
		. "<tr>\n"
		. "<th style=\"vertical-align: top; text-align: center;\">Operation<br>\n"
		. "</th>\n"
		. "<th style=\"vertical-align: top; width: 100px; text-align: center;\">Status<br>\n"
		. "</th>\n"
		. "</tr>\n";
		foreach $logentry ( @{$self->{_entry}} )
		{
			my ( $text, $lvl ) = $logentry->Get();
			if ( $lvl <= $level )
			{
				push( @log , $text );
			};
		};
		foreach $tableentry ( @{$self->{_table}} )
		{
			my ( $text, $status ) = $tableentry->Get();
			$plaintext .= "| " . sprintf("%-35s" ,$text);
			$html .= "<tr>\n" . "<td style=\"vertical-align: top;\">$text<br>\n" . "</td>\n";
			if ( $status == 0 )
			{			
				$html .= "<td style=\"background-color: rgb(51, 255, 51); vertical-align: top; width: 100px; text-align: center;\">OK<br>\n";
				$plaintext .= "| " . sprintf("%11s"," - OK - ") . " |\n"
				. "----------------------------------------------------\n";
			}
			else
			{
				$html .= "<td style=\"background-color: rgb(255, 0, 0); vertical-align: top; width: 100px; text-align: center;\">ERROR<br>\n";
				$plaintext .= "| " . sprintf("%11s"," * ERROR * ") . " |\n"
				. "----------------------------------------------------\n";
			}
			$html .= "</td>\n"
			."</tr>\n";
		};
		$plaintext .= "\n";
		$html .= "</tbody>\n"
		. "</table>\n"
		. "<br>\n";
		foreach (@log)
		{
			$log .= $_ . "\n";
		};
		$html .= "<br>\n";
		if ( $mode  eq "html" )
		{
			$plaintext = "Only html reports for this e-mail";
		}
		elsif ( $mode eq "plain" )
		{
			$html = "Only plaintext reports for this e-mail";
		};
		if ( ( $self->{_state} == 2 ) | ( $level >= 2 ) | ( ( $self->{_state} == 1 ) & ( $level == 1 ) ) )
		{
			my ( $mailstat, $maillog ) = $self->MailReport( $address, $subject , $html, $plaintext, $state, $log );
			$self->AddEntry( " Mail ". $address . " send with exit status " . $mailstat, 3 );
			$self->AddEntry( " Mail log :", 4 );
			$self->AddEntry( $maillog, 4 );
		};
	};
	return ( 0 );
};
sub MailReport
{
	my ( $self ) = shift;
	my ( $mailaddr, $subject, $msghtml, $msgplain, $state, $log ) = @_;
	my ( $rc, $plain, $html ,$body );
	my ($configfilename) =  $cmdln->GetConfigFileName();
	my $cfg = Config::IniFiles->new( -file => $configfilename );
	my ($smtpserver)	= $cfg->val('global', 'smtpserver');
	my ($smtpuser)	= $cfg->val('global', 'smtpuser');
	my ($smtppass)	= $cfg->val('global', 'smtppass');
	my ($smtpfrom) 	= $cfg->val('global', 'smtpfrom');
	#my ( $boundary ) = "====" . time() . "====";
	$plain =  $msgplain;
	$html =  $msghtml;
	my $sm = SendMail->new($smtpserver, 25);
	#
	#
	# Set SMTP AUTH login profile.
	#
	#sm->setAuth($sm->AUTHLOGIN, $smtpuser , $smtppass);
	$sm->setAuth($sm->AUTHPLAIN, $smtpuser , $smtppass );
	#
	# We set the debug mode "OFF". 
	#
	$sm->setDebug($sm->OFF);
	#
	# We set the sender.
	#
	$sm->From($smtpfrom);
	#
	# We set the subject.
	#
	$sm->Subject($subject);
	#
	# We set the recipient.
	#
	$sm->To($mailaddr);
	#
	# We set the mail headers
	#
	#$obj->setMailHeader($mailheader, $mailheadervalue);
	#$sm->setMailHeader('content-type', "multipart/alternative; boundary=\"$boundary\"");
	#if ( $state != 0 )
	#	{
	#	$sm->setMailHeader('X-Priority', "1 (Highest)");
	#	};
	$sm->setMailHeader('X-Mailer', "bck [mailobject " . $sm->version . "]");
	$sm->setMailHeader('User-Agent', "bck [$version]");
	#
	# We set the content of the mail.
	#
	#$boundary = '--' . $boundary;
	#
	# Set body content
	#
	$html = "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
		."<html>\n"
		."<head>\n"
		."<meta content=\"text/html; charset=ISO-8859-1\"\n"
		."http-equiv=\"content-type\">\n"
		."<title></title>\n"
		."</head>\n"
		."<body>\n"
		."$html"
		."</body>\n"
		."</html>\n";
	$sm->setMailBody( $html, $plain );
	#
	# Attach log as a file.
	#
	$sm->Inline("log.txt", \$log);
	#
	# To attach config file, uncomment this.
	#
	#$sm->Attach( $configfilename );
	#
	# Check if the mail sent successfully or not.
	#
	if ($sm->sendMail() != 0) {
		$rc = 1;
	}
	else
	{
		$rc = 0;
	};
	return( $rc, $sm->{'log'} );
};
sub VerbosePrint 
{
	my ( $self ) = shift;
	my ( $string ) = @_;
	if ( $self->{_verbose} )
	{
		print $string ."\n";
	};	
};
sub DebugPrint 
{
	my ( $self ) = shift;
	my ( $string ) = @_;
	if ( $self->{_debug} )
	{
		print $string . "\n";
	};	
};
sub SysLog
{
	my ( $self ) = shift;
	my ( $string ) = @_;
	my ( $name ) = "bck";
	openlog($name, 'cons,pid', 'user');
	syslog('info', '%s', $string);
	closelog();
};
##################################################################################
# End Class Report
##################################################################################
##################################################################################
#
# Class ReportLine : Reportline class
#
##################################################################################
package ReportLine;
sub new
{
	my ( $class ) = shift;
	my ( $text, $level ) = @_;
	my $self =
	{
        	_text		=> $text,
		_lvl			=> $level,
    	};
	bless $self, $class;
	return $self;
};
#accessor method for reportline
sub Get
{
	my ( $self ) = shift;
	return ( $self->{_text}, $self->{_lvl} );
};
##################################################################################
# End Class ReportLine
##################################################################################
##################################################################################
#
# Class Mail : Mail container class
#
##################################################################################
package Mail;
sub new
{
	my ( $class ) = shift;
	my ( $address, $level, $mode) = @_;
	my $self =
	{
        	_address		=> $address,
		_lvl			=> $level,
		_mode 		=> $mode,
    	};
	bless $self, $class;
	return $self;
};
#accessor method for reportline
sub Get
{
	my ( $self ) = shift;
	return ( $self->{_address}, $self->{_lvl}, $self->{_mode} );
};
##################################################################################
# End Class Mail
##################################################################################
##################################################################################
#
# Class TableLine : TableLine class
#
##################################################################################
package TableLine;
sub new
{
	my ( $class ) = shift;
	my ( $text, $status) = @_;
	my $self =
	{
        	_text		=> $text,
		_status		=> $status,
    	};
	bless $self, $class;
	return $self;
};
#accessor method for reportline
sub Get
{
	my ( $self ) = shift;
	return ( $self->{_text}, $self->{_status} );
};
##################################################################################
# End Class TableLine
##################################################################################
##################################################################################
#
# Class SendMail : Sendmail object
#
##################################################################################
package SendMail;
#===============================================================================
#
# Constructor: 
#	$obj = new SendMail;
#       $obj = new SendMail($smtpserver);
#       $obj = new SendMail($smtpserver, $smtpport);
#
# Methods:
#	$obj->Attach($filename, [\$data]);
# 	$obj->Bcc($bccemailadd1, [$bccemailadd2, ...]);
# 	$obj->Cc($ccemailadd1, [$ccemailadd2, ...]);
# 	$obj->ErrorsTo($errorstoadd1, [$errorstoadd2, ...]);
# 	$obj->From($sender);
#	$obj->Inline($filename, [\$data]);
#	$obj->AUTHLOGIN;
#	$obj->AUTHPLAIN;
# 	$obj->OFF;
# 	$obj->ON;
# 	$obj->ReplyTo($replytoadd1, [$replytoadd2, ...]);
# 	$obj->Subject($subject);
# 	$obj->To($recipient1, [$recipient2, ...]);
#	$obj->attach(\%hash);
#	$obj->clearAttach();
#	$obj->clearBcc();
#	$obj->clearCc();
#	$obj->clearTo();
# 	$obj->createMailData();
# 	$obj->getEmailAddress($emailaddstr);
# 	$obj->getRcptLists();
# 	$obj->isMailReady();
#	$obj->receiveFromServer(\*SOCKET);
# 	$obj->reset();
# 	$obj->sendMail();
#	$obj->sendToServer(\*SOCKET, $message);
#	$obj->setAuth($authtype, $userid, $password);
# 	$obj->setDebug($obj->ON);
# 	$obj->setError($errormessage);
# 	$obj->setMailBody($htmlbody, $plainbody);
# 	$obj->setMailHeader($mailheader, $mailheadervalue);
# 	$obj->setSMTPPort($smtpport);
# 	$obj->setSMTPServer($smtpserver);
# 	$obj->version;
#
# *p/s: For more details, please refer to the description below.
#
#===============================================================================

#
# We are using Socket.pm to connect to the SMTP port.
#
use Socket;

#
# We are using MIME::Base64 and MIME::QuotedPrint to encode MIME data.
#
use MIME::Base64;
use MIME::QuotedPrint;

#use Exporter;
use strict;
#use vars qw($_LOCALHOST $VERSION $_MAILER @ISA @EXPORT @EXPORT_OK $_ERR);
#use vars qw($_DEFAULT_SMTP_PORT);
#@EXPORT = qw();
#@EXPORT_OK = qw();
my ($_LOCALHOST, $VERSION, $_MAILER,$_ERR,$_DEFAULT_SMTP_PORT);


#===============================================================================
#
# CONSTRUCTOR:	$obj = new SendMail;
#		$obj = new SendMail($smtpserver);
#		$obj = new SendMail($smtpserver, $smtpport);
#
# DESCRIPTION:	This is the constructor of the SendMail object.
#
#===============================================================================
sub new {
    my($pkg) 		= shift;
    my($smtpserver) 	= shift;
    my($smtpport) 	= shift;
    my($self) 		= {};

    bless $self, $pkg;

    #
    # The mail server.
    #
    $self->{'smtpserver'}  = ($smtpserver && $smtpserver !~ /^\s*$/)
		 ? $smtpserver : "localhost";

    #
    # The port number for smtp.
    #
    $self->{'smtpport'}    = ($smtpport && $smtpport =~ /^\d+$/) ? $smtpport : 
		$_DEFAULT_SMTP_PORT;

    #
    # The default debug mode is "OFF".
    #
    $self->{'debugmode'}   = $self->OFF;

    #
    # Set the default mailer.
    #
    $self->setMailHeader("X-MAILER", $_MAILER);

    #
    # Create empty attachment array.
    #
    $self->{'attachmentArr'} = [];

    #
    # SMTP AUTH
    #
    $self->{'authtype'} = "";
    $self->{'authuserid'} = "";
    $self->{'authpassword'} = "";
	$self->{'log'} = "";
    $VERSION = "2.09_bck";
    $_MAILER  = "Bck Sendmail $VERSION";
	$_DEFAULT_SMTP_PORT = 25;
	#
	# Some of the SMTP server needs to say "HELO domain.address".
	#
	eval {
		require Sys::Hostname;
		$_LOCALHOST = Sys::Hostname::hostname();
	};
	$_LOCALHOST = $_MAILER if $@;

    return $self;

}

#===============================================================================
#
# METHOD:	$obj->Attach($filename, [\$data]);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of 
#		reading from the file.
#
#===============================================================================
sub Attach ($;$) {
    my($self) = shift;
    my($filename) = shift;
    my($dataRef) = shift;
    my(%hash, $dump);

    return $self->setError("No attachment has been specified.")
	if $filename =~ /^\s*$/;
    if ($filename =~ /(\\|\/)/) {
      ($hash{'filename'}) = $filename =~ /^.*[\\\/]([^\\\/]+)$/;
    }
    else {
      $hash{'filename'} = $filename;
    }
    $hash{'filepath'} = $filename;
    $hash{'dataref'} = $dataRef if ref($dataRef) !~ /^\s*$/;
    $hash{'attachtype'} = "attachment";
    return $self->attach(\%hash);

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->Bcc($bccemailadd1, [$bccemailadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the blind carbon copy 
#		list.
#
#===============================================================================
sub Bcc ($) {
    my($self)      = shift;
    my(@bcc)       = @_;
    my($currEmail) = undef;

    for $currEmail (@bcc) {
      push(@{$self->{'mailheaders'}->{'BCC'}}, $currEmail) if 
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
    }

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->Cc($ccemailadd1, [$ccemailadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the carbon copy list.
#
#===============================================================================
sub Cc ($) {
    my($self)      = shift;
    my(@cc)        = @_;
    my($currEmail) = undef;

    for $currEmail (@cc) {
      push(@{$self->{'mailheaders'}->{'CC'}}, $currEmail) if 
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
    }

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->ErrorsTo($errorstoadd1, [$errorstoadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address into the "Errors-To" list.
#
#===============================================================================
sub ErrorsTo ($) {
    my($self)      = shift;
    my(@errorsto)  = @_;
    my($currEmail) = undef;

    for $currEmail (@errorsto) {
      push(@{$self->{'mailheaders'}->{'ERRORS-TO'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
    }

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->From($sender);
#
# DESCRIPTION:	Set the sender of the email.
#
#===============================================================================
sub From ($) {
    my($self) = shift;
    my($from) = shift;

    $self->{'mailheaders'}->{'FROM'} = $from;

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->Inline($filename, [\$data]);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of 
#		reading from the file.
#
#===============================================================================
sub Inline ($;$) {
    my($self) = shift;
    my($filename) = shift;
    my($dataRef) = shift;
    my(%hash, $dump);

    return $self->setError("No attachment has been specified.")
	if $filename =~ /^\s*$/;
    if ($filename =~ /(\\|\/)/) {
      ($hash{'filename'}) = $filename =~ /^.*[\\\/]([^\\\/]+)$/;
    }
    else {
      $hash{'filename'} = $filename;
    }
    $hash{'filepath'} = $filename;
    $hash{'dataref'} = $dataRef if ref($dataRef) !~ /^\s*$/;
    $hash{'attachtype'} = "inline";
    return $self->attach(\%hash); print $hash{'dataref'};

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->OFF;
#
# DESCRIPTION:	Will return 0. Basically, it is used to set the debug mode OFF.
#		Eg. $obj->setDebug($obj->OFF);
#
#===============================================================================
sub OFF () {
    return 0;
}

#===============================================================================
#
# METHOD:	$obj->ON;
#
# DESCRIPTION:	Will return 1. Basically, it is used to set the debug mode ON.
#		Eg. $obj->setDebug($obj->ON);
#
#===============================================================================
sub ON () {
    return 1;
}

#===============================================================================
#
# METHOD:	$obj->AUTHLOGIN;
#
# DESCRIPTION:	Will return string 'AUTH LOGIN'.
#		Eg. $obj->setAuth($obj->AUTHLOGIN, $userid, $password);
#
#===============================================================================
sub AUTHLOGIN () {
  return 'AUTH LOGIN';
}

#===============================================================================
#
# METHOD:	$obj->AUTHPLAIN;
#
# DESCRIPTION:	Will return string 'AUTH PLAIN'.
#		Eg. $obj->setAuth($obj->AUTHPLAIN, $userid, $password);
#
#===============================================================================
sub AUTHPLAIN () {
  return 'AUTH PLAIN';
}

#===============================================================================
#
# METHOD:	$obj->ReplyTo($replytoadd1, [$replytoadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address into the "Reply-To" list.
#
#===============================================================================
sub ReplyTo ($;@) {
    my($self)      = shift;
    my(@replyto)   = @_;

    push(@{$self->{'mailheaders'}->{'REPLY-TO'}}, @replyto);

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->Subject($subject);
#
# DESCRIPTION:	Set the subject of the email.
#
#===============================================================================
sub Subject ($) {
    $_[0]->{'mailheaders'}->{'SUBJECT'} = $_[1];

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->To($recipient1, [$recipient2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the recipient list.
#
#===============================================================================
sub To ($;@) {
    my($self)      = shift;
    my(@to)        = @_;
    
    for (@to) {
      my($currEmail) = $_;
      push(@{$self->{'mailheaders'}->{'TO'}}, $currEmail) if 
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
    }

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->attach(\%hash);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of 
#		reading from the file.
#
#===============================================================================
sub attach ($) {
    my($self) = shift;
    my($dataRef) = shift;

    return $self->setError("No attachment has been specified.")
	if $dataRef->{'filename'} =~ /^\s*$/;
    push(@{$self->{'attachmentArr'}}, $dataRef);

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->clearAttach();
#
# DESCRIPTION:	This method will clear the attachment stack.
#
#===============================================================================
sub clearAttach () {
    my($self) = shift;
    $self->{'attachmentArr'} = [];
}

#===============================================================================
#
# METHOD:	$obj->clearBcc();
#
# DESCRIPTION:	This method will clear the email addresses specified for Bcc:.
#
#===============================================================================
sub clearBcc () {
    my($self) = shift;
    $self->{'mailheaders'}->{'BCC'} = [];
}

#===============================================================================
#
# METHOD:	$obj->clearCc();
#
# DESCRIPTION:	This method will clear the email addresses specified for Cc:.
#
#===============================================================================
sub clearCc () {
    my($self) = shift;
    $self->{'mailheaders'}->{'CC'} = [];
}

#===============================================================================
#
# METHOD:	$obj->clearTo();
#
# DESCRIPTION:	This method will clear the email addresses specified for To:.
#
#===============================================================================
sub clearTo () {
    my($self) = shift;
    $self->{'mailheaders'}->{'TO'} = [];
}

#===============================================================================
#
# METHOD:	$obj->createMailData();
#
# DESCRIPTION:	This method will create the mail data which will be sent to the
#		SMTP server. It will contain some mail headers and mail body.
#
#===============================================================================
sub createMailData () {
    my($self) = shift;
    my($currHeader) = undef;

    return -1 if $self->isMailReady() != 0;

    $self->{'maildata'} = undef;

    $self->{'maildata'} = "To: ";
    $self->{'maildata'} .= join(",\r\n\t", @{$self->{'mailheaders'}->{'TO'}});
    $self->{'maildata'} .= "\r\nFrom: ".$self->{'mailheaders'}->{'FROM'}."\r\n";
    $self->{'maildata'} .= "Subject: ".$self->{'mailheaders'}->{'SUBJECT'}."\r\n";
    if (defined $self->{'mailheaders'}->{'CC'} && 
		@{$self->{'mailheaders'}->{'CC'}} > 0) {
      $self->{'maildata'} .= "Cc: ";
      $self->{'maildata'} .= join(",\r\n\t", @{$self->{'mailheaders'}->{'CC'}});
      $self->{'maildata'} .= "\r\n";
    }

    if (defined $self->{'mailheaders'}->{'REPLY-TO'} && 
		@{$self->{'mailheaders'}->{'REPLY-TO'}} > 0) {
      $self->{'maildata'} .= "Reply-To: ";
      $self->{'maildata'} .= join(",\r\n\t", 
		@{$self->{'mailheaders'}->{'REPLY-TO'}})."\r\n";
    }

    if (defined $self->{'mailheaders'}->{'ERRORS-TO'} && 
		@{$self->{'mailheaders'}->{'ERRORS-TO'}} > 0) {
      $self->{'maildata'} .= "Errors-To: ";
      $self->{'maildata'} .= join(",\r\n\t", 
		@{$self->{'mailheaders'}->{'ERRORS-TO'}})."\r\n";
    }

    for $currHeader (sort keys %{$self->{'mailheaders'}->{'OTHERS'}}) {
      my($currMailHeader) = undef;
      ($currMailHeader = $currHeader) =~ s/\b(\w)(\w+)\b/$1\L$2/g;
      $self->{'maildata'} .= "$currMailHeader: ";
      $self->{'maildata'} .= $self->{'mailheaders'}->{'OTHERS'}->{$currHeader};
      $self->{'maildata'} .= "\r\n";
    }

    if (scalar(@{$self->{'attachmentArr'}}) > 0) {
      my($currHash);
      srand(time ^ $$);
      my($boundary) = "==__BCK__".
		join("", ('a'..'z','A'..'Z', 0..9)[map rand $_, (62)x25]).
		"__==";
      my($boundary2) = "==__BCK__".
		join("", ('a'..'z','A'..'Z', 0..9)[map rand $_, (62)x25]).
		"__==";
      $self->{'maildata'} .= "MIME-Version: 1.0\r\n";
      $self->{'maildata'} .= "Content-Type: multipart/mixed;";
      $self->{'maildata'} .= "boundary=\"$boundary\"\r\n";
      $self->{'maildata'} .= "\r\n";
      $self->{'maildata'} .= "This is a multi-part message in MIME format.\r\n";
      $self->{'maildata'} .= "\-\-$boundary\r\n";
      $self->{'maildata'} .= "Content-Type: multipart/alternative;";
      $self->{'maildata'} .= "boundary=\"$boundary2\"\r\n";
      $self->{'maildata'} .= "\r\n";

      if (defined $self->{'plainbody'}) {
        $self->{'maildata'} .= "\-\-$boundary2\r\n";
        $self->{'maildata'} .= "Content-Type: text/plain; charset=\"iso-8859-1\"\r\n";
        $self->{'maildata'} .= "Content-Transfer-Encoding: quoted-printable\r\n\r\n";
        $self->{'maildata'} .= encode_qp($self->{'plainbody'})."\r\n\r\n";
      }

      if (defined $self->{'htmlbody'}) {
        $self->{'maildata'} .= "\-\-$boundary2\r\n";
        $self->{'maildata'} .= "Content-Type: text/html; charset=\"iso-8859-1\"\r\n";
        $self->{'maildata'} .= "Content-Transfer-Encoding: quoted-printable\r\n\r\n";
        $self->{'maildata'} .= encode_qp($self->{'htmlbody'})."\r\n\r\n";
      }
      $self->{'maildata'} .= "\-\-${boundary2}\-\-\r\n";
      for $currHash (@{$self->{'attachmentArr'}}) {
        $currHash->{'content-type'} = 
		$self->getMIMEType($currHash->{'filename'});
        $self->{'maildata'} .= "\-\-$boundary\r\n";
        $self->{'maildata'} .= "Content-Type: $currHash->{'content-type'}; name=\"$currHash->{'filename'}\"\r\n";
        $self->{'maildata'} .= "Content-Transfer-Encoding: base64\r\n";
        $self->{'maildata'} .= "Content-Disposition: $currHash->{'attachtype'}; filename=\"$currHash->{'filename'}\"\r\n";
        $self->{'maildata'} .= "\r\n";

	if (defined $currHash->{'dataref'}) {
	  if (ref($currHash->{'dataref'}) eq "SCALAR") {
	    $self->{'maildata'} .= encode_base64(${$currHash->{'dataref'}}, "\r\n");
	  }
	  else {
	    my($data) = undef;
	    my($buff) = "";
	    my($pos) = 0;
	    (defined ($pos = tell($currHash->{'dataref'}))) ||
    		return $self->setError("Error in tell(): $!");
	    while (read($currHash->{'dataref'}, $buff, 1024)) {
	      $data .= $buff;
            }
	    $self->{'maildata'} .= encode_base64($data, "\r\n");
	    seek($currHash->{'dataref'}, $pos, 0) ||
    		return $self->setError("Error in seek(): $!");
	  }
	}
	elsif (-f $currHash->{'filepath'}) {
          my($data) = undef;
	  my($buff) = "";
          open(FILE, $currHash->{'filepath'});
	  # In Windows platform, non-text file should use binmode() function.
	  if (! -T $currHash->{'filepath'}) {
	    binmode(FILE);
	  }
	  while (sysread(FILE, $buff, 1024)) {
	    $data .= $buff;
          }
          close(FILE);
          $self->{'maildata'} .= encode_base64($data, "\r\n");
	}
	else {
	  $self->{'maildata'} .= encode_base64("", "\r\n");
	}
        $self->{'maildata'} .= "\r\n";
      }
      $self->{'maildata'} .= "\-\-${boundary}\-\-\r\n";
    }
    else {
      my($tmpbody) = $self->{'mailbody'};
      $tmpbody =~ s/([^\r])\n/$1\r\n/g;
      $self->{'maildata'} .= "\r\n";
      $self->{'maildata'} .= "$tmpbody\r\n";
    }

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->getEmailAddress($emailaddstr);
#
# DESCRIPTION:	Get the email address from the email address string which might
#		contain email account owner's name, what we want is the email 
#		address only.
#
#===============================================================================
sub getEmailAddress ($) {
    my($self)  = shift;
    my($value) = shift;
    my($retvalue) = undef;

    if ($value =~ /^\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/) {
      ($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
      return $retvalue;
    }

    if ($value =~ /^[^\<]+\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/) {
      ($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
      return $retvalue;
    }

    return "" if $value =~ /\s+/;

    $value =~ tr/[A-Z]/[a-z]/;
    return $value if $value =~ /^[^\@]+\@[\w\-]+(\.[\w\-]+)+$/;

    return "";
}

#===============================================================================
#
# METHOD:	$obj->getMIMEType($filename);
#
# DESCRIPTION:	This will return MIME type for $filename.
#
#===============================================================================
sub getMIMEType ($) {
    my($self) = shift;
    my($filename) = shift;
    my($ext, %MIMEHash);

    %MIMEHash = (
	'au'	=> 'audio/basic',
	'avi'	=> 'video/x-msvideo',
	'class'	=> 'application/octet-stream',
	'cpt'	=> 'application/mac-compactpro',
	'dcr'	=> 'application/x-director',
	'dir'	=> 'application/x-director',
	'doc'	=> 'application/msword',
	'exe'	=> 'application/octet-stream',
	'gif'	=> 'image/gif',
	'gtx'	=> 'application/x-gentrix',
	'jpeg'	=> 'image/jpeg',
	'jpg'	=> 'image/jpeg',
	'js'	=> 'application/x-javascript',
	'hqx'	=> 'application/mac-binhex40',
	'htm'	=> 'text/html',
	'html'	=> 'text/html',
	'mid'	=> 'audio/midi',
	'midi'	=> 'audio/midi',
	'mov'	=> 'video/quicktime',
	'mp2'	=> 'audio/mpeg',
	'mp3'	=> 'audio/mpeg',
	'mpeg'	=> 'video/mpeg',
	'mpg'	=> 'video/mpeg',
	'pdf'	=> 'application/pdf',
	'pm'	=> 'text/plain',
	'pl'	=> 'text/plain',
	'ppt'	=> 'application/powerpoint',
	'ps'	=> 'application/postscript',
	'qt'	=> 'video/quicktime',
	'ram'	=> 'audio/x-pn-realaudio',
	'rtf'	=> 'application/rtf',
	'tar'	=> 'application/x-tar',
	'tif'	=> 'image/tiff',
	'tiff'	=> 'image/tiff',
	'txt'	=> 'text/plain',
	'wav'	=> 'audio/x-wav',
	'xbm'	=> 'image/x-xbitmap',
	'zip'	=> 'application/zip',
    );
    ($ext) = $filename =~ /\.([^\.]+)$/;
    $ext =~ tr/[A-Z]/[a-z]/;
    
    return defined $MIMEHash{$ext} ? $MIMEHash{$ext} : "application/octet-stream";

}

#===============================================================================
#
# METHOD:	$obj->getRcptLists();
#
# DESCRIPTION:	This will generate an array of the recipients' email address.
#		Basically, this method only called by $obj->sendMail() method, 
#		which needs to send "RCPT TO:" request to the SMTP server.
#
#===============================================================================
sub getRcptLists () {
    my($self) = shift;
    my(@rcptLists) = ();
    my($currEmail) = undef;

    for $currEmail (@{$self->{'mailheaders'}->{'TO'}}) {
      my($currEmail) = $self->getEmailAddress($currEmail);
      push(@rcptLists, $currEmail) if 
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
    }

    if (defined $self->{'mailheaders'}->{'BCC'} && 
		@{$self->{'mailheaders'}->{'BCC'}} > 0) {
      for $currEmail (@{$self->{'mailheaders'}->{'BCC'}}) {
        my($currEmail) = $self->getEmailAddress($currEmail);
        push(@rcptLists, $currEmail) if 
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
      }
    }

    if (defined $self->{'mailheaders'}->{'CC'} && 
		@{$self->{'mailheaders'}->{'CC'}} > 0) {
      for $currEmail (@{$self->{'mailheaders'}->{'CC'}}) {
        my($currEmail) = $self->getEmailAddress($currEmail);
        push(@rcptLists, $currEmail) if 
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
      }
    }

    return \@rcptLists;
}

#===============================================================================
#
# METHOD:	$obj->isMailReady();
#
# DESCRIPTION:	Check if the basic mail headers and the mail body have been set 
#		or not.
#		p/s: The "From:", "To:" and "Subject:" mail headers are required
#		here, I feel that a mail should contain these headers. It is 
#		just a personal opinion, if you do not think so, just comment 
#		them out.
#
#===============================================================================
sub isMailReady () {
    my($self) = shift;

    return $self->setError("No sender has been specified.") if
	! defined $self->{'mailheaders'}->{'FROM'};

    return $self->setError("No recipient has been specified.") if 
	((! defined $self->{'mailheaders'}->{'TO'}) ||
		(defined @{$self->{'mailheaders'}->{'TO'}} &&
		 @{$self->{'mailheaders'}->{'TO'}} < 1));

    return $self->setError("No subject has been specified.") if
	! defined $self->{'mailheaders'}->{'SUBJECT'};

    return $self->setError("No mail body has been set.") if
	((! defined $self->{'mailbody'}) &&
		(scalar(@{$self->{'attachmentArr'}}) < 1));

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->receiveFromServer(\*SOCKET);
#
# DESCRIPTION:	This will receive the data replied from the server.
#
#===============================================================================
sub receiveFromServer ($) {
    my($self) = shift;
    my($socket) = shift;
    my($reply);

    #
    # We keep receiveing the data from the server until
    # it waits for next command.
    #
    while ($socket && ($reply = <$socket>)) {
      return $self->setError($reply) if $reply =~ /^5/;
      print $reply if $self->{'debugmode'};
	  $self->{'log'} .= $reply;
      last if $reply =~ /^\d+ /;
    }

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->reset();
#
# DESCRIPTION:	This will clear the data that have been set before.
#
#===============================================================================
sub reset () {
    my($self) = shift;

    $self->{'debugmode'} = $self->OFF;
    $self->{'mailbody'} = undef;
    $self->{'maildata'} = undef;
    $self->{'mailheaders'} = undef;
    $self->{'sender'} = undef;
    $self->{'attachmentArr'} = [];
    $self->{'authtype'} = "";
    $self->{'authuserid'} = "";
    $self->{'authpassword'} = "";

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->sendMail();
#
# DESCRIPTION:	This will use the Socket to connect to the SMTP port to send the
#		mail.
#
#===============================================================================
sub sendMail () {
    my($self) = shift;
    my($iaddr, $paddr, $proto, $rcptlistRef, $currEmail) = undef;

    #
    # Get the sender's email address, this will be used in "MAIL FROM:" request.
    #
    $self->{'sender'} = $self->getEmailAddress($self->{'mailheaders'}->{'FROM'});

    #
    # Invalid email address format.
    #
    return $self->setError("Please check the sender's email address setting.")
	if $self->{'sender'} =~ /^\s*$/; 

    #
    # We create the mail data here.
    #
    return -1 if $self->createMailData() != 0;

    #
    # We get the recipients' email addresses.
    #
    $rcptlistRef = $self->getRcptLists();

    #
    # If no recipient has been specified, this is an error.
    #
    return $self->setError("No recipient has been specified.") if 
		@{$rcptlistRef} == 0;

    #
    # Please refer to Socket module manual. (perldoc Socket)
    #
    $iaddr = inet_aton($self->{'smtpserver'}) || 
		return $self->setError("no host: $self->{'smtpserver'}, please specify SMTP server with \"\$obj = new SendMail('your.smtp.server');\"");
    $paddr = sockaddr_in($self->{'smtpport'}, $iaddr);
    $proto = getprotobyname('tcp');
    socket(SOCK, PF_INET, SOCK_STREAM, $proto) || 
		return $self->setError("Socket error: $!");
    connect(SOCK, $paddr) || 
	return $self->setError("Error in connecting to $self->{'smtpserver'} at port $self->{'smtpport'}: $!");

    return -1 if $self->receiveFromServer(\*SOCK) != 0;
    return -1 if $self->sendToServer(\*SOCK, "EHLO $_LOCALHOST") != 0;
    if ($self->receiveFromServer(\*SOCK) != 0) {
      return -1 if $self->sendToServer(\*SOCK, "HELO $_LOCALHOST") != 0;
      return -1 if $self->receiveFromServer(\*SOCK) != 0;
    }

    #
    # SMTP AUTH LOGIN type.
    #
    if ($self->{'authtype'} eq $self->AUTHLOGIN) {
      return -1 if $self->sendToServer(\*SOCK, $self->{'authtype'});
      return -1 if $self->receiveFromServer(\*SOCK) != 0;
      return -1 if $self->sendToServer(\*SOCK, 
		encode_base64($self->{'authuserid'}, "")) != 0;
      return -1 if $self->receiveFromServer(\*SOCK) != 0;
      return -1 if $self->sendToServer(\*SOCK, 
		encode_base64($self->{'authpassword'}, "")) != 0;
      return -1 if $self->receiveFromServer(\*SOCK) != 0;
      
    }

    #
    # SMTP AUTH PLAIN type.
    #
    if ($self->{'authtype'} eq $self->AUTHPLAIN) {
      return -1 if $self->sendToServer(\*SOCK, 
		$self->{'authtype'}." ".
		encode_base64(
			join("\0", "", $self->{'authuserid'}, 
			$self->{'authpassword'}), "")) != 0;
      return -1 if $self->receiveFromServer(\*SOCK) != 0;
    }

    return -1 if $self->sendToServer(\*SOCK, "MAIL FROM: <$self->{'sender'}>") != 0;
    return -1 if $self->receiveFromServer(\*SOCK) != 0;
    for $currEmail (@{$rcptlistRef}) {
      return -1 if $self->sendToServer(\*SOCK, "RCPT TO: <$currEmail>") != 0;
      return -1 if $self->receiveFromServer(\*SOCK) != 0;
    }
    return -1 if $self->sendToServer(\*SOCK, "DATA") != 0;
    return -1 if $self->receiveFromServer(\*SOCK) != 0;
    return -1 if $self->sendToServer(\*SOCK, "$self->{'maildata'}\r\n.") != 0;
    return -1 if $self->receiveFromServer(\*SOCK) != 0;
    return -1 if $self->sendToServer(\*SOCK, "QUIT") != 0;
    return -1 if $self->receiveFromServer(\*SOCK) != 0;
    eof(SOCK) || close(SOCK) || 
	return $self->setError("Fail close connectiong socket: $!");
    print "The mail has been sent to ".scalar(@{$rcptlistRef}) if 
		$self->{'debugmode'};
	$self->{'log'} .= "The mail has been sent to ".scalar(@{$rcptlistRef});
    print " person/s successfully.\n" if $self->{'debugmode'};
	$self->{'log'} .= " person/s successfully.";
    return 0;
}

#===============================================================================
#
# METHOD:	$obj->setAuth($authtype, $userid, $password);
#
# DESCRIPTION:	This will set the authentication information.
#		$obj->setAuth($obj->AUTHLOGIN, $userid, $password);
#		$obj->setAuth($obj->AUTHPLAIN, $userid, $password);
#
#===============================================================================
sub setAuth ($$$) {
    my($self) = shift;
    $self->{'authtype'} = shift;
    $self->{'authuserid'} = shift;
    $self->{'authpassword'} = shift;
}

#===============================================================================
#
# METHOD:	$obj->sendToServer(\*SOCKET, $message);
#
# DESCRIPTION:	This will send the message to the SMTP server.
#
#===============================================================================
sub sendToServer ($$) {
    my($self) = shift;
    my($socket) = shift;
    my($message) = shift;

    print "$message\r\n" if $self->{'debugmode'};
	#$self->{'log'} .= "$message\r\n";

    # Fix BareLf problem.
    $message =~ s/\n/\r\n/g;
    $message =~ s/\r\r\n/\r\n/g;

    #
    # Sending data to the server.
    #
    send($socket, "$message\r\n", 0) || 
		return $self->setError("Fail to send $message: $!");

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->setDebug($obj->ON);
#		$obj->setDebug($obj->OFF);
#
# DESCRIPTION:	Set the debug mode as ON/OFF.
#		Also see: $obj->ON and $obj->OFF methods.
#
#===============================================================================
sub setDebug ($) {
    my($self) = shift;

    $self->{'debugmode'} = shift;

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->setError($errormessage);
#
# DESCRIPTION:	This will set the error message to "error" attribute in the 
#		object and return -1 value.
#
#===============================================================================
sub setError ($) {
    my($self)     = shift;
    my($errorMsg) = shift;

    $self->{'error'} = $errorMsg if $errorMsg !~ /^\s*$/;

    return -1;
}

#===============================================================================
#
# METHOD:	$obj->setMailBody($htmlbody, $plainbody);
#
# DESCRIPTION:	Set the mail body content.
#
#===============================================================================
sub setMailBody ($$) {
    my($self)	  = shift;
    my($htmlbody) = shift;
	my($plainbody) = shift;

    $self->{'htmlbody'} = $htmlbody;
    $self->{'plainbody'} = $plainbody;

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->setMailHeader($mailheader, $mailheadervalue);
#
# DESCRIPTION:	This method is used for setting custom email headers.
#
#===============================================================================
sub setMailHeader ($$) {
    my($self)	  	 = shift;
    my($mailheader)	 = shift;
    my($mailheadervalue) = shift;

    $mailheader =~ tr/[a-z]/[A-Z]/;

    $self->{'mailheaders'}->{'OTHERS'}->{$mailheader} = $mailheadervalue;

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->setSMTPPort($smtpport);
#
# DESCRIPTION:	Set the SMTP port.
#
#===============================================================================
sub setSMTPPort ($) {
    my($self)     = shift;
    my($smtpport) = shift;

    $self->{'smtpport'} = $smtpport if $smtpport =~ /^\d+$/;

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->setSMTPServer($smtpserver);
#
# DESCRIPTION:	Set the SMTP server.
#
#===============================================================================
sub setSMTPServer ($) {
    my($self)       = shift;
    my($smtpserver) = shift;

    $smtpserver =~ s/\s*//g;

    $self->{'smtpserver'} = $smtpserver if $smtpserver !~ /^\s*$/;

    return 0;
}

#===============================================================================
#
# METHOD:	$obj->version;
#
# DESCRIPTION:	Get the version of the module.
#
#===============================================================================
sub version () {
    my($self) = shift;

    return $VERSION;
}

#===============================================================================
#
# END of the module.
#
#===============================================================================
package Config::IniFiles;
$Config::IniFiles::VERSION = (qw($Revision: 2.39 $))[1];
require 5.004;
use strict;
use Carp;
use Symbol 'gensym','qualify_to_ref';   # For the 'any data type' hack
@Config::IniFiles::errors = ( );
sub new {
  my $class = shift;
  my %parms = @_;

  my $errs = 0;
  my @groups = ( );

  my $self           = {};
  # Set config file to default value, which is nothing
  $self->{cf}        = undef;
  if( ref($parms{-import}) && ($parms{-import}->isa('Config::IniFiles')) ) {
    # Import from the import object by COPYing, so we
	# don't clobber the old object
    %{$self} = %{$parms{-import}};
  } else {
    $self->{firstload} = 1;
    $self->{default}   = '';
    $self->{imported}  = [];
    if( defined $parms{-import} ) {
      carp "Invalid -import value \"$parms{-import}\" was ignored.";
      delete $parms{-import};
    } # end if
  } # end if
  # Copy the original parameters so we 
  # can use them when we build new sections 
  %{$self->{startup_settings}} = %parms;
  # Parse options
  my($k, $v);
  local $_;
  $self->{nocase} = 0;
  $self->{allowcode} = 1;
  # Handle known parameters first in this order, 
  # because each() could return parameters in any order
  if (defined ($v = delete $parms{'-import'})) {
    # Store the imported object's file parameter for reload
    if( $self->{cf} ) {
        push( @{$self->{imported}}, $self->{cf} );
    } else {
        push( @{$self->{imported}}, "<Un-named file>" );
    } # end if
  }
  if (defined ($v = delete $parms{'-file'})) {
    # Should we be pedantic and check that the file exists?
    # .. no, because now it could be a handle, IO:: object or something else
    $self->{cf} = $v;
  }
  if (defined ($v = delete $parms{'-default'})) {
    $self->{default} = $v;
  }
  if (defined ($v = delete $parms{'-nocase'})) {
    $self->{nocase} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-reloadwarn'})) {
    $self->{reloadwarn} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-allowcontinue'})) {
    $self->{allowcontinue} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-allowcode'})) {
    $self->{allowcode} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-commentchar'})) {
    if(!defined $v || length($v) != 1) {
      carp "Comment character must be unique.";
      $errs++;
    }
    elsif($v =~ /[\[\]=\w]/) {
      # must not be square bracket, equal sign or alphanumeric
      carp "Illegal comment character.";
      $errs++;
    } 
    else {
      $self->{comment_char} = $v;
    }
  }
  if (defined ($v = delete $parms{'-allowedcommentchars'})) {
    # must not be square bracket, equal sign or alphanumeric
    if(!defined $v || $v =~ /[\[\]=\w]/) {
      carp "Illegal value for -allowedcommentchars.";
      $errs++;
    }
    else {
      $self->{comment_char} = $v;
    }
  }
  $self->{comment_char} = '#' unless exists $self->{comment_char};
  $self->{allowed_comment_char} = ';' unless exists $self->{allowed_comment_char};
  # make sure that comment character is always allowed
  $self->{allowed_comment_char} .= $self->{comment_char};

  # Any other parameters are unkown
  while (($k, $v) = each %parms) {
    carp "Unknown named parameter $k=>$v";
    $errs++;
  }

  return undef if $errs;

  bless $self, $class;

  # No config file specified, so everything's okay so far.
  if (not defined $self->{cf}) {
    return $self;
  }
  
  if ($self->ReadConfig) {
    return $self;
  } else {
    return undef;
  }
}
###########################################
#
# eval perl hooks in Inifile values
# GCARLS 04/29/2005
sub eval_if_perl {
###########################################
    my($self, $value) = @_;

    if(my $cref = $self->compile_if_perl($value)) {
        return $cref->();
    }

    return $value;
}

###########################################
#
# compile perl-hooks in Inifile values
# GCARLS 04/29/2005
sub compile_if_perl {
###########################################
    my($self, $value) = @_;

    if(defined $value && $value =~ /^\s*sub\s*{/ ) {
        my $mask;
        unless( $self->{allowcode} ) {
            die "-allowcode => 0 setting " .
                "prohibits Perl code in ini file";
        }
        if( $self->{allowcode} == 1 ) {

            # eval without restriction
            my $cref = eval "package main; $value" or 
                die "Can't evaluate '$value' ($@)";
            return $cref;
        }
        else {
            die "Invalid value for -allowcode in __PACKAGE__ initialisation";
        }
    }

    return undef;
}
sub val {
  my ($self, $sect, $parm, $def) = @_;
  my ($elem, @ary);
  # Always return undef on bad parameters
  return undef if not defined $sect;
  return undef if not defined $parm;
  
  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }
  
  my $val = defined($self->{v}{$sect}{$parm}) ?
    $self->{v}{$sect}{$parm} :
    $self->{v}{$self->{default}}{$parm};
  
  # If the value is undef, make it $def instead (which could just be undef)
  $val = $def unless defined $val;
  
  # Return the value in the desired context
  if (wantarray and ref($val) eq "ARRAY") {
    # GCARLS 04/29/2005
    @ary=@$val; # save original values (probably perl code)
    foreach $elem ( @ary ) {
      $elem=$self->eval_if_perl($elem);
    }
    return @ary;
  } elsif (ref($val) eq "ARRAY") {
  	# GCARLS 04/29/2005:
  	@ary=@$val;
  	foreach $elem ( @ary ) {
           $elem=$self->eval_if_perl($elem);
        }
  	if (defined ($/)) {
	    return join "$/", @ary;
	} else {
	    return join "\n", @ary;
	}
  } else {
    return $self->eval_if_perl($val);
  }
}

sub setval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  my @val  = @_;

  return undef if not defined $sect;
  return undef if not defined $parm;

# tom@ytram.com +
  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }
# tom@ytram.com -

  if (defined($self->{v}{$sect}{$parm})) {
    if (@val > 1) {
      $self->{v}{$sect}{$parm} = \@val;
	  $self->{EOT}{$sect}{$parm} = 'EOT';
    } else {
      $self->{v}{$sect}{$parm} = shift @val;
    }
    return 1;
  } else {
    return undef;
  }
}

sub newval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  my @val  = @_;
  
  return undef if not defined $sect;
  return undef if not defined $parm;

# tom@ytram.com +
  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }
# tom@ytram.com -
	$self->AddSection($sect);

    push(@{$self->{parms}{$sect}}, $parm) 
      unless (grep {/^\Q$parm\E$/} @{$self->{parms}{$sect}} );

  if (@val > 1) {
    $self->{v}{$sect}{$parm} = \@val;
	$self->{EOT}{$sect}{$parm} = 'EOT' unless defined
				$self->{EOT}{$sect}{$parm};
  } else {
    $self->{v}{$sect}{$parm} = shift @val;
  }
  return 1
}

sub delval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  
  return undef if not defined $sect;
  return undef if not defined $parm;

# tom@ytram.com +
  if ($self->{nocase}) {
    $sect = lc($sect);
    $parm = lc($parm);
  }
# tom@ytram.com -

	@{$self->{parms}{$sect}} = grep !/^\Q$parm\E$/, @{$self->{parms}{$sect}};
	delete $self->{v}{$sect}{$parm};
	return 1
}

sub ReadConfig {
  my $self = shift;

  my($lineno, $sect);
  my($group, $groupmem);
  my($parm, $val);
  my @cmts;
  my %loaded_params = ();			# A has to remember which params are loaded vs. imported
  @Config::IniFiles::errors = ( );

  # Initialize (and clear out) storage hashes
  # unless we imported them from another file [JW]
  if( @{$self->{imported}} ) {
      #
      # Run up the import tree to the top, then reload coming
      # back down, maintaining the imported file names and our 
      # file name.
      # This is only needed on a re-load though
      unless( $self->{firstload} ) {
        my $cf = $self->{cf};
        $self->{cf} = pop @{$self->{imported}};
        $self->ReadConfig;
        push @{$self->{imported}}, $self->{cf};
        $self->{cf} = $cf;
      } # end unless
  } else {
      $self->{sects}  = [];		# Sections
      $self->{group}  = {};		# Subsection lists
      $self->{v}      = {};		# Parameter values
      $self->{sCMT}   = {};		# Comments above section
  } # end if
  
  return undef if (
    (not exists $self->{cf}) or
    (not defined $self->{cf}) or
    ($self->{cf} eq '')
  );
  
  my $nocase = $self->{nocase};

  # If this is a reload and we want warnings then send one to the STDERR log
  unless( $self->{firstload} || !$self->{reloadwarn} ) {
    my ($ss, $mm, $hh, $DD, $MM, $YY) = (localtime(time))[0..5];
    printf STDERR
      "PID %d reloading config file %s at %d.%02d.%02d %02d:%02d:%02d\n",
      $$, $self->{cf}, $YY+1900, $MM+1, $DD, $hh, $mm, $ss;
  }
  
  # Turn off. Future loads are reloads
  $self->{firstload} = 0;

  # Get a filehandle, allowing almost any type of 'file' parameter
  my $fh = $self->_make_filehandle( $self->{cf} );
  if (!$fh) {
    carp "Failed to open $self->{cf}: $!";
    return undef;
  }
  
  # Get mod time of file so we can retain it (if not from STDIN)
  my @stats = stat $fh;
  $self->{file_mode} = sprintf("%04o", $stats[2]) if defined $stats[2];
  
  # Get the entire file into memory (let's hope it's small!)
  local $_;
  my @lines = split /\015\012?|\012|\025|\n/, join( '', <$fh>);
  
  # Only close if this is a filename, if it's
  # an open handle, then just roll back to the start
  if( !ref($fh) ) {
    close($fh);
  } else {
    # But we can't roll back STDIN so skip that one
    if( $fh != 0 ) {
      seek( $fh, 0, 0 );
    } # end if
  } # end if

  # If there's a UTF BOM (Byte-Order-Mark) in the first character of the first line
  # then remove it before processing (http://www.unicode.org/unicode/faq/utf_bom.html#22)
  ($lines[0] =~ s/^ï»¿//);
# Disabled the utf8 one for now (JW) because it doesn't work on all perl distros
# e.g. 5.6.1 works with or w/o 'use utf8' 5.6.0 fails w/o it. 5.005_03 
# says "invalid hex value", etc. If anyone has a clue how to make this work 
# please let me know!
#  ($lines[0] =~ s/^ï»¿//) || (eval('use utf8; $lines[0] =~ s/^\x{FEFF}//;'));
#  $@ = ''; $! = undef;  # Clear any error messages

  
  
  # The first lines of the file must be blank, comments or start with [
  my $first = '';
  my $allCmt = $self->{allowed_comment_char};
  foreach ( @lines ) {
    next if /^\s*$/;	# ignore blank lines
    next if /^\s*[$allCmt]/;	# ignore comments
    $first = $_;
    last;
  }
  unless( $first =~ /^\s*\[/ ) {
    return undef;
  }
  
  # Store what our line ending char was for output
  ($self->{line_ends}) = $lines[0] =~ /([\015\012\025\n]+)/;
  while ( @lines ) {
    $_ = shift @lines;

    s/(\015\012?|\012|\025|\n)$//;				# remove line ending char(s)
    $lineno++;
    if (/^\s*$/) {				# ignore blank lines
      next;
    }
    elsif (/^\s*[$allCmt]/) {			# collect comments
      push(@cmts, $_);
      next;
    }
    elsif (/^\s*\[\s*(\S|\S.*\S)\s*\]\s*$/) {		# New Section
      $sect = $1;
      if ($self->{nocase}) {
        $sect = lc($sect);
      }
      $self->AddSection($sect);
      $self->SetSectionComment($sect, @cmts);
      @cmts = ();
    }
    elsif (($parm, $val) = /^\s*([^=]*?[^=\s])\s*=\s*(.*)$/) {	# new parameter
      $parm = lc($parm) if $nocase;
      $self->{pCMT}{$sect}{$parm} = [@cmts];
      @cmts = ( );
      if ($val =~ /^<<(.*)$/) {			# "here" value
	my $eotmark  = $1;
	my $foundeot = 0;
	my $startline = $lineno;
	my @val = ( );
	while ( @lines ) {
	  $_ = shift @lines;
	  s/(\015\012?|\012|\025|\n)$//;				# remove line ending char(s)
	  $lineno++;
	  if ($_ eq $eotmark) {
	    $foundeot = 1;
	    last;
	  } else {
	    push(@val, $_);
	  }
	}
	if ($foundeot) {
	    if (exists $self->{v}{$sect}{$parm} && 
	        exists $loaded_params{$sect} && 
	        grep( /^\Q$parm\E$/, @{$loaded_params{$sect}}) ) {
	      if (ref($self->{v}{$sect}{$parm}) eq "ARRAY") {
	        # Add to the array
	        push @{$self->{v}{$sect}{$parm}}, @val;
	      } else {
	        # Create array
	        my $old_value = $self->{v}{$sect}{$parm};
	        my @new_value = ($old_value, @val);
	        $self->{v}{$sect}{$parm} = \@new_value;
	      }
	    } else {
		$self->{v}{$sect}{$parm} = \@val;
		$loaded_params{$sect} = [] unless $loaded_params{$sect};
		push @{$loaded_params{$sect}}, $parm;
	    }
	    $self->{EOT}{$sect}{$parm} = $eotmark;
	} else {
	  push(@Config::IniFiles::errors, sprintf('%d: %s', $startline,
			      qq#no end marker ("$eotmark") found#));
	}
      } else { # no here value

        # process continuation lines, if any
        while($self->{allowcontinue} && $val =~ s/\\$//) {
          $_ = shift @lines;
	  s/(\015\012?|\012|\025|\n)$//; # remove line ending char(s)
	  $lineno++;
          $val .= $_;
        }

        # Now load value
	if (exists $self->{v}{$sect}{$parm} &&
	    exists $loaded_params{$sect} && 
	    grep( /^\Q$parm\E$/, @{$loaded_params{$sect}}) ) {
	    if (ref($self->{v}{$sect}{$parm}) eq "ARRAY") {
		# Add to the array
		push @{$self->{v}{$sect}{$parm}}, $val;
	    } else {
		# Create array
		my $old_value = $self->{v}{$sect}{$parm};
		my @new_value = ($old_value, $val);
		$self->{v}{$sect}{$parm} = \@new_value;
	    }
	} else {
	    $self->{v}{$sect}{$parm} = $val;
	    $loaded_params{$sect} = [] unless $loaded_params{$sect};
	    push @{$loaded_params{$sect}}, $parm;
	}
      }
      push(@{$self->{parms}{$sect}}, $parm) unless grep(/^\Q$parm\E$/, @{$self->{parms}{$sect}});
    }
    else {
      push(@Config::IniFiles::errors, sprintf("Line \%d in file " . $self->{cf} . " is mal-formed:\n\t\%s", $lineno, $_));
    }
  }

  #
  # Now convert all the parameter hashes into tied hashes.
  # This is in all uses, because it must be part of ReadConfig.
  #
  my %parms = %{$self->{startup_settings}};
  if( defined $parms{-default} ) {
    # If the default section doesn't exists, create it.
    unless( defined $self->{v}{$parms{-default}} ) {
      $self->{v}{$parms{-default}} = {};
      push(@{$self->{sects}}, $parms{-default}) unless (grep /^\Q$parms{-default}\E$/, @{$self->{sects}});
      $self->{parms}{$parms{-default}} = [];
    } # end unless
    $parms{-default} = $self->{v}{$parms{-default}};
  } # end if
  foreach( keys %{$self->{v}} ) {
    $parms{-_current_value} = $self->{v}{$_};
    $parms{-parms} = $self->{parms}{$_};
    $self->{v}{$_} = {};
    # Add a reference to our {parms} hash for each section
    tie %{$self->{v}{$_}}, 'Config::IniFiles::_section', %parms
  } # end foreach

  @Config::IniFiles::errors ? undef : 1;
}

sub Sections {
  my $self = shift;
  return @{$self->{sects}} if ref $self->{sects} eq 'ARRAY';
  return ();
}

sub SectionExists {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	return undef() if not defined $sect;
	return 1 if (grep {/^\Q$sect\E$/} @{$self->{sects}});
	return 0;
}

sub AddSection {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	return if $self->SectionExists($sect);
	push @{$self->{sects}}, $sect;
	$self->SetGroupMember($sect);
	
	# Set up the parameter names and values lists
    $self->{parms}{$sect} = [] unless ref $self->{parms}{$sect} eq 'ARRAY';
	if (!defined($self->{v}{$sect})) {
		$self->{sCMT}{$sect} = [];
		$self->{pCMT}{$sect} = {};		# Comments above parameters
		$self->{parms}{$sect} = [];
		$self->{v}{$sect} = {};
	}
}

sub DeleteSection {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}

	# This is done, the fast way, change if delval changes!!
	delete $self->{v}{$sect};
	delete $self->{sCMT}{$sect};
	delete $self->{pCMT}{$sect};
	delete $self->{EOT}{$sect};
	delete $self->{parms}{$sect};

	@{$self->{sects}} = grep !/^\Q$sect\E$/, @{$self->{sects}};

	if( $sect =~ /^(\S+)\s+\S+/ ) {
		my $group = $1;
		if( defined($self->{group}{$group}) ) {
			@{$self->{group}{$group}} = grep !/^\Q$sect\E$/, @{$self->{group}{$group}};
		} # end if
	} # end if

	return 1;
} # end DeleteSection

sub Parameters {
  my $self = shift;
  my $sect = shift;
  
  return undef if not defined $sect;
  
  if ($self->{nocase}) {
    $sect = lc($sect);
  }
  
  return @{$self->{parms}{$sect}} if ref $self->{parms}{$sect} eq 'ARRAY';
  return ();
}
sub Groups	{
  my $self = shift;
  return keys %{$self->{group}} if ref $self->{group} eq 'HASH';
  return ();
}
sub SetGroupMember {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	return(1) unless $sect =~ /^(\S+)\s+\S+/;
	
	my $group = $1;
	if (not exists($self->{group}{$group})) {
		$self->{group}{$group} = [];
	}
	if (not grep {/^\Q$sect\E$/} @{$self->{group}{$group}}) {
		push @{$self->{group}{$group}}, $sect;
	}
}
sub RemoveGroupMember {
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	return(1) unless $sect =~ /^(\S+)\s+\S+/;
	
	my $group = $1;
	return unless exists $self->{group}{$group};
	@{$self->{group}{$group}} = grep {!/^\Q$sect\E$/} @{$self->{group}{$group}};
}
sub GroupMembers {
  my $self  = shift;
  my $group = shift;
  
  return undef if not defined $group;
  
  if ($self->{nocase}) {
  	$group = lc($group);
  }
  
  return @{$self->{group}{$group}} if ref $self->{group}{$group} eq 'ARRAY';
  return ();
}
sub SetWriteMode
{
	my $self = shift;
	my $mode = shift;
	return undef if not defined ($mode);
	return undef if not ($mode =~ m/[0-7]{3,3}/);
	$self->{file_mode} = $mode;
	return $mode;
}
sub GetWriteMode
{
	my $self = shift;
	return undef if not exists $self->{file_mode};
	return $self->{file_mode};
}
sub WriteConfig {
  my $self = shift;
  my $file = shift;
  
  return undef unless defined $file;
  
  # If we are using a filename, then do mode checks and write to a 
  # temporary file to avoid a race condition
  if( !ref($file) ) {
    if (-e $file) {
          if (not (-w $file))
          {
                  #carp "File $file is not writable.  Refusing to write config";
                  return undef;
          }
          my $mode = (stat $file)[2];
          $self->{file_mode} = sprintf "%04o", ($mode & 0777);
          #carp "Using mode $self->{file_mode} for file $file";
    } elsif (defined($self->{file_mode}) and not (oct($self->{file_mode}) & 0222)) {
          #carp "Store mode $self->{file_mode} prohibits writing config";
    }
  
    my $new_file = $file . "-new";
    local(*F);
    open(F, "> $new_file") || do {
      carp "Unable to write temp config file $new_file: $!";
      return undef;
    };
    my $oldfh = select(F);
    $self->OutputConfig;
    close(F);
    select($oldfh);
    rename( $new_file, $file ) || do {
      carp "Unable to rename temp config file ($new_file) to $file: $!";
      return undef;
    };
    if (exists $self->{file_mode}) {
      chmod oct($self->{file_mode}), $file;
    }
  
  } # Otherwise, reset to the start of the file and write, unless we are using STDIN
  else {
    # Get a filehandle, allowing almost any type of 'file' parameter
    ## NB: If this were a filename, this would fail because _make_file 
    ##     opens a read-only handle, but we have already checked that case
    ##     so re-using the logic is ok [JW/WADG]
    my $fh = $self->_make_filehandle( $file );
    if (!$fh) {
      carp "Could not find a filehandle for the input stream ($file): $!";
      return undef;
    }
    
    
    # Only roll back if it's not STDIN (if it is, Carp)
    if( $fh == 0 ) {
      carp "Cannot write configuration file to STDIN.";
    } else {
      seek( $fh, 0, 0 );
      my $oldfh = select($fh);
      $self->OutputConfig;
      seek( $fh, 0, 0 );
      select($oldfh);
    } # end if

  } # end if (filehandle/name)
  
  return 1;
  
}
sub RewriteConfig {
  my $self = shift;
  
  return undef if (
    (not exists $self->{cf}) or
    (not defined $self->{cf}) or
    ($self->{cf} eq '')
  );
  
  # Return whatever WriteConfig returns :)
  $self->WriteConfig($self->{cf});
}
sub GetFileName
{
	my $self = shift;
	my $filename;
	if (exists $self->{cf}) {
		$filename = $self->{cf};
	} else {
		undef $filename;
	}
	return $filename;
}
sub SetFileName {
  my $self = shift;
  my $newfile = shift;
  
  return undef if not defined $newfile;
  
  if ($newfile ne "") {
    $self->{cf} = $newfile;
    return $self->{cf};
  }
  return undef;
}
sub OutputConfig {
  my $self = shift;

  my($sect, $parm, @cmts);
  my $ors = $self->{line_ends} || $\ || "\n";		# $\ is normally unset, but use input by default
  my $notfirst = 0;
  local $_;
  foreach $sect (@{$self->{sects}}) {
    next unless defined $self->{v}{$sect};
    print $ors if $notfirst;
    $notfirst = 1;
    if ((ref($self->{sCMT}{$sect}) eq 'ARRAY') &&
	(@cmts = @{$self->{sCMT}{$sect}})) {
      foreach (@cmts) {
	print "$_$ors";
      }
    }
    print "[$sect]$ors";
    next unless ref $self->{v}{$sect} eq 'HASH';

    foreach $parm (@{$self->{parms}{$sect}}) {
      if ((ref($self->{pCMT}{$sect}{$parm}) eq 'ARRAY') &&
	  (@cmts = @{$self->{pCMT}{$sect}{$parm}})) {
	foreach (@cmts) {
	  print "$_$ors";
	}
      }

      my $val = $self->{v}{$sect}{$parm};
      next if ! defined ($val);	# No parameter exists !!
      if (ref($val) eq 'ARRAY') {
        my $eotmark = $self->{EOT}{$sect}{$parm} || 'EOT';
	print "$parm= <<$eotmark$ors";
	foreach (@{$val}) {
	  print "$_$ors";
	}
	print "$eotmark$ors";
      } elsif( $val =~ /[$ors]/ ) {
        # The FETCH of a tied hash is never called in 
        # an array context, so generate a EOT multiline
        # entry if the entry looks to be multiline
        my @val = split /[$ors]/, $val;
        if( @val > 1 ) {
          my $eotmark = $self->{EOT}{$sect}{$parm} || 'EOT';
          print "$parm= <<$eotmark$ors";
          print map "$_$ors", @val;
          print "$eotmark$ors";
        } else {
           print "$parm=$val[0]$ors";
        } # end if
      } else {
        print "$parm=$val$ors";
      }
    }
  }
  return 1;
}
sub SetSectionComment
{
	my $self = shift;
	my $sect = shift;
	my @comment = @_;

	return undef if not defined $sect;
	return undef unless @comment;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	$self->{sCMT}{$sect} = [];
	# At this point it's possible to have a comment for a section that
	# doesn't exist. This comment will not get written to the INI file.
	
	push @{$self->{sCMT}{$sect}}, $self->_markup_comments(@comment);
	return scalar @comment;
}



# this helper makes sure that each line is preceded with the correct comment
# character
sub _markup_comments 
{
  my $self = shift;
  my @comment = @_;

  my $allCmt = $self->{allowed_comment_char};
  my $cmtChr = $self->{comment_char};
  foreach (@comment) {
    m/^\s*[$allCmt]/ or ($_ = "$cmtChr $_");
  }
  @comment;
}
sub GetSectionComment
{
	my $self = shift;
	my $sect = shift;

	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	if (exists $self->{sCMT}{$sect}) {
		return @{$self->{sCMT}{$sect}};
	} else {
		return undef;
	}
}
sub DeleteSectionComment
{
	my $self = shift;
	my $sect = shift;
	
	return undef if not defined $sect;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	
	delete $self->{sCMT}{$sect};
}
sub SetParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	my @comment = @_;

	defined($sect) || return undef;
	defined($parm) || return undef;
	@comment || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	}
	
	if (not exists $self->{pCMT}{$sect}) {
		$self->{pCMT}{$sect} = {};
	}
	
	$self->{pCMT}{$sect}{$parm} = [];
	# Note that at this point, it's possible to have a comment for a parameter,
	# without that parameter actually existing in the INI file.
	push @{$self->{pCMT}{$sect}{$parm}}, $self->_markup_comments(@comment);
	return scalar @comment;
}
sub GetParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	
	defined($sect) || return undef;
	defined($parm) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};
	
	exists($self->{pCMT}{$sect}) || return undef;
	exists($self->{pCMT}{$sect}{$parm}) || return undef;
	
	my @comment = @{$self->{pCMT}{$sect}{$parm}};
	return (wantarray)?@comment:join " ", @comment;
}
sub DeleteParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	
	defined($sect) || return undef;
	defined($parm) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};
	
	# If the parameter doesn't exist, our goal has already been achieved
	exists($self->{pCMT}{$sect}) || return 1;
	exists($self->{pCMT}{$sect}{$parm}) || return 1;
	
	delete $self->{pCMT}{$sect}{$parm};
	return 1;
}
sub GetParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;

	defined($sect) || return undef;
	defined($parm) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};

	if (not exists $self->{EOT}{$sect}) {
		$self->{EOT}{$sect} = {};
	}

	if (not exists $self->{EOT}{$sect}{$parm}) {
		return undef;
	}
	return $self->{EOT}{$sect}{$parm};
}
sub SetParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	my $EOT = shift;

	defined($sect) || return undef;
	defined($parm) || return undef;
	defined($EOT) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};

    if (not exists $self->{EOT}{$sect}) {
        $self->{EOT}{$sect} = {};
    }

    $self->{EOT}{$sect}{$parm} = $EOT;
}
sub DeleteParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	
	defined($sect) || return undef;
	defined($parm) || return undef;
	
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	}
	delete $self->{EOT}{$sect}{$parm};
}
sub Delete {
	my $self = shift;
	# Again, done the fast way, if the data structure changes, change this!
	$self->{sects}  = [];
	$self->{parms}  = {};
	$self->{group}  = {};
	$self->{v}      = {};
	$self->{sCMT}   = {};
	$self->{pCMT}   = {};
	$self->{EOT}    = {};
	return 1;
} # end Delete
############################################################
#
# TIEHASH Methods
#
# Description:
# These methods allow you to tie a hash to the 
# Config::IniFiles object. Note that, when tied, the 
# user wants to look at thinks like $ini{sec}{parm}, but the 
# TIEHASH only provides one level of hash interace, so the 
# root object gets asked for a $ini{sec}, which this 
# implements. To further tie the {parm} hash, the internal 
# class Config::IniFiles::_section, is provided, below.
#
############################################################
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub TIEHASH {
  my $class = shift;
  my %parms = @_;
  # Get a new object
  my $self = $class->new( %parms );
  return $self;
} # end TIEHASH
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub FETCH {
  my $self = shift;
  my( $key ) = @_;
  $key = lc($key) if( $self->{nocase} );
  return $self->{v}{$key};
} # end FETCH
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000Jun14 Fixed bug where wrong ref was saved           JW
# 2000Oct09 Fixed possible but in %parms with defaults    JW
# 2001Apr04 Fixed -nocase problem in storing              JW
# ----------------------------------------------------------
sub STORE {
  my $self = shift;
  my( $key, $ref ) = @_;
  return undef unless ref($ref) eq 'HASH';
  $key = lc($key) if( $self->{nocase} );
  # Create a new hash and tie it to a _sections object with the ref's data
  $self->{v}{$key} = {};
  # Store the section name in the list
  push(@{$self->{sects}}, $key) unless (grep {/^\Q$key\E$/} @{$self->{sects}});
  my %parms = %{$self->{startup_settings}};
  $self->{parms}{$key} = [];
  $parms{-parms} = $self->{parms}{$key};
  $parms{-_current_value} = $ref;
  delete $parms{default};
  $parms{-default} = $self->{v}{$parms{-default}} if defined $parms{-default} && defined $self->{v}{$parms{-default}};
  tie %{$self->{v}{$key}}, 'Config::IniFiles::_section', %parms;
} # end STORE
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# 2000Dec17 Now removes comments, groups and EOTs too     JW
# 2001Arp04 Fixed -nocase problem                         JW
# ----------------------------------------------------------
sub DELETE {
  my $self = shift;
  my( $key ) = @_;
  $key = lc($key) if( $self->{nocase} );
  delete $self->{sCMT}{$key};
  delete $self->{pCMT}{$key};
  delete $self->{EOT}{$key};
  delete $self->{parms}{$key};
  if( $key =~ /(\S+)\s+\S+/ ) {
    my $group = $1;
    if( defined($self->{group}{$group}) ) {
      @{$self->{group}{$group}} = grep !/\Q$key\E/, @{$self->{group}{$group}};
    } # end if
  } # end if
  @{$self->{sects}} = grep !/^\Q$key\E$/, @{$self->{sects}};
  return delete( $self->{v}{$key} );
} # end DELETE
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub CLEAR {
  my $self = shift;
  foreach (keys %{$self->{v}}) {
     $self->DELETE( $_ );
  } # end foreach
} # end CLEAR
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub FIRSTKEY {
  my $self = shift;
  my $a = keys %{$self->{v}};
  return each %{$self->{v}};
} # end FIRSTKEY
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub NEXTKEY {
  my $self = shift;
  my( $last ) = @_;
  return each %{$self->{v}};
} # end NEXTKEY
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# 2001Apr04 Fixed -nocase bug and false true bug          JW
# ----------------------------------------------------------
sub EXISTS {
  my $self = shift;
  my( $key ) = @_;
  $key = lc($key) if( $self->{nocase} );
  return exists $self->{v}{$key};
} # end EXISTS
# ----------------------------------------------------------
# DESTROY is used by TIEHASH and the Perl garbage collector,
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000May09 Created method                                JW
# ----------------------------------------------------------
sub DESTROY {
  # my $self = shift;
} # end if
# ----------------------------------------------------------
# Sub: _make_filehandle
#
# Args: $thing
#	$thing	An input source
#
# Description: Takes an input source of a filehandle, 
# filehandle glob, reference to a filehandle glob, IO::File
# object or scalar filename and returns a file handle to 
# read from it with.
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 06Dec2001 Added to support input from any source        JW
# ----------------------------------------------------------
sub _make_filehandle {
  my $self = shift;
  #
  # This code is 'borrowed' from Lincoln D. Stein's GD.pm module
  # with modification for this module. Thanks Lincoln!
  #
  no strict 'refs';
  my $thing = shift;
  return $thing if defined(fileno $thing);
#  return $thing if defined($thing) && ref($thing) && defined(fileno $thing);
  # otherwise try qualifying it into caller's package
  my $fh = qualify_to_ref($thing,caller(1));
  return $fh if defined(fileno $fh);
#  return $fh if defined($thing) && ref($thing) && defined(fileno $fh);
  # otherwise treat it as a file to open
  $fh = gensym;
  open($fh,$thing) || return;
  
  return $fh;
} # end _make_filehandle
############################################################
#
# INTERNAL PACKAGE: Config::IniFiles::_section
#
# Description:
# This package is used to provide a single-level TIEHASH
# interface to the sections in the IniFile. When tied, the 
# user wants to look at thinks like $ini{sec}{parm}, but the 
# TIEHASH only provides one level of hash interace, so the 
# root object gets asked for a $ini{sec} and must return a 
# has reference that accurately covers the '{parm}' part.
#
# This package is only used when tied and is inter-woven 
# between the sections and their parameters when the TIEHASH
# method is called by Perl. It's a very simple implementation
# of a tied hash object with support for the Config::IniFiles
# -nocase and -default options.
#
############################################################
# Date        Modification                            Author
# ----------------------------------------------------------
# 2000.May.09 Created to excapsulate TIEHASH interface    JW
############################################################
package Config::IniFiles::_section;
use strict;
use Carp;
use vars qw( $VERSION );
$Config::IniFiles::_section::VERSION = 2.16;
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::TIEHASH
#
# Args: $class, %parms
#	$class	The class that this is being tied to.
#	%parms   Contains named parameters passed from the 
#           constructor plus thes parameters
#	-_current_value	holds the values to be inserted in the hash.
#	-default	should be a hash ref.
#	-parms  	reference to the $self->{parms}{$sect} of the parent
#
# Description: Builds the object that gets tied to the 
# sections name. Inserts the existing hash, defined in the 
# named parameter '-_current_value' into the tied hash.
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub TIEHASH {
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my %parms = @_;
  # Make a new object
  my $self = {};
  # Put the passed hash into the holder
  $self->{v} = $parms{-_current_value};
  # Get all other the parms, removing leading '-', if any
  # Option checking is already handled in the Config::IniFiles contructor
  foreach( keys %parms ) {
    s/^-//g;
    $self->{$_} = $parms{-$_};
  } # end foreach
  return bless( $self, $class );
} # end TIEHASH
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::FETCH
#
# Args: $key
#	$key	The name of the key whose value to get
#
# Description: Returns the value associated with $key. If
# the value is a hash, returns a hashref, just like normal
# Perl hashes.
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2000Jun15 Fixed bugs in -default handler                JW
# 2000Dec07 Fixed another bug in -deault handler          JW
# 2002Jul04 Returning scalar values (Bug:447532)          AS
# ----------------------------------------------------------
sub FETCH {
  my $self = shift;
  my $key = shift;
  $key = lc($key) if( $self->{nocase} );
  my $val = $self->{v}{$key};
   unless( defined $self->{v}{$key} ) {
    $val = $self->{default}{$key} if ref($self->{default}) eq 'HASH';
  } # end unless
  return $val;
} # end FETCH
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::STORE
#
# Args: $key, @val
#	$key	The key under which to store the value
#	@val	The value to store, either an array or a scalar
#
# Description: Sets the value for the specified $key
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug                             JW
# ----------------------------------------------------------
sub STORE {
  my $self = shift;
  my $key = shift;
  my @val = @_;
  $key = lc($key) if( $self->{nocase} );
  # Add the parameter the the parent's list if it isn't there yet
  push(@{$self->{parms}}, $key) unless (grep /^\Q$key\E$/, @{$self->{parms}});
  if (@val > 1) {
    $self->{v}{$key} = @val;
  } else {
    $self->{v}{$key} = shift @val;
  }
  return $self->{v}{$key};
} # end STORE
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::DELETE
#
# Args: $key
#	$key	The key to remove from the hash
#
# Description: Removes the specified key from the hash
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug                              JW
# ----------------------------------------------------------
sub DELETE   {
  my $self = shift;
  my $key = shift;
  $key = lc($key) if( $self->{nocase} );
#	@{$self->{parms}{$sect}} = grep !/^$parm$/, @{$self->{parms}{$sect}};
  return delete $self->{v}{$key};
} # end DELETE
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::CLEAR
#
# Args: (None)
#
# Description: Empties the entire hash
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub CLEAR    {
  my $self = shift;
  foreach ( keys %{$self->{v}}) {
    $self->DELETE($_);
  } # end foreach
  return $self;
} # end CLEAR
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::EXISTS
#
# Args: $key
#	$key	The key to look for
#
# Description: Returns whether the key exists
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug                             JW
# ----------------------------------------------------------
sub EXISTS   {
  my $self = shift;
  my $key = shift;
  $key = lc($key) if( $self->{nocase} );
  return exists $self->{v}{$key};
} # end EXISTS
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::FIRSTKEY
#
# Args: (None)
#
# Description: Returns the first key in the hash
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub FIRSTKEY {
  my $self = shift;
  # Reset the each() iterator
  my $a = keys %{$self->{v}};
  return each %{$self->{v}};
} # end FIRST KEY
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::NEXTKEY
#
# Args: $last
#	$last	The last key accessed by the interator
#
# Description: Returns the next key in line
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub NEXTKEY  {
  my $self = shift;
  my $last = shift;
  return each %{$self->{v}};
} # end NEXTKEY
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::DESTROY
#
# Args: (None)
#
# Description: Called on cleanup
# ----------------------------------------------------------
# Date      Modification                              Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub DESTROY  {
  # my $self = shift
} # end DESTROY
# Eliminate annoying warnings
if ($^W)	{
	$Config::IniFiles::VERSION = $Config::IniFiles::VERSION;
};
1;
