#! /usr/bin/perl --
# bck-backup.
# Written & parts copyright by : Bruno Veldeman
#
# To simplify use, some modified modules have been copied into the code, this way no extra modules have to be installed.
# I'll check these modules from time to time to ensure they stay more or less up to date. (Sendmail.pm, Config::Inifiles)
#
#################################################################################
#										#
#   This program is free software: you can redistribute it and/or modify	#
#   it under the terms of the GNU General Public License as published by	#
#   the Free Software Foundation, either version 3 of the License, or		#
#   (at your option) any later version.						#
#										#
#   This program is distributed in the hope that it will be useful,		#
#   but WITHOUT ANY WARRANTY; without even the implied warranty or		#
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		#
#   GNU General Public License for more details.				#
#										#
#   You should have received a copy of the GNU General Public License		#
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.	#
#										#
#################################################################################
#
#
use warnings;
use strict;
use English;
use Config;
# Program version
my( $version ) = "2.2.0";
# Exit state variable
my( $state ) = 0;
# Evaluate the command line parameters
my $cmdln =  eval { new CommandLine(); }  or die ($@);
$cmdln->ParseCommandLine();
# Look for flags
if ( $cmdln->GetHelpFlag )
{
	&PrintHelp;
	exit(0);
};
if ( $cmdln->GetVersionFlag )
{
	&PrintVersion;
	exit(0);
};
if ( $cmdln->GetCheckFlag )
{
	&CheckConfig( $cmdln->GetConfigFileName );
	exit(0);
};
if ( $cmdln->GetInstallFlag )
{
	&CreateConfig( $cmdln->GetConfigFileName );
	exit(0);
};
if ( $cmdln->GetUpdateFlag )
{
	&Update( $cmdln->GetConfigFileName );
	exit(0);
};

#Load global section
my $gsection = eval { new GlobalSection(); } or die ($@);
if ( $cmdln->GetHttpFlag )
{
	my $web = new HttpServer();
	$web->SetConfigfile( $cmdln->GetConfigFileName );
	$web->Start( $cmdln->GetHttpFlag );
	exit(0);
};
if ( defined $cmdln->GetDo() )
{
	$state = &Main;
};
if ( $cmdln->GetReportFlag )
{
	CommReports();
};
if ( $cmdln->GetMailFlag )
{
	MailReports();
};
exit($state);
#
##################################################################################
#
# Sub Main
#
##################################################################################
sub Main # () -> ()
{
	my ( $cfg ) = undef;
	my ( $lang ) = undef;
	my ( $publicip, $line );
	my ( $logdate ) = GetLogDate();
	my $starttime = time();
	my ( @logfiles );
	my ( @filelist );
	my ( $globalstatus ) = 0;
	my ( $configfilename ) = $cmdln->GetConfigFileName;
	if ( -e $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
	};
	if ( defined $cfg)
	{
		$publicip = &GetIP( $gsection->GetIpWebAddress() );
		my ( @dolist ) = split(/,/,$cmdln->GetDo());
		my ( $seconds );
		my ( $entry );
		foreach $entry (@dolist)
		{
			my $section = eval { new DoSection(); } or die ($@);
			$section->SetSection( $entry );
			$section->SetLogDate( $logdate );
			$section->SetDebug( $cmdln->GetDebugFlag() );
			$section->SetVerbose( $cmdln->GetVerboseFlag() );
			$section->WriteLog( "START ************ bck version " . $version . " *************", 1 );
			$section->WriteLog( "Start time : local : " . &GetTime() . " ntp : " . &GetNtpTime( $gsection->GetNtpServer() ) , 1 ) ;
			$section->WriteLog( "Running on : " . $Config{'osname'} . " / " . $Config{'osvers'} . " [" . $Config{'archname'} . "] , Perl version : v" . $Config{'PERL_REVISION'} . "." . $Config{'PERL_VERSION'} . "." . $Config{'PERL_SUBVERSION'} , 1 );
			$section->WriteLog( "Client : " . $gsection->GetClient() . " / Public IP Address : $publicip", 1 );
			if ( $section->LoadSection( $cmdln->GetConfigFileName() ) == 0 )
			{
				if ( $section->CalcSize() == 0 )
				{
					my ( $status ) = $section->Backup();
					if ( $status == 0 )
					{
						#section ok
						$section->WriteLog( "Section [" . $section->{_section} . "]  (" . &HumanBytes( $section->GetSize() )  . " ) ok." , 1);
						$section->WriteTable();
					}
					else
					{
						#section not ok
						$section->WriteLog( "Section [" . $section->{_section} . "]  (" . &HumanBytes( $section->{_size} ) . ") errors/warnings." , 1);
						$section->WriteTable();
					};
				}
				else
				{
					#section size larger then maxsize
					$section->WriteLog( "Section [" . $section->{_section} . "] size (" . &HumanBytes( $section->{_size} ) . ") larger then maxsize (" . &HumanBytes( $section->{_maxsize} ) . ")." , 1);
					$section->WriteTable();
				};
			}
			else
			{
				#section does not exist
				$section->WriteLog( "Section [" . $section->{_section} . "] does not exist." , 1);
				$section->WriteTable();
			};
			$section->WriteLog( "End time : " . &GetTime() , 1 );
			$seconds = (time() - $starttime);
			my ( $timestr ) =  sprintf("%02d:%02d:%02d", ($seconds/(60*60))%24 , ($seconds/60)%60 ,  $seconds%60 );
			$section->WriteLog( "Total time elapsed (hh:mm:ss): " . $timestr , 1 );
			$section->WriteLog( "END   ************ bck version " . $version . " *************", 1 );
		};
	}
	else
	{
		#Configuration file error
	};
	return(0);
};
##################################################################################
#
# Sub MailReports :
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub MailReports
{
	my ( $cfg ) = undef;
	my ( $lang ) = undef;
	my ( $publicip);
	my ( $logdate ) = GetLogDate();
	my $starttime = time();
	$publicip = &GetIP( $gsection->GetIpWebAddress() );
	my ( $configfilename ) = $cmdln->GetConfigFileName;
	if ( -e $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
	};
	if ( defined $cfg)
	{
		my ( $statusfile ) = $cmdln->GetStatusFileName;
		my ( $report ) = Report->new();
		$report->SetTittle( "Backup report." );
		$report->SetIP( $publicip );
		my ( @mails ) = $cfg->Parameters( "mail" );
		my ( $mail );
		foreach $mail ( @mails )
		{
			my ( $maillvl, $mailmode ) = split( /,/, $cfg->val( "mail", $mail ) );
			if ( not defined $mailmode )
			{
				$mailmode = "html and plain";
			};
		$report->AddMail( $mail, $maillvl, $mailmode );
		};
		my ( $line, $date );
		my ( $reportstatus ) = 0;
		my ( $table ) = TableFile->new();
		$table->SetFile( $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' );
		# Get an array with lines that have the mail bit set to 0, mailbit = 0
		my ( @lines ) = $table->FindLines( 0, 0 );
		foreach $line ( @lines )
		{
			chomp( $line );
			# Clean up the line
			$line = StrCl( $line );
			my ( $id, $statusbits, $section, $name, $timestamp, $stat, $size, $destsize, $destfree ) = split( /,/,$line );
			# Check values in table file
			if ( !defined $section ) { $section = 0 };
			if ( !defined $name ) { $name = 0 };
			if ( !defined $timestamp ) { $timestamp = 0 };
			if ( !defined $stat ) { $stat = 0 };
			if ( !defined $size ) { $size = 0 };
			if ( !defined $destsize ) { $destsize = 0 };
			if ( !defined $destfree ) { $destfree = 0 };
			# End check values
			if ( $stat eq "Warning" )
			{
				if ( $reportstatus < 1 )
				{
					$reportstatus = 1;
				};
			}
			elsif ( $stat eq "ERROR" )
			{
				$reportstatus = 2;
			};
			$report->AddTable( $section, $name, $timestamp, $stat, $size, $destsize, $destfree );
		};
		$report->SetState( $reportstatus );
		my ( $mailstatus ) = $report->SendReports();
		if ( $mailstatus == 0 )
		{
			# Update statusbit for mail at position "0" to "1", pass the array as reference.
			$table->UpdateStatusBits( 0, 1, \@lines );
		};
		return(0);
	};
};
##################################################################################
#
# Sub CommReports :
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub CommReports # () -> ()
{
	use Socket;
	my ( $response, $myip );
	my ( $peer, $address );
	my ( $cfg ) = undef;
	my ( $lang ) = undef;
	my ( $publicip);
	my ( $logdate ) = GetLogDate();
	my $starttime = time();
	my ( $rsection ) = ReportSection->new();
	$publicip = &GetIP( $gsection->GetIpWebAddress() );
	my ( $configfilename ) = $cmdln->GetConfigFileName;
	if ( -e $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
	};
	if ( defined $cfg)
	{
		my ( $statusfile ) = $cmdln->GetStatusFileName;
		my ( $date );
		my ( $reportstatus ) = 0;
		my ( $table ) = TableFile->new();
		$table->SetFile( $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' );
		# Get an array with lines that have the report bit set to 0, reportbit = 1
		my ( @lines ) = $table->FindLines( 1, 0 );
		my ( $numlines ) = scalar @lines;
		foreach my $line ( @lines )
		{
			chomp( $line );
			# Clean up the line
			$line = StrCl( $line );
			my ( $id, $mailed, $section, $name, $timestamp, $stat, $size, $destsize, $destfree ) = split( /,/,$line );
			# check values in table file
			if ( !defined $section ) { $section = 0 };
			if ( !defined $name ) { $name = 0 };
			if ( !defined $timestamp ) { $timestamp = 0 };
			if ( !defined $stat ) { $stat = 0 };
			if ( !defined $size ) { $size = 0 };
			if ( !defined $destsize ) { $destsize = 0 };
			if ( !defined $destfree ) { $destfree = 0 };
			$size = NumCl( $size );
			$destsize = NumCl( $destsize );
			$destfree = NumCl( $destfree );
			if ( $stat eq "Warning" )
			{
				if ( $reportstatus < 1 )
				{
					$reportstatus = 1;
				};
			}
			elsif ( $stat eq "ERROR" )
			{
				$reportstatus = 2;
			};
		};
		my ( $password ) = $rsection->GetPassword();
		my ( $host ) = $rsection->GetServer();
		my ( $port ) = $rsection->GetPort;
		$address = inet_aton( $host );
		if ( not defined $address )
		{
			return(0);
		}
		else
		{
			$peer = sockaddr_in( $port, $address );
			socket( S, PF_INET, SOCK_STREAM, getprotobyname('tcp') ) or die "Socket: $!";
			connect( S, $peer ) or die "Connect: $!";
			select ( S );
			$|=1;
			print S "bck . .\n";
			select ( STDOUT );
			{
				while ( sysread( S, my $buff, 1 ) )
				{
					last if ( $buff eq "\n" );
					$response .= $buff;
				};
				# Get the seed to create the password
				# Skip the first 3 chars as this is bck
				my ( $seed ) = StrCl( substr( $response, 3 ) );
				my  ( $auth ) = crypt( $password, $seed );
				select ( S );
				print S "bck$auth\n";
				foreach my $line ( @lines )
				{
					my ( $id, $statusbits, $section, $name, $timestamp, $stat, $size, $destsize, $destfree ) = split( /,/,$line );
					my ( $repline ) = $statusbits . "," . $section . "," . $name . "," . $timestamp . "," . $stat . "," . $size . "," . $destsize . "," . $destfree;
					print S "$repline\n";
				};
				my ( $statusbits ) = 132 | ( $reportstatus << 3 );
				my ( $headerline ) = "$statusbits," . $publicip . "," . $gsection->GetClient() . "," . time . ",Remote,0,0,0";
				print S "$headerline\n";
				print S "bck/END/\n";
				$response = "";
				while ( sysread( S, my $buff, 1 ) )
				{
					last if ( $buff eq "\n" );
					$response .= $buff;
				};
				close S;
				select ( STDOUT );
				chomp( $response );
				$response = StrCl( $response );
			};
		};
		if ( ( $response ne "bck00" ) and ( $response ne "" ) )
		{
			# Update statusbit for comm at position "1" to "1", pass the array as reference.
			$table->UpdateStatusBits( 1, 1, \@lines );
		};
		return(0);
	};
};
##################################################################################
#
# Sub GetIP :
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub GetIP # (webaddress) -> (myip)
{
	use Socket;
	my ( $webaddress ) = @_;
	my ( $response, $myip );
	my ( $peer, $address );
	# Return empty IP string if no webaddress is passed
	return ("---.---.---.---") unless $webaddress;
	# Clean up the $webaddress string
	$webaddress =~ s/[^\w\.-\/]//g;
	my ( $host , $page ) = split( /\//, $webaddress, 2 );
	$page = "" unless $page;
	$address = inet_aton( $host );
	
	if ( not defined $address )
	{
		$myip = "Cannot connect!";
	}
	else
	{
		$peer = sockaddr_in( 80, $address );
		socket( S, PF_INET, SOCK_STREAM, getprotobyname('tcp') );
		connect( S, $peer );
		select(S);
		$|=1;
		print S "GET /$page HTTP/1.1\r\n";
		print S "Host: $host\r\n";
		print S "Accept: text/html\r\n";
		print S "Connection: close\r\n\r\n";
		select STDOUT;
		{
			while ( defined ( my $line = <S> )  )
				{
				chomp($line);
				$response .= $line;
				}
			close S;
		};
		$response =~ m/([\d]+\.[\d]+\.[\d]+\.[\d]+)/;
		if (defined ( $1 ) )
			{
			$myip = $1;
		}
		else
		{
		$myip = "---.---.---.---";
		};
	};
	return ($myip);
};
##################################################################################
#
# Sub HumanBytes :
# 
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub HumanBytes
{
	my ( $bytes ) = @_;
	my ( $output );
	#byte	  B
	#kilobyte  K = 2**10 B = 1024 B
	#megabyte  M = 2**20 B = 1024 * 1024 B
	#gigabyte  G = 2**30 B = 1024 * 1024 * 1024 B
	#terabyte  T = 2**40 B = 1024 * 1024 * 1024 * 1024 B
	#petabyte  P = 2**50 B = 1024 * 1024 * 1024 * 1024 * 1024 B
	#exabyte   E = 2**60 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
	#zettabyte Z = 2**70 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
	#yottabyte Y = 2**80 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
	if ( defined $bytes and ( $bytes != 0 ) )
	{
		if ( $bytes > ( 2 ** 80 ) )
		{
			$output = sprintf("%.2f YB",( $bytes / ( 2 ** 80 ) ) );
		}
		elsif ( $bytes > ( 2 ** 70) )
		{
			$output = sprintf("%.2f ZB",( $bytes / ( 2 ** 70 ) ) );
		}
		elsif ( $bytes > ( 2 ** 60) )
		{
			$output = sprintf("%.2f EB",( $bytes / ( 2 ** 60 ) ) );
		}
		elsif ( $bytes > ( 2 ** 50) )
		{
			$output = sprintf("%.2f PB",( $bytes / ( 2 ** 50 ) ) );
		}
		elsif ( $bytes > ( 2 ** 40) )
		{
			$output = sprintf("%.2f TB",( $bytes / ( 2 ** 40 ) ) );
		}
		elsif ( $bytes > ( 2 ** 30) )
		{
			$output = sprintf("%.2f GB",( $bytes / ( 2 ** 30 ) ) );
		}
		elsif ( $bytes > ( 2 ** 20) )
		{
			$output = sprintf("%.2f MB",( $bytes / ( 2 ** 20 ) ) );
		}
		elsif ( $bytes > ( 2 ** 10) )
		{
			$output = sprintf("%.2f KB",( $bytes / ( 2 ** 10 ) ) );
		}
		else
		{
			$output = sprintf("%.0f B",( $bytes ) );
		};
	}
	else
	{
		$output = "-"
	};
	return( $output );
};
##################################################################################
#
# Sub StrCl : Check a string so it is valid input. Only let alfanum and a few 
#             harmless chars through, if undefined, return a space so things won't
#             break
#
##################################################################################
sub StrCl # ( string ) -> ( clean string )
{
	my ( $string ) = shift;
	# If undefined, make it one space.
	$string = " " unless $string;
	# Remove al chars exept a-z 0-9 A-Z , . _ - : ; and space
	$string =~ s/[^\w\,\.-:;\s]//g;
	return ( $string );
};
##################################################################################
#
# Sub NumCl : Check a number so it is valid input. Only let numbers through, if 
#             undefined, return a 0 so things won't break
#
##################################################################################
sub NumCl # ( num ) -> ( clean num )
{
	my ( $num ) = shift;
	# If undefined, make it 0
	$num = 0 unless $num;
	# Remove al chars exept 0-9
	$num =~ s/[^\d]//g;
	# If we end up with an empty value, make it 0
	$num = 0 unless ( $num ne "" );
	return ( $num );
};
##################################################################################
#
# Sub NumNz : Check a number so it is valid input. Only let numbers through, if 
#             undefined or 0, return a 1 so things won't break
#
##################################################################################
sub NumNz # ( num ) -> ( clean num )
{
	my ( $num ) = shift;
	# If undefined, make it 0
	$num = 1 unless $num;
	# Remove al chars exept 0-9
	$num =~ s/[^\d]//g;
	# If we end up with an empty value, make it 0
	$num = 0 unless ( $num ne "" );
	$num = 1 unless ( $num ne 0  );
	return ( $num );
};
##################################################################################
#
# Sub GetTime :
#
##################################################################################
sub GetTime # () -> (mytime)
{
	my ($mytime);
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	$mytime = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . sprintf( "%02d:%02d:%02d" , $hour, $min, $sec ) . " (" . ($wday) . ")";
	return ($mytime);
};
##################################################################################
#
# Sub GetNtpTime : Get time from time server
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub GetNtpTime # (ntpservername) -> (mytime)
{
	use Socket;
	my ( $ntpserver, $ntpport ) = @_;
	my ( $mytime, $buflen, $sndmsg, $ttime ,$ipaddr, $portaddr, @response );
	# If no server name or address is passed, return emty time string
	return ( "-/-/---- --:--:-- (-)" ) unless $ntpserver;
	$ntpserver = StrCl( $ntpserver );
	# If no port is given, we use the standard port.
	$ntpport = 123 unless $ntpport;
	# Clean up the number
	$ntpport = NumCl( $ntpport );
	$buflen = 1024;
	my ( $retry ) = 3;
	my ( $timeout ) = 3;
	while ( $retry gt 0 )
	{
		eval
		{
			local $SIG{ALRM} = sub { die print "timeout" };
			$retry--;
			alarm( $timeout );
			socket( SOCKET, PF_INET, SOCK_DGRAM, getprotobyname( "udp" ) );
			$ipaddr = inet_aton( $ntpserver );
			if ( defined $ipaddr )
			{
				$portaddr = sockaddr_in( $ntpport, $ipaddr );
				# We send a message
				$sndmsg="\010"."\0"x47;
				send(SOCKET, $sndmsg, 0, $portaddr);
				$portaddr = recv(SOCKET, $sndmsg, $buflen, 0);
				# We receive the time message
				@response = unpack("N12",$sndmsg);
				$ttime = $response[10];
				# Since ntp starts counting on 1/1/1900 and unix starts on 1/1/1970, we substract the seconds needed.
				$ttime -= ( ( 1970 - 1900 ) * ( 365 * 24 * 60 * 60 ) + ( int ( ( 1970 - 1900 ) / 4 ) * 24 * 60 * 60 ) );
				# Now we put it in a human readable format.
				my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( $ttime );
				$mytime = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . sprintf( "%02d:%02d:%02d" , $hour, $min, $sec ) . " (" . ($wday) . ")";
			};
			alarm(0);
		};
		last;
	};
	if ( $@ )
	{
		return ( "-/-/---- --:--:-- (-)" );
	}
	else
	{
		return ($mytime);
	};
};
##################################################################################
#
# Sub GetLogDate : Date/time format for log files
#
##################################################################################
sub GetLogDate # () -> (mydate)
{
	my ( $mytime );
	$mytime = time;
	return ( $mytime );
};
##################################################################################
#
# Sub CheckConfig :
#
##################################################################################
sub CheckConfig # ($configfilename) -> ()
{
	use File::Path;
	my ( $configfilename ) = @_;
	my ( $line, $testmail );
	$testmail = 0;
	use Socket;
	use MIME::Base64;
	print "bck version : $version\n";
	print "   Checking configuration file...\n";
	if (-r $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
		unless ($cfg)
		{
			print "   Error in loading configuration file `$configfilename'\n";
			foreach $line ( @Config::IniFiles::errors )
			{
			print "	  $line .\n";
			};
		}
		else
		{
			print "   Configuration file structure OK.\n";
			print "   Checking configuration.\n";
			print "   Global variables :\n";
			my ($lang)		= $cfg->val('global', 'lang');
			my ($client)		= $cfg->val('global', 'client');
			my ($sysloglevel)	= $cfg->val('global', 'sysloglevel');
			my ($winmsg)		= $cfg->val('global', 'winmsg');
			my ($mt)		= $cfg->val('global', 'mt');
			my ($tar)		= $cfg->val('global', 'tar');
			my ($smbmount)	= $cfg->val('global', 'smbmount');
			my ($smbumount)	= $cfg->val('global', 'smbumount');
			my ($smbclient)	= $cfg->val('global', 'smbclient');
			my ($sudo)		= $cfg->val('global', 'sudo');
			my ($rsync)		= $cfg->val('global', 'rsync');
			my ($dvdrecord)	= $cfg->val('global', 'dvdrecord');
			my ($dvdformat)	= $cfg->val('global', 'dvdformat');
			my ($cdrecord)	= $cfg->val('global', 'cdrecord');
			my ($rsyncrypto)	= $cfg->val('global', 'rsyncrypto');
			my ($smtpserver)	= $cfg->val('global', 'smtpserver');
			my ($smtpuser)	= $cfg->val('global', 'smtpuser');
			my ($smtppass)	= $cfg->val('global', 'smtppass');
			my ($smtpfrom)	= $cfg->val('global', 'smtpfrom');
			my ($smtpport)	= $cfg->val('global', 'smtpport');
			my ($ntpserver)	= $cfg->val('global', 'ntpserver');
			my ($ipwebaddress)	= $cfg->val('global', 'ipwebaddress');
			my ($logdir)	= $cfg->val('global', 'logdir');
			my ($spooldir)	= $cfg->val('global', 'spooldir');
			my ($tempdir)	= $cfg->val('global', 'tempdir');
			my ($oktag)		= $cfg->val('global', 'oktag');
			my ($errortag)	= $cfg->val('global', 'errortag');
			my ($warningtag)= $cfg->val('global', 'warningtag');
			# Tests
			if ( defined $lang)
			{
				print "	 lang ok.\n";
			}
			else
			{
				print "	#lang not defined\n";
			};
			if ( defined $client)
			{
				print "	 client ok.\n";
			}
			else
			{
				print "	#client not defined\n";
			};
			if ( defined $sysloglevel)
			{
				if ( ($sysloglevel >= 0) and ($sysloglevel <= 5) )
				{
					print "	 sysloglevel ok.\n";
				}
				else
				{
					print "	#sysloglevel out of range\n";
				}
			}
			else
			{
				print "	#sysloglevel not defined\n";
			};
			if ( defined $winmsg)
			{
				if ( ($winmsg eq "yes") or ($winmsg eq "no") )
				{
					print "	 winmsg ok.\n";
				}
				else
				{
					print "	#winmsg out of range\n";
				}
			}
			else
			{
				print "	#winmsg not defined\n";
			};
			if ( defined $mt)
			{
				if ( -x ($mt) )
				{
					print "	 mt ok.\n";
				}
				else
				{
					print "	#mt path/permission error\n";
				}
			}
			else
			{
				print "	#mt not defined\n";
			};
			if ( defined $tar )
			{
				if ( -x ($tar) )
				{
					print "	 tar ok.\n";
				}
				else
				{
					print "	#tar path/permission error\n";
				}
			}
			else
			{
				print "	#tar not defined\n";
			};
			if ( defined $smbmount )
			{
				if ( -x ($smbmount) )
				{
					print "	 smbmount ok.\n";
				}
				else
				{
				print "	#smbmount path/permission error\n";
				}
			}
			else
			{
				print "	#smbmount not defined\n";
			};
			if ( defined $smbumount )
			{
				if ( -x ($smbumount) )
				{
					print "	 smbumount ok.\n";
				}
				else
				{
					print "	#smbumount path/permission error\n";
				}
			}
			else
			{
				print "	#smbumount not defined\n";
			};
			if ( defined $smbclient )
			{
				if ( -x ($smbclient) )
				{
					print "	 smbclient ok.\n";
				}
				else
				{
					print "	#smbclient path/permission error\n";
				}
			}
			else
			{
				print "	#smbclient not defined\n";
			};
			if ( defined $sudo)
			{
				if ( -x ($sudo) )
				{
					print "	 sudo ok.\n";
				}
				else
				{
					print "	#sudo path/permission error\n";
				}
			}
			else
			{
				print "	#sudo not defined\n";
			};
			if ( defined $rsync )
			{
				if ( -x ($rsync) )
				{
					print "	 rsync ok.\n";
				}
				else
				{
					print "	#rsync path/permission error\n";
				}
			}
			else
			{
				print "	#rsync not defined\n";
			};
			if ( defined $cdrecord )
			{
				if ( -x ($cdrecord) )
				{
					print "	 cdrecord ok.\n";
				}
				else
				{
					print "	#cdrecord path/permission error\n";
				}
			}
			else
			{
				print "	#cdrecord not defined\n";
			};
			if ( defined $dvdrecord )
			{
				if ( -x ($dvdrecord) )
				{
					print "	 dvdrecord ok.\n";
				}
				else
				{
					print "	#dvdrecord path/permission error\n";
				}
			}
			else
			{
				print "	#dvdrecord not defined\n";
			};
			if ( defined $dvdformat )
			{
				if ( -x ($dvdformat) )
				{
					print "	 dvdformat ok.\n";
				}
				else
				{
					print "	#dvdformat path/permission error\n";
				}
			}
			else
			{
				print "	#dvdformat not defined\n";
			};
			if ( defined $rsyncrypto )
			{
				if ( -x ($rsyncrypto) )
				{
					print "	 rsyncrypto ok.\n";
				}
				else
				{
					print "	#rsyncrypto path/permission error\n";
				}
			}
			else
			{
				print "	#rsyncrypto not defined\n";
			};
			if ( defined $smtpserver )
			{
				print "	 smtpserver ok.\n";
			}
			else
			{
				print "	#smtpserver not defined\n";
			};
			if ( defined $smtpport)
			{
				my ( $iaddr, $paddr, $proto, $timeout );
				$timeout = 3;
				$testmail = 0;
				if ( defined ($smtpserver) )
				{
					print "	 smtpport ok.\n	 -testing connection.\n";
					if ( $iaddr  = inet_aton($smtpserver) )
					{
						#It worked
						$paddr = sockaddr_in($smtpport, $iaddr);
						$proto = getprotobyname('tcp');
						if ( socket(SOCK, PF_INET, SOCK_STREAM, $proto) )
						{
							#It worked
							eval {
							  local $SIG{ALRM} = sub { die "timeout" };
							  alarm($timeout);
							  connect(SOCK, $paddr) || error();
							  alarm(0);
							};
							if ($@) {
							  close SOCK || die "close: $!";
							  print "	#--$smtpserver is NOT listening on tcp port $smtpport.\n";
							}
							else {
							  close SOCK || die "close: $!";
							  print "	 --$smtpserver is listening on tcp port $smtpport.\n";
							  $testmail = 1;
							}
						}
						else
						{
							print "	Socket error: $!.\n";
						};
					}
					else
					{
						print "	host $smtpserver not responding, check your config file.\n";
					};
				}
				else
				{
					print "	 smtpport ok.\n";
				};
			}
			else
			{
				print "	#smtpport not defined\n";
			};
			if ( defined $smtpuser )
			{
				print "	 smtpuser ok.\n";
			}
			else
			{
				print "	#smtpuser not defined\n";
			};
			if ( defined $smtppass)
			{
				if ( ( defined $smtpuser) and ( $testmail == 1 ) )
				{
					print "	 smtppass ok.\n	 -testing smtp authentication.\n";
					my($iaddr, $paddr, $proto, $mailaddr, $_LOCALHOST, $failed ) = undef;
					require Sys::Hostname;
					$_LOCALHOST = Sys::Hostname::hostname();
					$mailaddr = getEmailAddress( $smtpfrom );
					$failed = 0;
					#
					# Please refer to Socket module manual. (perldoc Socket)
					#
					$iaddr = inet_aton($smtpserver);
					$paddr = sockaddr_in($smtpport, $iaddr);
					$proto = getprotobyname('tcp');
					socket(SOCK, PF_INET, SOCK_STREAM, $proto);
					connect(SOCK, $paddr);
					
					receiveFromServer(\*SOCK);
					sendToServer(\*SOCK, "EHLO $_LOCALHOST");
					if ( receiveFromServer(\*SOCK) != 0 )
					{
						sendToServer(\*SOCK, "HELO $_LOCALHOST");
						receiveFromServer(\*SOCK);
					}
					#
					# Start authentication test.
					#
					$failed = 1 if sendToServer(\*SOCK, "AUTH LOGIN");
					$failed = 1 if receiveFromServer(\*SOCK) != 0;
					$failed = 1 if sendToServer(\*SOCK, encode_base64($smtpuser, "")) != 0;
					$failed = 1 if receiveFromServer(\*SOCK) != 0;
					$failed = 1 if sendToServer(\*SOCK, encode_base64($smtppass, "")) != 0;
					$failed = 1 if receiveFromServer(\*SOCK) != 0;
					$failed = 1 if sendToServer(\*SOCK, "QUIT") != 0;
					$failed = 1 if receiveFromServer(\*SOCK) != 0;
					eof(SOCK) || close(SOCK);
					if ( $failed eq 1 )
					{
						print "	#--smtp authentication failed.\n";
					}
					else
					{
						print "	 --smtp authentication ok.\n";
					};
				}
				else
				{
					print "	 smtppass ok.\n";
				};
			}
			else
			{
				print "	#smtppass not defined\n";
			};
			if ( defined $smtpfrom)
			{
				print "	 smtpfrom ok.\n";
			}
			else
			{
				print "	#smtpfrom not defined\n";
			};
			if ( defined $ntpserver)
			{
				print "	 ntpserver ok.\n";
				print "	 -testing connection\n";
				print "	 --" . GetNtpTime( $ntpserver ) . " returned by server\n"
			}
			else
			{
				print "	#ntpserver not defined\n";
			};
			if ( defined $ipwebaddress)
			{
				print "	 ipwebaddress ok.\n";
			}
			else
			{
				print "	#ipwebaddress not defined\n";
			};
			if ( defined $logdir )
			{
				if ( -d $logdir )
				{
					print "	 logdir ok.\n";
				}
				else
				{
					if ( mkpath($logdir) )
					{
						print "	+logdir created\n";
					}
					else
					{
						print "	#logdir does not exist\n";
					};
				};
			}
			else
			{
				print "	#logdir not defined\n";
			};
			if ( defined $spooldir )
			{
				if ( -d $spooldir )
				{
					print "	 spooldir ok.\n";
				}
				else
				{
					if ( mkpath($spooldir) )
					{
						print "	+spooldir created\n";
					}
					else
					{
						print "	#spooldir does not exist\n";
					};
				};
			}
			else
			{
				print "	#spooldir not defined\n";
			};
			if ( defined $tempdir )
			{
				if ( -d $tempdir )
				{
					print "	 tempdir ok.\n";
				}
				else
				{
					print "	#tempdir does not exist\n";
				};
			}
			else
			{
				print "	#tempdir not defined\n";
			};
			if ( defined $oktag)
			{
				print "	 oktag ok.\n";
			}
			else
			{
				print "	#oktag not defined\n";
			};
			if ( defined $errortag)
			{
				print "	 errortag ok.\n";
			}
			else
			{
				print "	#errortag not defined\n";
			};
			if ( defined $warningtag)
			{
				print "	 warningtag ok.\n";
			}
			else
			{
				print "	#warningtag not defined\n";
			};
		};
	};
	return (0);
};
##################################################################################
#
# Mail send test routines
#
##################################################################################
##################################################################################
#
# receiveFromServer : Receive data from server on socket connection.
#
##################################################################################
sub receiveFromServer # ( $socket ) -> ( $reply )
{
	my($socket) = shift;
	my($reply);
	#
	# We keep receiveing the data from the server until
	# it waits for next command.
	#
	while ($socket && ($reply = <$socket>))
	{
		return (1) if $reply =~ /^5/;
		last if $reply =~ /^\d+ /;
	};
	return( 0 );
};
##################################################################################
#
# sendToserver : Send data to server on socket conection.
#
##################################################################################
sub sendToServer # ( $socket, $message ) -> ()
{
	my($socket) = shift;
	my($message) = shift;
	print "	 --Tx $message\n";
	# Fix BareLf problem.
	$message =~ s/\n/\r\n/g;
	$message =~ s/\r\r\n/\r\n/g;
	#
	# Sending data to the server.
	#
	send($socket, "$message\r\n", 0);
	return( 0 );
};
##################################################################################
#
# getEmailAddress : Get email from "Name" <my.email@my.host> line.
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub getEmailAddress # ( $test ) -> ( $email )
{
	my($value) = shift;
	my($retvalue) = undef;
	if ($value =~ /^\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/)
	{
		($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
		return $retvalue;
	};
	if ($value =~ /^[^\<]+\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/)
	{
		($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
		return $retvalue;
	};
	return "" if $value =~ /\s+/;
	$value =~ tr/[A-Z]/[a-z]/;
	return $value if $value =~ /^[^\@]+\@[\w\-]+(\.[\w\-]+)+$/;
	return( "" );
}
##################################################################################
#
# End of mail test send routines
#
##################################################################################
##################################################################################
#
# Sub PrintHelp : print help when --help option is used
#
##################################################################################
sub PrintHelp # () -> ()
{
	print "bck version : $version\n";
	print "Options :\n";
	print "	--verbose			: Verbose\n";
	print "	--config-file=	[/mypath/myconfig.file]\n";
#	print "	--systemcheck			: Include system check in report\n";
#	print "	--install			: Create config file mode\n";
	print "	--update			: Update from http/ftp server.\n";
	print "	--http				: Run bck in http server mode for use with inetd\n";
	print "	--report			: Report in to central cerver.\n";
	print "	--mail				: Send pending reports by e-mail\n";
	print "	--check				: Check configuration file\n";
	print "	--debug				: Debugging verbosity\n";
	print "	--version			: Show version\n";
	print "	--do=[block1[,block2...]]	: Execute block1, block2...\n";
	print "	--help|?			: Show this help\n\n";
};
##################################################################################
#
# Sub PrintVersion : print version when --version option is used
#
##################################################################################
sub PrintVersion # () -> ()
{
	print "bck version : $version\n";
};
# NOT USED #################################################################################
#
# Sub CreateConfig : Create configuration file
#
# NOT USED #################################################################################
sub CreateConfig # (configfile) -> ()
{
	my($configfile) = @_;
	print "Creating config file subroutine\n";
	return(0);
};
##################################################################################
#
# Sub Update : Update to new version from ftp server
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub Update # (configfile) -> ()
{
	my( $configfile ) = @_;
	my( $cfg, $name, $path, $result, $url, $user, $pass, $cmd );
	use File::Copy;
	use FindBin qw( $Bin $Script );
	$path = $Bin;
	$name = $Script;
	print "Preparing to update bck-backup version $version...\n";
	my ( $configfilename ) = $cmdln->GetConfigFileName;
	if ( -e $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
	};
	if ( defined $cfg)
	{
		$url	= $cfg->val('update', 'url');
		$user	= $cfg->val('update', 'user');
		$pass	= $cfg->val('update', 'password');
	};
	if ( ( defined $url ) and ( defined $user ) and ( defined $pass ) )
	{
		$cmd = "wget $url --quiet --user=$user --password=$pass --output-document=$path/$name.new";
	}
	else
	{
		$cmd = "wget $url --quiet --output-document=$path/$name.new";
	};
	if ( defined $url )
	{
		$result = `$cmd`;
		if ( -e  "$path/$name.new" )
		{
			# Check the downloaded version.
			undef $result;
			open FILE, "<$path/$name.new";
			while ( <FILE>)
			{
				if ( /my.*\$version.*=.*\"(\d+\.\d+\.\d+)\"/ )
				{
					$result = "$1";
					last;
				};
			};
			close FILE;
			print "Downloaded version $result\n";
			chomp( $result );
			if ( &ConvertVersionString($result) gt &ConvertVersionString($version) )
			{
				print "Installing new version...\n";
				if ( -e "$path/$name.$version" )
				{
					unlink ("$path/$name.$version");
				};
				chmod 0755, "$path/$name.new";
				move ("$path/$name","$path/$name.$version");
				move ("$path/$name.new","$path/$name");
				print "$name succesfully updated to version $result\n";
			}
			elsif ( &ConvertVersionString($result) lt &ConvertVersionString($version) )
			{
				print "No updates available, instaled version ($version) is newer then downloaded version ($result).\n";
				unlink ("$path/$name.new");
			}
			else
			{
				print "Already up to date.\n";
				unlink ("$path/$name.new");
			};
		}
		else
		{
			print "Update failed\n";
		};
	}
	else
	{
		print "Update failed\n";
	};
	return(0);
};
##################################################################################
#
# ConvertVersionString : Convert version string to int.
#
# Input validation : OK (BV 11/9/2009)
#
##################################################################################
sub ConvertVersionString # ( $versionstring ) -> ( $versionnum )
{
	my ( $version ) = @_;
	my ( $vernum, $vercount );
	# Clean up the string
	chomp ( $version);
	$version = StrCl( $version );
	$version =~ s/^\s+//;
	$version =~ s/\s+$//;
	# Split up in array
	my ( @ver ) = split( /\./, $version );
	$vercount = @ver;
	$vernum = 0;
	# Make an int with version by multiplicating by 1000 every piece.
	for (my $num=0 ; $num lt $vercount ; $num++  )
	{
		$vernum*= 1000;
		$vernum+= $ver[$num];
	};
	return ( $vernum );
};
##################################################################################
#
# Start -> WEB INTERFACE
#
##################################################################################
##################################################################################
##################################################################################
#
# Class HttpServer : Web interface server class
#
##################################################################################
package HttpServer;
#includes
use English;
use Config;
our @ISA = qw( TableFile );	# inherits from TableFile
#constructor
sub new
{	my ($class) = @_;
	my $self =
	{
		_configfile	=> "",
		_html		=> "",
		_htmlheaders => "",
		_method		=> "",
		_uri		=> "",
		_protocol	=> "",
		_headers	=> [],
		_headerlist => {},
		_postdata	=> {}
  	};
	bless $self, $class;
	return $self;
};
#accessor method for html
sub GetHtml
{
	my ( $self ) = shift;
	return $self->{_html};
};
sub AddHtml
{
	my ( $self ) = shift;
	my ( $html ) = @_;
	$self->{_html} .= $html;
};
#accessor method for htmlheaders
sub AddHeaders
{
	my ( $self ) = shift;
	my ( $headers ) = @_;
	$self->{_htmlheaders} .= $headers;
	print "$headers\n";
};
#accessor method for configfile
sub SetConfigfile
{
	my ( $self ) = shift;
	my ( $configfile ) = @_;
	$self->{_configfile} = $configfile;
};
#######################################################################################
#
# Parse request data from browser
#
# Input validation : OK (BV 11/9/2009)
#
#######################################################################################
sub ParseRequest
{
	my ( $self ) = shift;
	my $chunk;
	while ( sysread( STDIN, my $buff, 1 ) )
	{
		last if $buff eq "\n";
		$chunk .= $buff;
	}
	defined($chunk) or return undef;
	$_ = $chunk;
	m/^(\w+)\s+(\S+)(?:\s+(\S+))?\r?$/;
	my $method   = $1 || '';
	my $uri	  = lc($2) || '';
	my $protocol = $3 || '';
	$self->{_method} =  ::StrCl( $method );
	$self->{_uri} =  ::StrCl( $uri );
	$self->{_protocol} =  ::NumNz( $protocol );
	return();
};
#######################################################################################
#
# Handle http requests
#
# Input validation : OK (BV 11/9/2009)
#
#######################################################################################
sub Start # () -> ()
{
	my ( $self ) = shift;
	my ( $type ) = shift;
	$type = ::NumCl( $type );
	$self->ParseRequest();
	# If $type bit 0 = 1, respond to HTTP GET requests
	if ( ( $self->{_method} eq "GET" ) and ( $type & 1 ) )
	{
		if ( $self->{_uri} eq "/" )
		{
			$self->HtmlMain();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/test" )
		{
			$self->HtmlTest();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/logs" )
		{
			$self->HtmlLogs();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} =~ /detail/ )
		{
			$self->HtmlDetail( $self->{_uri} );
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/config" )
		{
			if ( $self->HtmlConfig() == 1 )
			{
			$self->SendHeaders();
			$self->SendBody();
			}
			else
			{
				$self->SendAuthHeaders("Config");
				$self->SendBody();
			};
		}
		else
		{
			$self->HtmlNotfound();
			$self->SendNotFoundHeaders();
			$self->SendBody();
		};
	}
	elsif ( ( $self->{_method} eq "POST" ) and ( $type & 1 ) )
	{
		if ( $self->{_uri} eq "/config" )
		{
			if ( $self->HtmlEditsection() == 1 )
			{
			$self->SendHeaders();
			$self->SendBody();
			}
			else
			{
				$self->SendAuthHeaders("Config");
				$self->SendBody();
			};
		}
		elsif ( $self->{_uri} eq "/" )
		{
			$self->HtmlMain();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/writeconfig" )
		{
			if ( $self->HtmlWriteconfig() == 1 )
			{
			$self->SendHeaders();
			$self->SendBody();
			}
			else
			{
				$self->SendAuthHeaders("Config");
				$self->SendBody();
			};
		}
		elsif ( $self->{_uri} eq "/test" )
		{
			$self->HtmlTest();
			$self->SendHeaders();
			$self->SendBody();
		}
		elsif ( $self->{_uri} eq "/logs" )
		{
			$self->HtmlLogs();
			$self->SendHeaders();
			$self->SendBody();
		}
		else
		{
			$self->HtmlNotfound();
			$self->SendNotFoundHeaders();
			$self->SendBody();
		};
	}
	# If $type bit 1 = 1, respond to bck report server requests
	elsif ( ( lc( $self->{_method} ) eq "bck" ) and ( $type & 2 ) )
	{
		# Create a random seed
		my ( $seed ) = sprintf("%2x", int( rand( 255 ) ) );
		# Get report access password.
		my ( $rsection ) = ReportSection->new();
		my ( $password ) = $rsection->GetServerAuth();

		# Create password string for compare
		my  ( $authstring ) = crypt( $password, $seed );
		# Send the seed
		print "bck" . $seed . "\n";
		# Wait for authentification and report lines
		my ( @report );
		my ( $numreports ) = 0;
		my $fh = select ( STDOUT );
		$| = 1;
		select ( $fh );
		while ( my $line = <STDIN> )
		{
			$line =~ s/\r?\n$//;
			last if $line eq "bck/END/";
			push ( @report, $line );
			$numreports++;
		};
		my ( $auth ) = shift( @report );
		$auth = substr( $auth, 3 );
		print "bck", $numreports - 2 ,"\n";
		my ( $statusfile ) = $cmdln->GetStatusFileName;
		if ( $authstring eq $auth )
		{
			print "bck", $numreports - 2 ,"\n";
			my ( $table ) = TableFile->new();
			$table->SetFile( $gsection->GetSpoolDir() . '/' . "$statusfile" . '.tbl' );
			foreach my $line ( @report )
			{
				my ( $statusbits, $section, $name, $timestamp, $stat, $size, $destsize, $destfree ) = split( /,/,$line );
				if ( !defined $statusbits ) { $statusbits = 24 };
				if ( !defined $section ) { $section = " " };
				if ( !defined $name ) { $name = " " };
				if ( !defined $timestamp ) { $timestamp = 0 };
				if ( !defined $stat ) { $stat = "" };
				$size = ::NumCl( $size );
				$destsize = ::NumCl( $destsize );
				$destfree = ::NumCl( $destfree );
				$table->{_statusbits} = $statusbits | 128;
				$table->SetSection( $section );
				$table->SetName( $name );
				$table->SetTimeStamp( $timestamp );
				$table->SetStatusText( $stat );
				$table->SetSize( $size );
				$table->SetDestSize( $destsize );
				$table->SetDestFree( $destfree );
				$table->AddLine();
			};
		}
		else
		{
			print "bck00\n";
		};
	}
	else
	{
		print "What are you doing?\r\nYou are not a browser, are you?\r\n";
	};
	return();
};
#######################################################################################
#
# SendHeaders
#
#######################################################################################
sub SendHeaders
{
	my ( $self ) = shift;
	print "HTTP/1.1 200 OK\r\n";
	print "Server: bck-backup/$version\r\n";
	print "Cache-Control: no-cache\r\n";
	print "Connection: close\r\n";
	print "Content-Length: " . length( $self->{_html} ) . "\r\n";
	print "Content-Language: en\r\n";
	print "Content-Type: text/html;charset=utf-8\r\n\r\n";
	return();
};
#######################################################################################
#
# SendChunkedHeaders
#
#######################################################################################
sub SendChunkedHeaders
{
	my ( $self ) = shift;
	print "HTTP/1.1 200 OK\r\n";
	print "Server: bck-backup/$version\r\n";
	print "Cache-Control: no-cache\r\n";
	print "Connection: close\r\n";
	print "Transfer-Encoding: chunked\r\n";
	print "Content-Language: en\r\n";
	print "Content-Type: text/html;charset=utf-8\r\n\r\n";
	return();
};
#######################################################################################
#
# SendAuthHeaders
#
#######################################################################################
sub SendAuthHeaders
{
	my ( $self ) = shift;
	my ( $realm ) = @_;
	$self->HtmlBodyTop();
	$self->AddHtml ( "<br><h1>401 Unauthorized</h1><p>Authorization Required</p>\r\n" );
	$self->AddHtml ( "<p>This server could not verify that you are authorized to access<br>\r\n" );
	$self->AddHtml ( "the document requested. Either you supplied the wrong credentials<br>\r\n" );
	$self->AddHtml ( "(e.g., bad password), or your browser doesn't understand how to<br>\r\n" );
	$self->AddHtml ( "supply the credentials required.</p>\r\n" );
	$self->HtmlBodyBottom();
	print "HTTP/1.1 401 Unauthorized\r\n";
	print "Server: bck-backup/$version\r\n";
	print 'WWW-Authenticate: Basic realm="' . $realm . '"' . "\r\n";
	print "Cache-Control: no-cache\r\n";
	print "Connection: close\r\n";
	print "Content-Length: " . length( $self->{_html} ) . "\r\n";
	print "Content-Language: en\r\n";
	print "Content-Type: text/html;charset=utf-8\r\n\r\n";
	return();
};
#######################################################################################
#
# SendNotFoundHeaders
#
#######################################################################################
sub SendNotFoundHeaders
{
	my ( $self ) = shift;
	print "HTTP/1.1 404 Not Found\r\n";
	print "Server: bck-backup/$version\r\n";
	print "Cache-Control: no-cache\r\n";
	print "Connection: close\r\n";
	print "Content-Length: " . length( $self->{_html} ) . "\r\n";
	print "Content-Language: en\r\n";
	print "Content-Type: text/html;charset=utf-8\r\n\r\n";
	return();
};
#######################################################################################
#
# SendBody
#
#######################################################################################

sub SendBody
{
	my ( $self ) = shift;
	print $self->{_html};
};
#######################################################################################
#
# SendBodyChunk
#
#######################################################################################
sub SendBodyChunk
{
	my ( $self ) = shift;
	printf ( "%x\r\n" , length( $self->{_html} ) );
	print $self->{_html} . "\r\n";
	$self->{_html} = "";
};
#######################################################################################
#
# ParseHeaders
#
# Input validation : PENDING!
#
#######################################################################################
sub ParseHeaders
{
	my ( $self ) = shift;
	my $chunk = '';
	while ( sysread( STDIN, my $buff, 1 ) )
	{
		if ( $buff eq "\n" )
		{
			$chunk =~ s/[\r\l\n\s]+$//;
			if ( $chunk =~ /^([\w\-]+): (.+)/i )
			{
				push @{$self->{_headers}}, $1 => $2;
			}
			last if ( $chunk =~ /^$/ );
			$chunk = '';
		}
		else
		{
			$chunk .= $buff
		}
	};
	my $counter = 0;
	while ( $counter < $#{$self->{_headers}})
	{
		$self->{_headerlist}->{lc( $self->{_headers}->[$counter])} = $self->{_headers}->[$counter+1];
		$counter++;
		$counter++;
	};
	return ();
};
#######################################################################################
#
# ParsePostdata
#
# Input validation : PENDING!
#
#######################################################################################
sub ParsePostdata # (datasize) -> (data)
{
	my ( $self ) = shift;
	my ( $data, @datalist );
	sysread( STDIN, $data, $self->{_headerlist}->{"content-length"} );
	@datalist = split(/&/,$data);
	foreach $data ( @datalist )
	{
		$data =~ s/\+/ /g;
		$data =~ s/%(..)/pack("C",hex($1))/ge;
		$data =~ s/[\'\^\`\;\'&?]//g; #`
		my ( $var, $val ) = split(/=/,$data);
		$self->{_postdata}->{$var} = $val;
	};
	return ( );
};
#######################################################################################
#
# HtmlMain
#
# Input validation : OK (BV 11/07/2009)
#
#######################################################################################
sub HtmlMain # () -> ()
{
	my ( $self ) = shift;
	my ( $statusfile ) = $cmdln->GetStatusFileName;
	$self->ParseHeaders;
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	my ($page ) = $self->{_postdata}->{"page"};
	my ( $gsection ) = GlobalSection->new();
	my ( $hsection ) = HttpSection->new();
	# If not defined, page = 1
	$page = 1 unless $page;
	my ( $lastpage ) = 1;
	if ( -e $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' )
	{
		my ( $table ) = TableFile->new();
		$table->SetFile( $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' );
		$lastpage = int( ( $table->GetNumLines() / $hsection->GetReportlines() ) + 0.5 );
		$lastpage = 1 unless ( $lastpage gt 1 );
	};
	$self->HtmlBodyTop();
	$self->AddHtml( "<tr><th class=\"buttons\">" );
	if ( $page > 1 )
	{
		$self->AddHtml ( "<form class=\"left\" action=\"\" method=\"POST\">\n" );
		$self->AddHtml ( '<input class="button" type="Submit" value="First page" name="group1">' . "\r\n" );
		$self->AddHtml ( '<input type="hidden" name="page" value="' . 1 . '" size="20">' . "\r\n" );
		$self->AddHtml ( "</form>" );
		$self->AddHtml ( "<form class=\"left\" action=\"\" method=\"POST\">\n" );
		$self->AddHtml ( '<input class="button" type="Submit" value="Previous page" name="group1">' . "\r\n" );
		$self->AddHtml ( '<input type="hidden" name="page" value="' . ( $page - 1 ) . '" size="20">' . "\r\n" );
		$self->AddHtml ( "</form>" );
	};
	if ( $page < $lastpage )
	{
		$self->AddHtml ( "<form class=\"right\" action=\"\" method=\"POST\">\n" );
		$self->AddHtml ( '<input class="button" type="Submit" value="Last page" name="group2">' . "\r\n" );
		$self->AddHtml ( '<input type="hidden" name="page" value="' . $lastpage . '" size="20">' . "\r\n" );
		$self->AddHtml ( "</form>" );
		$self->AddHtml ( "<form class=\"right\" action=\"\" method=\"POST\">\n" );
		$self->AddHtml ( '<input class="button" type="Submit" value="Next page" name="group2">' . "\r\n" );
		$self->AddHtml ( '<input type="hidden" name="page" value="' . ( $page + 1 ) . '" size="20">' . "\r\n" );
		$self->AddHtml ( "</form>" );
	};
	$self->AddHtml( "</th></tr><tr><td>" );
	$self->AddHtml( "<table class=\"lines\">\n" );
	$self->AddHtml( "<thead>\n"
	. "<tr>\n"
	. "<th class=\"pages\" colspan=\"5\">"
	. "Backup reports - Page " . $page . " of " . $lastpage . "\n"
	. "</th>\n"
	. "</tr>\n"
	. "<tr>\n"
	. "<th class=\"lines\">Operation\n"
	. "</th>\n"
	. "<th class=\"lines\" width=\"120\">Date/Time\n"
	. "</th>\n"
	. "<th class=\"lines\" width=\"120\">Size (Use%)\n"
	. "</th>\n"
	. "<th class=\"lines\" width=\"100\">Status\n"
	. "</th>\n"
	. "<th class=\"lines\" width=\"120\">Report\n"
	. "</th></thead><tbody>\n" );
	if ( -e $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' )
	{
		my ( $line, $date, @lines );
		my ( $reportstatus ) = 0;
		my ( $counter ) = 0;
		my ( $table ) = TableFile->new();
		$table->SetFile( $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' );
		@lines = $table->ReadLast( $hsection->GetReportlines(), $page );	
		foreach $line ( @lines )
		{
			chomp( $line );
			$line = ::StrCl( $line );
			my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree,$id ) = split( /,/,$line );
			$statusbits = ::NumCl( $statusbits );
			$section = ::StrCl( $section );
			$name = ::StrCl( $name );
			$timestamp = ::NumCl( $timestamp );
			$statustext = ::StrCl( $statustext );
			$size = ::NumCl( $size );
			$destsize = ::NumCl( $destsize );
			$destfree = ::NumCl( $destfree );
			$id = ::NumCl( $id );
			my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( $timestamp );
			my ( $date ) =  sprintf( "%02d/%02d/%02d %02d:%02d", $mday, ( $mon + 1 ), ( $year + 1900 ), $hour, $min );
			$self->AddHtml ( "<tr " );
			if ( $statusbits & 4 )
			{
				$self->AddHtml( "class=\"header\"" );
			}
			elsif ( $statusbits & 128 )
			{
				$self->AddHtml( "class=\"remote\"" );
			}
			else
			{
				$self->AddHtml( "class=\"local\"" );
			};
			$self->AddHtml ( ">\n" . "<td class=\"lines\"><a class=\"line\" href=\"/detail/$id\">[$section] $name</a>\n" . "</td>\n" );
			$self->AddHtml ( "<td class=\"lines\">$date\n" . "</td>\n" );
			$self->AddHtml ( "<td class=\"blue\">\n" );
			if ( $destsize ne 0 )
			{
				$self->AddHtml ( "<div>\n" );
			};
			$self->AddHtml ( ::HumanBytes( $size ) );
			if ( $destsize ne 0 )
			{
				$self->AddHtml ( "&nbsp;(" . int( 100 - ( $destfree / $destsize ) * 100 ) . "%)\n" );
				$self->AddHtml ( "<div style=\"background: rgb(255,0,0); float: left; color: rgb(255,255,0); overflow: hidden; border: 0px; margin: 0px 0px 0px 0px; height: 4px; padding: 0; width: " . int( 100 - ( $destfree / $destsize ) * 100 )  . "% \"></div>" );
				$self->AddHtml ( "</div>\n" );
			}
			$self->AddHtml ( "</td>\n" );
			$self->AddHtml ( "<td " );
			if ( $statusbits & 24 ) # Invalid
			{
				$self->AddHtml ( "class=\"red\"" );
			}
			elsif ( $statusbits & 16 ) # Error
			{
				$self->AddHtml ( "class=\"red\"" );
			}
			elsif ( $statusbits & 8 ) # Warning
			{
				$self->AddHtml ( "class=\"orange\"" );
			}
			else # OK
			{
				$self->AddHtml ( "class=\"green\"" );
			}
			$self->AddHtml (">$statustext</td>\n");
			$self->AddHtml ("<td ");
			if ( ( $statusbits & 1 ) and ( $statusbits & 2 ) )
			{
				$self->AddHtml ( "class=\"green\">Mail &amp; Report" );
			}
			elsif ( $statusbits & 2 )
			{
				$self->AddHtml ( "class=\"green\">Report" );
			}
			elsif ( $statusbits & 1 )
			{
				$self->AddHtml ( "class=\"green\">Mail" );
			}
			else
			{
				$self->AddHtml ( "class=\"orange\">Pending" );
			};
			$self->AddHtml ( "</td>\n" . "</tr>\n" );
		};
   	}
	else
	{
		$self->AddHtml ( "<tr><td class=\"orange\" colspan=\"5\">No data</td></tr>" );
	};
	$self->AddHtml ( "</tbody>\n" . "</table>\n" . "\n" );
	$self->HtmlBodyBottom();
	return();
};
#######################################################################################
#
# HtmlDetail : Display detailed info for entry
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlDetail # ( $uri ) -> ()
{
	my ( $self ) = shift;
	my ( $uri ) = shift;
	my ( $statusfile ) = $cmdln->GetStatusFileName;
	$self->ParseHeaders;
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	my ( $gsection ) = GlobalSection->new();
	my ( $hsection ) = HttpSection->new();
	$self->HtmlBodyTop();
	$uri =~ /\/detail\/(.*)/;
	my ( $id ) = $1;
	$self->AddHtml("<br><table class=\"lines\">\n"
	. "<tbody>\n" );
	# content here
	my ( $table ) = TableFile->new();
	$table->SetFile( $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' );
	my ( $line ) = $table->ReadLine( $id );
	$self->AddHtml("Section: " . $table->GetSection() . "<br>\r\n" );
	$self->AddHtml("Name: " . $table->GetName() . "<br>\r\n" );
	$self->AddHtml("Timestamp: " . $table->GetHTimeStamp() . "<br>\r\n" );
	$self->AddHtml("Result: " . $table->GetStatusText() . "<br>\r\n" );
	$self->AddHtml("Size: " . $table->GetSize() . " (bytes) <br>\r\n" );
	$self->AddHtml("Size of destnation: " . $table->GetDestSize() . " (bytes) <br>\r\n" );
	$self->AddHtml("Space free on destnation: " . $table->GetDestFree() . " (bytes) <br>\r\n" );
	$self->AddHtml("Report mailed: " . $table->GetMailrep() . "<br>\r\n" );
	$self->AddHtml("Report sent to server: " . $table->GetCommrep() . "<br>\r\n" );
	$self->AddHtml("More info to come....<br>\r\n");
	$self->AddHtml("<br>Raw status file data: &gt;$line&lt; <br>\r\n" );
	$self->AddHtml("</tbody>\n" . "</table>\n" . "<br>\n");
	$self->HtmlBodyBottom();
	return();
};
#######################################################################################
#
# HtmlLogs :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlLogs # () -> ()
{
	my ( $self ) = shift;
	# If not defined, page = 1
	my ( $statusfile ) = $cmdln->GetStatusFileName;
	$self->ParseHeaders;
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	my ($page ) = $self->{_postdata}->{"page"};
	my ( $gsection ) = GlobalSection->new();
	my ( $hsection ) = HttpSection->new();
	$page = 1 unless $page;
	my ( $lastpage ) = 1;
	if ( -e $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' )
	{
		my ( $table ) = TableFile->new();
		$table->SetFile( $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' );
		$lastpage = int( ( $table->GetNumLines() / $hsection->GetReportlines() ) + 0.5 );
		$lastpage = 1 unless ( $lastpage gt 1 );
	};
	$self->HtmlBodyTop();
	if ( ( $self->{_method} eq "POST" ) and ( defined $self->{_postdata}->{"file"} ) )
	{
		my ( $ext );
		if ( $self->{_postdata}->{"group"} =~ /log/ )
		{
			$ext = "log";
		}
		else
		{
			$ext = "lst";
		};
		if ( -e $gsection->GetLogDir() . "/" . $self->{_postdata}->{"file"} . "." . lc( $ext ) )
		{
			open ( FILEDATA, "<" . $gsection->GetLogDir() . "/" . $self->{_postdata}->{"file"} . "." . lc( $ext ) );
			my ( $line, $size );
			$self->AddHtml( "<br><b>File: </b><i>" . $gsection->GetLogDir() . "/" . $self->{_postdata}->{"file"} . "." . lc( $ext ) . "</i><br>\r\n" );
			foreach $line (<FILEDATA>)
			{
				chomp( $line );
				$self->AddHtml( "$line<br>\r\n" );
			};
			close ( FILEDATA );
		}
		else
		{
			$self->AddHtml( "<br>No data<br>\r\n" );
		};
	};
	if ( ( $self->{_method} eq "GET" ) or ( defined $self->{_postdata}->{"page"} ) )
	{
		$self->AddHtml( "<tr><th class=\"buttons\">" );
		if ( $page > 1 )
		{
			$self->AddHtml ( "<form class=\"left\" action=\"\" method=\"POST\">\n" );
			$self->AddHtml ( '<input class="button" type="Submit" value="First page" name="group">' . "\r\n" );
			$self->AddHtml ( '<input type="hidden" name="page" value="' . 1 . '" size="20">' . "\r\n" );
			$self->AddHtml ( "</form>" );
			$self->AddHtml ( "<form class=\"left\" action=\"\" method=\"POST\">\n" );
			$self->AddHtml ( '<input class="button" type="Submit" value="Previous page" name="group">' . "\r\n" );
			$self->AddHtml ( '<input type="hidden" name="page" value="' . ( $page - 1 ) . '" size="20">' . "\r\n" );
			$self->AddHtml ( "</form>" );
		};
		if ( $page < $lastpage )
		{
			$self->AddHtml ( "<form class=\"right\" action=\"\" method=\"POST\">\n" );
			$self->AddHtml ( '<input class="button" type="Submit" value="Last page" name="group">' . "\r\n" );
			$self->AddHtml ( '<input type="hidden" name="page" value="' . $lastpage . '" size="20">' . "\r\n" );
			$self->AddHtml ( "</form>" );
			$self->AddHtml ( "<form class=\"right\" action=\"\" method=\"POST\">\n" );
			$self->AddHtml ( '<input class="button" type="Submit" value="Next page" name="group">' . "\r\n" );
			$self->AddHtml ( '<input type="hidden" name="page" value="' . ( $page + 1 ) . '" size="20">' . "\r\n" );
			$self->AddHtml ( "</form>" );
		};
		$self->AddHtml( "</th></tr><tr><td>" );
		$self->AddHtml ( "<table class=\"lines\">\n" );
		$self->AddHtml ( "<thead>\n"
		. "<tr>\n"
		. "<th colspan=\"5\" class=\"pages\">"
		. "Logs - Page " . $page . " of " . $lastpage . "\n"
		. "</th>\n"
		. "</tr>\n"
		. "<tr>\n"
		. "<th class=\"lines\">Section<br>\n"
		. "</th>\n"
		. "<th class=\"lines\" width=\"120\">Date/Time<br>\n"
		. "</th>\n"
		. "<th class=\"lines\" width=\"100\">Logfile Size<br>\n"
		. "</th>\n"
		. "<th class=\"lines\" width=\"100\">Listfile Size<br>\n"
		. "</th>\n"
		. "</tr></thead><tbody>\n" );
		if ( -e $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' )
		{
			my ( $line, $date, @lines );
			my ( $reportstatus ) = 0;
			my ( $counter ) = 0;
			my ( $table ) = TableFile->new();
			$table->SetFile( $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' );
			@lines = $table->ReadLast( $hsection->GetReportlines(), $page );	
			foreach $line ( @lines )
			{
				chomp( $line );
				$line = ::StrCl( $line );
				my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree,$id ) = split( /,/,$line );
				$statusbits = ::NumCl( $statusbits );
				$section = ::StrCl( $section );
				$name = ::StrCl( $name );
				$timestamp = ::NumCl( $timestamp );
				$statustext = ::StrCl( $statustext );
				$size = ::NumCl( $size );
				$destsize = ::NumCl( $destsize );
				$destfree = ::NumCl( $destfree );
				$id = ::NumCl( $id );
				my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime( $timestamp );
				my ($date ) = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . sprintf( "%02d:%02d" , $hour, $min );
				$self->AddHtml ( "<tr " );
				if ( $statusbits & 4 )
				{
					$self->AddHtml( "class=\"header\"" );
				}
				elsif ( $statusbits & 128 )
				{
					$self->AddHtml( "class=\"remote\"" );
				}
				else
				{
					$self->AddHtml( "class=\"local\"" );
				};
				$self->AddHtml ( ">\n" . "<td class=\"col\">\r\n" );
				$self->AddHtml( "<form class=\"left\" action=\"logs\" method=\"POST\" >\n" );
				$self->AddHtml( "<label>[$section] $name </label>" );
				if ( -e $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".log" )
				{
					if ( -e $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".lst" )
					{
						$self->AddHtml( '<input class="button" type="Submit" value="Show file list" name="group">' . "\r\n" );
					};
					$self->AddHtml( '<input class="button" type="Submit" value="Show log file" name="group">' . "\r\n" );
					$self->AddHtml( '<input type="hidden" name="file" value="' .  "$section.$timestamp" . '" size="20">' . "\r\n" );
				}
				$self->AddHtml( "</form>" );
				$self->AddHtml( "</td>\n" );
				$self->AddHtml( "<td class=\"lines\">$date\n" . "</td>\n" );
				if ( -e $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".log" )
				{
					$size = -s $gsection->GetLogDir() . "/" . $section . "." . $timestamp . ".log";
					$self->AddHtml( "<td class=\"lines\">" . ::HumanBytes( $size ) . "\n" . "</td>\n" );
				}
				else
				{
					$self->AddHtml( "<td class=\"lines\">n/a\n" . "</td>\n" );
				};
				if ( -e $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".lst" )
				{
					$size = -s $gsection->GetLogDir() . "/"  . $section . "." . $timestamp . ".lst";
					$self->AddHtml( "<td class=\"lines\">" . ::HumanBytes($size) . "\n" . "</td>\n" );
				}
				else
				{
					$self->AddHtml( "<td class=\"lines\">n/a\n" . "</td>\n" );
				};
				$self->AddHtml( "\r\n</tr>\n" );
			};
		}
		else
		{
			$self->AddHtml( "<tr><td class=\"orange\"  colspan=\"5\">No data</td></tr>" );
		};
	};
	$self->AddHtml( "</tbody>\n" . "</table>\n" . "\n" );
	$self->HtmlBodyBottom();
	return();
};
#######################################################################################
#
# HtmlNotfound :
#
# Input Validation : PENDING!
#
#######################################################################################
sub HtmlNotfound # () -> ()
{
	my ( $self ) = shift;
	$self->ParseHeaders;
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	my ( $var, $val );
	$self->HtmlBodyTop();
	$self->AddHtml( '<br><h1>404 Not Found</h1><p>Page Not Found</p>' );
	$self->AddHtml( '<p>The requested URL ' . $self->{_uri} . ' was not found on this server.</p>' );
	$self->HtmlBodyBottom();
	return();
};
#######################################################################################
#
# HtmlConfig :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlConfig # () -> ()
{
	use MIME::Base64;
	my ( $self ) = shift;
	my ( $var, $val );
	$self->ParseHeaders();
	my ( $hsection ) = HttpSection->new();
	my $authstring = $hsection->GetUser() . ":" . $hsection->GetPassword();
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	if ( defined ( $self->{_headerlist}->{"authorization"} ) )
	{
		return(0) unless( $self->{_headerlist}->{"authorization"} eq "Basic " . encode_base64( "$authstring","" ) )
	}
	else
	{
		return( 0 );
	};
	$self->HtmlBodyTop();
	$self->AddHtml( "<br><b>Config file:</b><br><br>" );
	if ( -e $self->{_configfile} )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
		};
		foreach my $section ( $cfg->Sections)
		{
			$self->AddHtml( "<hr>" );
			$self->AddHtml( '<form action="config" method="POST">' . "\r\n<b>[" . "$section" . "]</b>&nbsp;&nbsp;" . '<input type="hidden" name="section" value="' .  "$section" . '" size="20" ><input type="Submit" value="Edit"></form>' . "\r\n" );
			my @values = $cfg->Parameters($section);
			$self->AddHtml( '<table border="1">' );
			foreach $var ( @values )
			{
				$val = $cfg->val($section, $var);
				$val =~ s/\n/\,/g;
				$val =~ s/\</&lt;/g;
				$val =~ s/\>/&gt;/g;
				$val =~ s/\"/&quot;/g;
				if ( $var =~ m/pass/ )
				{
					$val = "************";
				};
				$self->AddHtml( "<tr><td>" . $var  . " = </td><td> " . $val . "</td></tr>\r\n" );
			};
			$self->AddHtml( '</table><hr>' );
		};
	};
	$self->HtmlBodyBottom();
	return( 1 );
};
#######################################################################################
#
# HtmlEditSection :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlEditsection # () -> () 
{
	my ( $self ) = shift;
	my ( $section, $var, $val );
	my ( $hsection ) = HttpSection->new();
	my $authstring = $hsection->GetUser() . ":" . $hsection->GetPassword();
	$self->ParseHeaders();
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata( );
	};
	$section = $self->{_postdata}->{"section"};
	if ( defined ( $self->{_headerlist}->{"authorization"} ) )
	{
		return( 0 ) unless( $self->{_headerlist}->{"authorization"} eq ("Basic " . encode_base64("$authstring","")) )
	}
	else
	{
		return( 0 );
	};
	$self->HtmlBodyTop();
	$self->AddHtml( '<br>Editing section <b>' . $section . ':</b>' . "\r\n" . '<br><br>' );
	if (-r $self->{_configfile} )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
		};
		$self->AddHtml( "<b>[" . $section . "]</b>" );
		my @values = $cfg->Parameters($section);
		$self->AddHtml( '<form action="writeconfig" method="POST"><input type="hidden" name="section" value="' .  "$section" . '" size="20">' . "\r\n" );
		$self->AddHtml( '<table border="1">' );
		foreach $var (@values)
		{
			$val = $cfg->val($section, $var);
			$val =~ s/\n/\,/g;
			$val =~ s/\</&lt;/g;
			$val =~ s/\>/&gt;/g;
			$val =~ s/\"/&quot;/g;
			$self->AddHtml( '<tr><td>' . $var . '</td><td>' );
			if ( $var =~ m/pass/ )
			{
				$self->AddHtml( '<input type="password" ' );
			}
			else
			{
				$self->AddHtml( '<input type="text" ' );
			};
			$self->AddHtml( ' name="' . $var  . '" value="' .  $val . '" size="80">' . "\n\r" );
			$self->AddHtml( ' <input type="Submit" value="Delete ' . $var . '" name="del"></td></tr>' . "\r\n" );
		};
		$self->AddHtml( '<tr><td><input type="text" name="newvar" value="" size="20"></td><td><input type="text" name="newval" value="" size="80">' . "\r\n" . '<input type="Submit" value="Add" name="add"></td></tr>' . "\r\n" );
		$self->AddHtml( '</table>' );
		$self->AddHtml( '<input type="Submit" value="OK" name="ok"></form>' . "\r\n" );
	};
	$self->HtmlBodyBottom();
	return( 1 );
};
#######################################################################################
#
# HtmlWriteConfig :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlWriteconfig # () -> ()
{
	my ( $self ) = shift;
	my ( $section, $var, $val );
	$self->ParseHeaders();
	my ( $hsection ) = HttpSection->new();
	my $authstring = $hsection->GetUser() . ":" . $hsection->GetPassword();

	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};
	$section = $self->{_postdata}->{"section"};
	if ( defined ( $self->{_headerlist}->{"authorization"} ) )
	{
		if ( $self->{_headerlist}->{"authorization"} eq ("Basic " . encode_base64("$authstring","")) )
		{
			#Authentication OK!
		}
		else
		{
			#Autentication NOT OK!
			return(0);
		};
	}
	else
	{
		return(0);
	};
	$self->HtmlBodyTop();
	$self->AddHtml( '<br>Section <b>' . $section . '</b> written.' . "\r\n" . '<br><br>' );
	if (-r $self->{_configfile} )
	{
		if ( defined $self->{_postdata}->{"ok"} )
		{
			my ( $cfg, $mastercfg );
			if ( -r "/etc/bck/bck.default" )
			{
				  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
				  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
			}
			else
			{
				$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
			};
			$self->AddHtml( "<b>[" . $section . "]</b>" );
			my @values = $cfg->Parameters($section);
			$self->AddHtml( '<table border="1">' . "\r\n" );
			while (( $var, $val) = each %{$self->{_postdata}})
			{
				$cfg->setval($section, $var, $val );
			};
			foreach $var (@values)
			{
				$val = $cfg->val($section, $var);
				$val =~ s/\n/\,/g;
				$val =~ s/\</&lt;/g;
				$val =~ s/\>/&gt;/g;
				$val =~ s/\"/&quot;/g;
				if ( $var =~ m/pass/ )
				{
					$val = "************";
				};
				$self->AddHtml( '<tr><td>' . $var . ' = </td><td>' .  $val . '</td></tr>' . "\n\r" );
			};
			$self->AddHtml( '</table>' . "\r\n" );
			if ( $cfg->WriteConfig($self->{_configfile}) )
			{
				$self->AddHtml( "<p>Configuration file updated.</p>" );
			}
			else
			{
				$self->AddHtml( "ERROR" );
			};
		}
		elsif ( defined $self->{_postdata}->{'add'} )
		{
			$var = $self->{_postdata}->{'newvar'};
			$val = $self->{_postdata}->{'newval'};
			my ( $cfg, $mastercfg );
			if ( -r "/etc/bck/bck.default" )
			{
				  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
				  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
			}
			else
			{
				$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
			};
			$cfg->newval($section, $var, $val );
			$self->AddHtml( "<b>[" . $section . "]</b>" );
			my @values = $cfg->Parameters($section);
			$self->AddHtml( '<table border="1">' . "\r\n" );
			foreach $var (@values)
			{
				$val = $cfg->val($section, $var);
				$val =~ s/\n/\,/g;
				$val =~ s/\</&lt;/g;
				$val =~ s/\>/&gt;/g;
				$val =~ s/\"/&quot;/g;
				if ( $var =~ m/pass/ )
				{
					$val = "************";
				};
				$self->AddHtml( '<tr><td>' . $var . ' = </td><td>' .  $val . '</td></tr>' . "\n\r" );
			};
			$self->AddHtml( '</table>' . "\r\n" );
			if ( $cfg->WriteConfig($self->{_configfile}) )
			{
				$self->AddHtml( "<p>Configuration file updated.</p>" );
			}
			else
			{
				$self->AddHtml( "ERROR" );
			};
		}
		elsif ( defined $self->{_postdata}->{'del'} )
		{
			my ( $dummy );
			( $dummy, $var ) = split( /\s/, $self->{_postdata}->{'del'} );
			my ( $cfg, $mastercfg );
			if ( -r "/etc/bck/bck.default" )
			{
				  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
				  $cfg = Config::IniFiles->new( -file => $self->{_configfile}, -import => $mastercfg );
			}
			else
			{
				$cfg 	= Config::IniFiles->new( -file => $self->{_configfile} );
			};
			$cfg->delval($section, $var );
			$self->AddHtml( "<b>[" . $section . "]</b>" );
			my @values = $cfg->Parameters($section);
			$self->AddHtml( '<table border="1">' . "\r\n" );
			foreach $var (@values)
			{
				$val = $cfg->val($section, $var);
				$val =~ s/\n/\,/g;
				$val =~ s/\</&lt;/g;
				$val =~ s/\>/&gt;/g;
				$val =~ s/\"/&quot;/g;
				if ( $var =~ m/pass/ )
				{
					$val = "************";
				};
				$self->AddHtml( '<tr><td>' . $var . ' = </td><td>' .  $val . '</td></tr>' . "\n\r" );
			};
			$self->AddHtml( '</table>' . "\r\n" );
			if ( $cfg->WriteConfig($self->{_configfile}) )
			{
				$self->AddHtml( "<p>Configuration file updated.</p>" );
			}
			else
			{
				$self->AddHtml( "ERROR" );
			};
		}
		else
		{
			$self->AddHtml( "ERROR" );
		}
	};
	$self->HtmlBodyBottom();
	return (1);
};
#######################################################################################
#
# Htmltest :
#
# Input validation : PENDING!
#
#######################################################################################
sub HtmlTest # () -> ()
{
	my ( $self ) = shift;
	my ( $header, $value, $var, $val, $headers );
	$self->ParseHeaders();
	if ( $self->{_method} eq "POST" )
	{
		$self->ParsePostdata();
	};

	$self->HtmlBodyTop();
	$self->AddHtml( "<br><p><b>Request:</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>" );
	$self->AddHtml( "Method : " . $self->{_method} . "<br>" );
	$self->AddHtml( "URI : " . $self->{_uri} . "<br>");
	$self->AddHtml( "Protocol : " . $self->{_protocol} . "<br>" );
	$self->AddHtml( '<p><b>Headers: </b></p>' );
	while (( $header, $value ) = each ( %{$self->{_headerlist}} ))
	{
		$self->AddHtml( "$header : $value<br>\r\n" );
	};
	if ( $self->{_method} eq "POST" )
	{
		$self->AddHtml( "<p><b>Postdata:</b></p>\r\n" );
		while (( $var, $val) = each ( %{$self->{_postdata}} ) )
		{
			$self->AddHtml( "$var : $val<br>\r\n" );
		};
	};
	$self->AddHtml( '<br>Form submit testing<br>' );
	$self->AddHtml( '<form action="test" method="POST">Data1: <input type="text" name="data1" value="Some data" size="20"><br>Data2: <input type="text" name="data2" value="More data" size="20"><br><input type="submit" value="Submit"></form>' );
	$self->AddHtml( '<form action="test" method="POST"><input type="hidden" name="data4" value="Other data" size="20"><br>Data3: <input type="text" name="data3" value="More data..." size="20"><br><input type="submit" value="Submit"></form>' );
	$self->HtmlBodyBottom();
	return ();
};
#######################################################################################
#
# HtmlBodyTop :
#
# Input validation : NONE
#
#######################################################################################
sub HtmlBodyTop # () -> ()
{
	my ( $self ) = shift;
	my ( $gsection ) = GlobalSection->new();
	$self->AddHtml( '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">' . "\r\n" );
	$self->AddHtml( '<html>' . "\r\n" );
	$self->AddHtml( '<head>' . "\r\n" );
	$self->AddHtml( '<meta http-equiv="Pragma" content="no-cache" >' . "\r\n" );
	$self->AddHtml( '<meta http-equiv="Content-type" content="text/html;charset=UTF-8">' );
	$self->AddHtml( '<meta http-equiv="expires" content="-1" >' . "\r\n" );
	$self->AddHtml( '<meta name="Robots" content="noindex" >' . "\r\n" );
	$self->AddHtml( '<title>bck-backup</title>' . "\r\n" );
	$self->AddHtml( '<style type="text/css">' . "\r\n" );
	$self->AddHtml( '<!--' . "\r\n" );
	$self->AddHtml( 'body {' );
	$self->AddHtml( 'background: #CECECE;' );
	$self->AddHtml( 'color: #000000;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'bar {' );
	$self->AddHtml( 'border-color: rgb(255,0,0);' );
	$self->AddHtml( 'border: 0px;' );
	$self->AddHtml( 'padding: 0;' );
	$self->AddHtml( 'height: 2px;' );
	$self->AddHtml( 'margin: 0 0 0 0px;' );
	$self->AddHtml( 'overflow: hidden;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'a.menu {' );
	$self->AddHtml( 'color: #000099;' );
	$self->AddHtml( 'font-size: 1.3em;' );
	$self->AddHtml( 'font-weight: bold;text-decoration: none;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'a.line {' );
	$self->AddHtml( 'color: #000000;' );
	$self->AddHtml( 'font-size: 1em;' );
	$self->AddHtml( 'padding: 0px 5px 0px 5px;' );
	$self->AddHtml( 'font-weight: bold;text-decoration: none;' );
	$self->AddHtml( 'float: left;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.top {' );
	$self->AddHtml( 'background: #8080FF;' );
	$self->AddHtml( 'color: #000099;' );
	$self->AddHtml( 'padding: 10px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'div.subtitle {' );
	$self->AddHtml( 'font-size: 1.1em;' );
	$self->AddHtml( 'font-style: italic;' );
	$self->AddHtml( 'text-indent: 70px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'div.title {' );
	$self->AddHtml( 'font-size: 3.3em;' );
	$self->AddHtml( 'font-weight: bold;' );
	$self->AddHtml( 'text-indent: 70px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'table.main {' );
	$self->AddHtml( 'table-layout: fixed;' );
	$self->AddHtml( 'width: 100%;' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'border-collapse: collapse;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'table.list {' );
	$self->AddHtml( 'width: 100%;' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'border-color: #CECECE;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'border-collapse: collapse;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'span.menu {' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: top;' );
	$self->AddHtml( 'background: #8080FF;' );
	$self->AddHtml( 'padding: 6px;' );
	$self->AddHtml( 'margin: 6px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'table.lines {' );
	$self->AddHtml( 'width: 100%;' );
	$self->AddHtml( 'border-width: 2px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-collapse: collapse;' );
	$self->AddHtml( 'text-align: left;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'th.buttons {' );
	$self->AddHtml( 'border-width: 0px;' );
	$self->AddHtml( 'display:  block;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'input.button {' );
	$self->AddHtml( 'border-width: 2px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: outset;' );
	$self->AddHtml( 'background: #C0C0C0;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'padding: 0px;' );
	$self->AddHtml( 'margin: 0px;' );
	$self->AddHtml( 'height: 23px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'th.lines {' );
	$self->AddHtml( 'border-width: 2px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'background: #707070;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'font-size: 1em;' );
	$self->AddHtml( 'padding: 2px;' );
	$self->AddHtml( 'margin: 2px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'th.pages {' );
	$self->AddHtml( 'border-width: 2px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'background: rgb(255, 255, 204);' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'font-size: 1.5em;' );
	$self->AddHtml( 'font-weight: bold;' );
	$self->AddHtml( 'padding: 2px;' );
	$self->AddHtml( 'margin: 2px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.lines {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'height: 28px;' );
	$self->AddHtml( 'overflow: hidden;' );
	$self->AddHtml( 'padding: 2px;' );
	$self->AddHtml( 'margin: 2px;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.col {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-indent: 5px;' );
	$self->AddHtml( 'height: 28px;' );
	$self->AddHtml( 'padding: 2px;' );
	$self->AddHtml( 'margin: 2px;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( 'border-collapse: collapse;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'tr.header {' );
	$self->AddHtml( 'background: #F4FA58;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'tr.local {' );
	$self->AddHtml( 'background: #AEAEAE;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'tr.remote {' );
	$self->AddHtml( 'background: #58FAF4;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.green {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background-color: rgb(51, 255, 51);' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.red {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background-color: rgb(255, 0, 0);' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.orange {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background-color: rgb(255, 153, 0);' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.blue {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background-color: rgb(120,120,255);' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'text-align: center;' );
	$self->AddHtml( 'vertical-align: middle;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.menu {' );
	$self->AddHtml( 'border-width: 1px;' );
	$self->AddHtml( 'background: #707070;' );
	$self->AddHtml( 'border-color: #000000;' );
	$self->AddHtml( 'border-style: solid;' );
	$self->AddHtml( 'padding: 10px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'td.footer{' );
	$self->AddHtml( 'color: #202020;' );
	$self->AddHtml( 'background: #B0B0B0;' );
	$self->AddHtml( 'text-align: right;' );
	$self->AddHtml( 'font-size: 0.8em;' );
	$self->AddHtml( 'font-style: italic;' );
	$self->AddHtml( 'padding-right: 40px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'form.left{' );
	$self->AddHtml( 'float: left;' );
	$self->AddHtml( 'padding: 1px 1px 1px 1px;' );
	$self->AddHtml( 'margin: 0px 0px 0px 0px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( 'form.right{' );
	$self->AddHtml( 'float: right;' );
	$self->AddHtml( 'padding: 1px 1px 1px 1px;' );
	$self->AddHtml( 'margin: 0px 0px 0px 0px;' );
	$self->AddHtml( '}' . "\r\n" );
	$self->AddHtml( '-->' . "\r\n" );
	$self->AddHtml( '</style>' . "\r\n" );
	$self->AddHtml( '</head>' . "\r\n" );
	$self->AddHtml( '<body>' . "\r\n" );
	$self->AddHtml( '<table class="main">' . "\r\n" );
	$self->AddHtml( '<tr>' . "\r\n" );
	$self->AddHtml( '<td class="top">' . "\r\n" );
	$self->AddHtml( '<div class="title">bck-backup</div>' . "\r\n" );
	$self->AddHtml( "<div class=\"subtitle\"><b>Version</b> : $version" . "</div>\r\n" );
	$self->AddHtml( "<div class=\"subtitle\"><b>Configfile</b> : $self->{_configfile}" . "</div>\r\n" );
	$self->AddHtml( "<div class=\"subtitle\"><b>Instalation</b> : $gsection->{_client}" . "</div>\r\n" );
	$self->AddHtml( '</td>' . "\r\n" );
	$self->AddHtml( '</tr>' . "\r\n" );
	$self->AddHtml( '<tr>' . "\r\n" );
	$self->AddHtml( '<td class="menu">' . "\r\n" );
	$self->AddHtml( '<span class="menu"><a class="menu" href="/">Reports</a></span>' . "\r\n" );
	$self->AddHtml( '<span class="menu"><a class="menu" href="/logs">Logs</a></span>' . "\r\n" );
	$self->AddHtml( '<span class="menu"><a class="menu" href="/config">Config</a></span>' . "\r\n" );
	#$self->AddHtml( '<span class="menu"><a class="menu" href="/test">Test</a></span>' . "\r\n" );
	$self->AddHtml( '</td></tr>' . "\r\n" );
	$self->AddHtml( '<tr><td>' . "\r\n" );
	return();
}
#######################################################################################
#
# HtmlBodyBottom :
#
# Input validation : NONE
#
#######################################################################################
sub HtmlBodyBottom # () -> ()
{
	my ( $self ) = shift;
	$self->AddHtml( '</td>' . "\r\n" );
	$self->AddHtml( '</tr>' . "\r\n" );
	$self->AddHtml( '<tr><td class="footer">' . "\r\n" );
	$self->AddHtml( 'bck-backup Web interface' . "\r\n" );
	$self->AddHtml( "Running on : " . $Config{'osname'} . " / " . $Config{'osvers'} . " [" . $Config{'archname'} . "] , Perl version : v" . $Config{'PERL_REVISION'} . "." . $Config{'PERL_VERSION'} . "." . $Config{'PERL_SUBVERSION'} . "\r\n" );
	$self->AddHtml( '</td></tr>' . "\r\n" );
	$self->AddHtml( '</table>' . "\r\n" );
	$self->AddHtml( '</body>' . "\r\n" );
	$self->AddHtml( '</html>' . "\r\n" );
	return();
};
##################################################################################
# End Class HttpServer
####################################################################################################################################################################
##################################################################################
#
# Class CommandLine : Command line parameter storage class
#
# Input Validation : OK (Done by Config::Ini)
#
##################################################################################
package CommandLine;
use Getopt::Long;
#constructor
sub new
{	my ($class) = @_;
	my $self =
	{
		_verbose	=> undef,
		_configfile	=> undef,
		_install	=> undef,
		_update		=> undef,
		_check		=> undef,
		_debug		=> undef,
		_do		=> undef,
		_version	=> undef,
		_help		=> undef,
		_http		=> undef,
		_report		=> undef,
		_mail		=> undef,
		_statusfile	=> undef
	};
	bless $self, $class;
	return $self;
};
#accessor method for verbose
sub GetVerboseFlag {
	my ( $self ) = @_;
	return $self->{_verbose};
};
#accessor method for configfile
sub GetConfigFileName {
	my ( $self ) = @_;
	return $self->{_configfile};
};
#accessor method for configfile
sub GetStatusFileName {
	my ( $self ) = @_;
	return $self->{_statusfile};
};
#accessor method for install
sub GetInstallFlag {
	my ( $self ) = @_;
	return $self->{_install};
};
#accessor method for update
sub GetUpdateFlag {
	my ( $self ) = @_;
	return $self->{_update};
};
#accessor method for check
sub GetCheckFlag {
	my ( $self ) = @_;
	return $self->{_check};
};
#accessor method for debug
sub GetDebugFlag {
	my ( $self ) = @_;
	return $self->{_debug};
};
#accessor method for do
sub GetDo {
	my ( $self ) = @_;
	return $self->{_do};
};
#accessor method for version
sub GetVersionFlag {
	my ( $self ) = @_;
	return $self->{_version};
};
#accessor method for help
sub GetHelpFlag {
	my ( $self ) = @_;
	return $self->{_help};
};
#accessor method for http
sub GetHttpFlag {
	my ( $self ) = @_;
	return $self->{_http};
};
#accessor method for report
sub GetReportFlag {
	my ( $self ) = @_;
	return $self->{_report};
};
#accessor method for mail
sub GetMailFlag {
	my ( $self ) = @_;
	return $self->{_mail};
};
#parse command line and fill class
sub ParseCommandLine{ # () -> (ok)
	my ( $self ) = @_;
	my ( $ok, $verbose, $configfile, $langfile, $help, $version, $debug, $install, $check, $do, $httpserver, $reportserver, $report, $mail, $update);
	my ( $status ) = 0;
	$ok = @ARGV;
	if ( $ok > 0 )
	{
		GetOptions
		(
			'verbose'	=> \$verbose,
			'config-file=s'	=> \$configfile,
			'install'	=> \$install,
			'update'	=> \$update,
			'check'		=> \$check,
			'debug'		=> \$debug,
			'do=s'		=> \$do,
			'mail'		=> \$mail,
			'version'	=> \$version,
			'help|?'	=> \$help,
			'httpserver'=> \$httpserver,
			'reportserver'=> \$reportserver,
			'report'	=> \$report
		);
	}
	else
	{
		print "No parameters specified, check documentation.\nUse --help option for more information.\n";
		exit(0);
	};
	if (defined $mail)
	{
		$self->{_mail} = 1;
	}
	else
	{
		$self->{_mail} = 0;
	};
	if (defined $verbose)
	{
		$self->{_verbose} = 1;
	}
	else
	{
		$self->{_verbose} = 0;
	};
	if (defined $configfile)
	{
		$self->{_configfile} = $configfile;
		$self->{_statusfile} = $configfile;
		$self->{_statusfile} =~ s/\W//g;
	}
	else
	{
		$self->{_configfile} = "/etc/bck/bck.config";
		$self->{_statusfile} = "status";
	};
	if (defined $install)
	{
		$self->{_install} = 1;
	}
	else
	{
		$self->{_install} = 0;
	};
	if (defined $update)
	{
		$self->{_update} = 1;
	}
	else
	{
		$self->{_update} = 0;
	};
	if (defined $check)
	{
		$self->{_check} = 1;
	}
	else
	{
		$self->{_check} = 0;
	};
	if (defined $debug)
	{
		$self->{_debug} = 1;
		$self->{_verbose} = 0;
	}
	else
	{
		$self->{_debug} = 0;
	};
	if (defined $do)
	{
		$self->{_do} = $do;
	}
	else
	{
		$self->{_do} = undef;
	};
	if (defined $version)
	{
		$self->{_version} = 1;
		return (0);
	}
	else
	{
		$self->{_version} = 0;
	};
	if (defined $help)
	{
		$self->{_help} = 1;
		return (0);
	}
	else
	{
		$self->{_help} = 0;
	};
	if (defined $httpserver)
	{
		$self->{_http} = 1;
		if (defined $reportserver)
		{
			$self->{_http} = 3;
		};
		return (0);
	}
	else
	{
		$self->{_http} = 0;
		if (defined $reportserver)
		{
			$self->{_http} = 2;
		};
	};
	if (defined $report)
	{
		$self->{_report} = 1;
		return (0);
	}
	else
	{
		$self->{_report} = 0;
	};
	if ( not ( -f $self->{_configfile} ) )
	{
		print "Config file (" . $self->{_configfile} . ") does not exist, check documentation.\nUse --help option for more information.\n";
		exit(0);
	};
	if ( not ( -r $self->{_configfile} ) )
	{
		print "Config file (" . $self->{_configfile} . ") cannot be read, check file permissions.\nUse --help option for more information.\n";
		exit(0);
	};
	return($status);
};
##################################################################################
# End Class CommandLine
##################################################################################
##################################################################################
#
# Class GlobalSection : Global configuration file section class
#
##################################################################################
package GlobalSection;
sub new
{
	my ( $class ) = shift;
	my ( $configfilename)  =  $cmdln->GetConfigFileName();
	my ( $lang, $client, $sysloglevel, $winmsg, $mt, $tar, $smbmount, $smbumount, $smbclient );
	my ( $sudo, $rsync, $dvdrecord, $dvdformat, $cdrecord, $rsyncrypto, $ntpserver,$ipwebaddress );
	my ( $logdir,$spooldir,$tempdir, $oktag, $errortag, $warningtag );
	if (-r $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
		unless ($cfg)
		{
			die "Error in loading configuration file `$configfilename'\n Use --check option for detailed information\n";
		}
		$lang		= $cfg->val('global', 'lang');
		$client		= $cfg->val('global', 'client');
		$sysloglevel	= $cfg->val('global', 'sysloglevel');
		$winmsg		= $cfg->val('global', 'winmsg');
		$mt		= $cfg->val('global', 'mt');
		$tar		= $cfg->val('global', 'tar');
		$smbmount	= $cfg->val('global', 'smbmount');
		$smbumount	= $cfg->val('global', 'smbumount');
		$smbclient	= $cfg->val('global', 'smbclient');
		$sudo		= $cfg->val('global', 'sudo');
		$rsync		= $cfg->val('global', 'rsync');
		$dvdrecord	= $cfg->val('global', 'dvdrecord');
		$dvdformat	= $cfg->val('global', 'dvdformat');
		$cdrecord	= $cfg->val('global', 'cdrecord');
		$rsyncrypto	= $cfg->val('global', 'rsyncrypto');
		$ntpserver	= $cfg->val('global', 'ntpserver');
		$ipwebaddress	= $cfg->val('global', 'ipwebaddress');
		$logdir		= $cfg->val('global', 'logdir');
		$spooldir	= $cfg->val('global', 'spooldir');
		$tempdir	= $cfg->val('global', 'tempdir');
		$oktag		= $cfg->val('global', 'oktag');
		$errortag	= $cfg->val('global', 'errortag');
		$warningtag	= $cfg->val('global', 'warningtag');
	};
	my $self =
	{
		_lang		=> $lang,
		_client		=> $client,
		_sysloglevel => $sysloglevel,
		_winmsg		=> $winmsg,
		_mt			=> $mt,
		_tar		=> $tar,
		_smbmount	=> $smbmount,
		_smbumount	=> $smbumount,
		_smbclient	=> $smbclient,
		_sudo		=> $sudo,
		_rsync		=> $rsync,
		_cdrecord	=> $cdrecord,
		_dvdrecord	=> $dvdrecord,
		_dvdformat	=> $dvdformat,
		_rsyncrypto	=> $rsyncrypto,
		_ntpserver	=> $ntpserver,
		_ipwebaddress	=> $ipwebaddress,
		_logdir		=> $logdir,
		_spooldir	=> $spooldir,
		_tempdir	=> $tempdir,
		_oktag		=> $oktag,
		_errortag	=> $errortag,
		_warningtag => $warningtag
	};
	bless $self, $class;
	return $self;
};
#accessor method for oktag
sub GetOktag
{
	my ( $self ) = shift;
	return $self->{_oktag};
};
#accessor method for errortag
sub GetErrortag
{
	my ( $self ) = shift;
	return $self->{_errortag};
};
#accessor method for warningtag
sub GetWarningtag
{
	my ( $self ) = shift;
	return $self->{_warningtag};
};
#accessor method for tempdir
sub GetTempDir
{
	my ( $self ) = shift;
	return $self->{_tempdir};
};
#accessor method for logdir
sub GetLogDir
{
	my ( $self ) = shift;
	return $self->{_logdir};
};
#accessor method for spooldir
sub GetSpoolDir
{
	my ( $self ) = shift;
	return $self->{_spooldir};
};
#accessor method for lang
sub GetLang
{
	my ( $self ) = shift;
	return $self->{_lang};
};
#accessor method for client
sub GetClient
{
	my ( $self ) = shift;
	return $self->{_client};
};
#accessor method for sysloglevel
sub GetSysLogLevel
{
	my ( $self ) = shift;
	return $self->{_sysloglevel};
};
#accessor method for winmsg
sub GetWinMsg
{
	my ( $self ) = shift;
	return $self->{_winmsg};
};
#accessor method for mt
sub GetMt
{
	my ( $self ) = shift;
	return $self->{_mt};
};
#accessor method for tar
sub GetTar
{
	my ( $self ) = shift;
	return $self->{_tar};
};
#accessor method for smbmount
sub GetSmbMount
{
	my ( $self ) = shift;
	return $self->{_smbmount};
};
#accessor method for smbumount
sub GetSmbUmount
{
	my ( $self ) = shift;
	return $self->{_smbumount};
};
#accessor method for smbclient
sub GetSmbClient
{
	my ( $self ) = shift;
	return $self->{_smbclient};
};
#accessor method for sudo
sub GetSudo
{
	my ( $self ) = shift;
	return $self->{_sudo};
};
#accessor method for rsync
sub GetRsync
{
	my ( $self ) = shift;
	return $self->{_rsync};
};
#accessor method for dvdrecord
sub GetDvdRecord
{
	my ( $self ) = shift;
	return $self->{_dvdrecord};
};
#accessor method for dvdformat
sub GetDvdFormat
{
	my ( $self ) = shift;
	return $self->{_dvdformat};
};
#accessor method for cdrecord
sub GetCdRecord
{
	my ( $self ) = shift;
	return $self->{_cdrecord};
};
#accessor method for rsyncrypto
sub GetRsyncrypto
{
	my ( $self ) = shift;
	return $self->{_rsyncrypto};
};
#accessor method for ntpserver
sub GetNtpServer
{
	my ( $self ) = shift;
	return $self->{_ntpserver};
};
#accessor method for webipaddress
sub GetIpWebAddress
{
	my ( $self ) = shift;
	return $self->{_ipwebaddress};
};
##################################################################################
# End Class GlobalSection
##################################################################################
##################################################################################
#
# Class HttpSection : Http configuration file section class
#
##################################################################################
package HttpSection;
sub new
{
	my ($class) = shift;
	my ($configfilename) =  $cmdln->GetConfigFileName();
	my ($user, $password, $reportlines, $backupuser, $backuppass);
	if (-r $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
		unless ($cfg)
		{
			die "Error in loading configuration file `$configfilename'\n Use --check option for detailed information\n";
		}
		$user			= $cfg->val('http', 'user');
		$password		= $cfg->val('http', 'pass');
		$reportlines	= $cfg->val('http', 'reportlines');
		$backupuser		= $cfg->val('http', 'backupuser');
		$backuppass		= $cfg->val('http', 'backuppass');
	};
	my $self =
	{
		_user			=> $user,
		_password		=> $password,
		_reportlines	=> $reportlines,
		_backupuser		=> $backupuser,
		_backuppass		=> $backuppass
	};
	bless $self, $class;
	return $self;
};
#accessor method for user
sub GetUser
{
	my ( $self ) = shift;
	return $self->{_user};
};
#accessor method for password
sub GetPassword
{
	my ( $self ) = shift;
	return $self->{_password};
};
#accessor method for backup user
sub GetBackupUser
{
	my ( $self ) = shift;
	return $self->{_backupuser};
};
#accessor method for backup password
sub GetBackupPassword
{
	my ( $self ) = shift;
	return $self->{_backuppass};
};
#accessor method for reportlines
sub GetReportlines
{
	my ( $self ) = shift;
	return $self->{_reportlines};
};
##################################################################################
# End Class http Section
##################################################################################
##################################################################################
#
# Class ReportSection : Http configuration file section class
#
##################################################################################
package ReportSection;
sub new
{
	my ($class) = shift;
	my ($configfilename) =  $cmdln->GetConfigFileName();
	my ($server, $port, $password, $serverauth);
	if (-r $configfilename )
	{
		my ( $cfg, $mastercfg );
		if ( -r "/etc/bck/bck.default" )
		{
			  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
			  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
		}
		else
		{
			$cfg 	= Config::IniFiles->new( -file => $configfilename );
		};
		unless ($cfg)
		{
			die "Error in loading configuration file `$configfilename'\n Use --check option for detailed information\n";
		}
		$server			= $cfg->val('report', 'server');
		$port			= $cfg->val('report', 'port');
		$password		= $cfg->val('report', 'password');
		$serverauth		= $cfg->val('report', 'serverauth');
	};
	my $self =
	{
		_server			=> $server,
		_port			=> $port,
		_password		=> $password,
		_serverauth		=> $serverauth
	};
	bless $self, $class;
	return $self;
};
#accessor method for server
sub GetServer
{
	my ( $self ) = shift;
	return $self->{_server};
};
#accessor method for port
sub GetPort
{
	my ( $self ) = shift;
	return $self->{_port};
};
#accessor method for password
sub GetPassword
{
	my ( $self ) = shift;
	return $self->{_password};
};
#accessor method for password
sub GetServerAuth
{
	my ( $self ) = shift;
	return $self->{_serverauth};
};
##################################################################################
# End Class report Section
##################################################################################
##################################################################################
#
# Class TableFile : Read/Write table file class
#
##################################################################################
#
# status table field def:
#
# |Status bits|,|Section Name|,|Section Description|,|Timestamp|,|Status|,|Size|,|Dest size|,|Dest free|
#      |                                                 |          |       |         |         |
#      |                                                 |          |       |         |         -> Bytes free on destination
#      |                                                 |          |       |         -> Size of destination in bytes
#      |                                                 |          |       -> Size of setion
#      |                                                 |          -> Text field status [OK, ERROR, Warning]
#      |                                                 -> Internal timestamp format ddmmyyyyhhmm
#      -> 8 bits [7 6 5 4 3 2 1 0]
#         Bit 0 : 0-Not send by mail            1-Send by mail                 (1)
#         Bit 1 : 0-Not send to remote server   1-Send to remote server        (2)
#         Bit 2 : 0-Line                        1-Header                       (4)
#         Bit 3&4 : 00-OK  01-Warning  10-ERROR  11-Not Available [Defines color used in Status column] (8&16)
#         Bit 5 : 0-Finished		1-In progress                                      (32)
#         Bit 6 : 0-No alarm               1-Alarm                                               (64)
#         Bit 7 : 0-Local 1-Remote                                             (128)
#
##################################################################################
package TableFile;
# We use tied arrays as this allows us to modify anywhere in the file
use Tie::File;
sub new
{
	my ( $class ) = shift;
	my $self =
	{
		# Public values
		_file		=> undef, # string :path/filename of tablefile
		_mailrep	=> 0, # 1 bit  -
		_commrep	=> 0, # 1 bit   |
		_isheader	=> 0, # 1 bit   |-> statusbits [ 8 bits ]
		_status		=> 0, # 2 bits  |
		_alarm		=> 0, # 1 bit   |
		_finished	=> 0, # 1 bit  |
		_isremote	=> 0, # 1 bit  -
		_section	=> "", # string
		_name		=> "", # string
		_timestamp	=> 0, # string : Internal timestamp (will change to unix timestamp)
		_statustext	=> "", # string
		_size		=> 0, # integer
		_destsize	=> 0, # integer
		_destfree	=> 0, # integer
		# Private values
		_statusbits	=> 0  # bit array as defined above
	};
	bless $self, $class;
	return $self;
};
#######################################################################################
#
# ReadLast : Read the last n lines and return an array, used for web interface
#
# Input validation : OK (BV 11/07/2009)
#
#######################################################################################
sub ReadLast # ( numlines, page ) -> ( @lines )
{
	my ( $self ) = shift;
	my ( $numlines ) = shift;
	my ( $page ) = shift;
	my ( $line, $date, @lines, @lastlines );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	# Get the number of lines in the file
	my ( $totallines ) = scalar @lines;
	$page = 1 unless $page;
	my ( $firstline ) = ( $page - 1 ) * $numlines;
	my ( $lastline ) = $firstline + $numlines;
	my ( $counter ) = $firstline;
	# Check that we don't get more lines than in file
	if ( $lastline > $totallines )
	{
		$lastline = $totallines;
	};
	# Get the lines from the end of the file
	while ( $counter < $lastline )
	{
		# Get the line
		$line = $lines[ ( $totallines - 1 ) - $counter ];
		# validate the line
		$line = ::StrCl( $line );
		# Split into variables
		my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree ) = split( /,/,$line );
		# Validate the file data read
		$line = ::StrCl( $line );
		$statusbits = ::StrCl( $statusbits );
		$section = ::StrCl( $section );
		$name = ::StrCl( $name );
		$timestamp = ::NumCl( $timestamp );
		$statustext = ::StrCl( $statustext );
		$size = ::NumCl( $size );
		$destsize = ::NumCl( $destsize );
		$destfree = ::NumCl( $destfree );
		# Prepare the variables in one line
		$line = $statusbits . "," . $section . "," . $name . "," . $timestamp . "," . $statustext . "," . $size . "," . $destsize . "," . $destfree . "," . ( ( $totallines - 1 ) - $counter );
		# Put them in our array
		push( @lastlines,  $line );
		# Count lines
		$counter++;
	};
	undef $ar;
	untie @lines;
	return( @lastlines );
};
#######################################################################################
#
# GetNumLines : Get the number of lines in the file
#
# Input validation : PENDING!
#
#######################################################################################
sub GetNumLines # ( ) -> ( $numlines )
{
	my ( $self ) = shift;
	my ( @lines );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	# Get the number of lines in the file
	my ( $totallines ) = scalar @lines;
	undef $ar;
	untie @lines;
	return( $totallines );
};
#######################################################################################
#
# AddLine : Add line to end of file
#
# Input validation : PENDING!
#
#######################################################################################
sub AddLine # ( ) -> ( )
{
	my ( $self ) = shift;
	my ( $line, @lines );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	$ar->flock();
	$line = $self->{_statusbits} . "," . $self->{_section} . "," . $self->{_name} . "," . $self->{_timestamp} . "," . $self->{_statustext} . "," . $self->{_size} . "," . $self->{_destsize} . "," . $self->{_destfree};
	push( @lines, $line );
	undef $ar;
	untie @lines;
	return();
};
#######################################################################################
#
# WriteLine : Write line number $linenum in place
#
# Input validation : PENDING!
#
#######################################################################################
sub WriteLine # ( $linenum  ) -> () 
{
	my ( $self ) = shift;
	my ( $linenum ) = shift;
	my ( @lines );
	# Tie the file to an array
	my ( $line );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	$ar->flock();
	$line = $self->{_statusbits} . "," . $self->{_section} . "," . $self->{_name} . "," . $self->{_timestamp} . "," . $self->{_statustext} . "," . $self->{_size} . "," . $self->{_destsize} . "," . $self->{_destfree};
	$lines[ $linenum ] = $line;
	undef $ar;
	untie @lines;
	return();
};
#######################################################################################
#
# ReadLine : Read line number "n"
#
# Input validation : OK (BV 11/7/2009)
#
#######################################################################################
sub ReadLine # ( $linenum  ) -> ( $line ) 
{
	my ( $self ) = shift;
	my ( $linenum ) = shift;
	my ( $line, @lines );
	# Tie the file to an array
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	$line = $lines[ $linenum ];
	undef $ar;
	untie @lines;
	chomp( $line );
	# Validate the line read
	$line = ::StrCl( $line );
	( $self->{_statusbits}, $self->{_section}, $self->{_name}, $self->{_timestamp}, $self->{_statustext}, $self->{_size}, $self->{_destsize}, $self->{_destfree} ) = split( /,/, $line );
	# Validate the file data read
	$self->{_statusbits} = ::StrCl( $self->{_statusbits} );
	$self->{_section} = ::StrCl( $self->{_section} );
	$self->{_name} = ::StrCl( $self->{_name} );
	$self->{_timestamp} = ::NumCl( $self->{_timestamp} );
	$self->{_statustext} = ::StrCl( $self->{_statustext} );
	$self->{_size} = ::NumCl( $self->{_size} );
	$self->{_destsize} = ::NumCl( $self->{_destsize} );
	$self->{_destfree} = ::NumCl( $self->{_destfree} );
	return( $line );
};
#######################################################################################
#
# FindLines : Get a list of lines with bit $bit set, added the line number as the first
#             element in the array
#
# Input validation : PENDING!
#
#######################################################################################
sub FindLines # ( $bit, $bitvalue ) -> ( @lines )
{
	my ( $self ) = shift;
	my ( $bit ) = shift;
	my ( $bitvalue ) = shift; # TRUE or FALSE
	# Convert bit position to the byte with bit set
	$bit = ( 2 ** $bit );
	my ( $line, @lines, @pendinglines );
	my ( $counter ) = 0;
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	foreach $line ( @lines )
	{
		# Validate the lines read
		$line = ::StrCl( $line );
		my ( $statusbits, $section, $name, $timestamp, $statustext, $size, $destsize, $destfree ) = split( /,/,$line );
		# Validate the values read
		$statusbits = ::NumCl( $statusbits );
		$section = ::StrCl( $section );
		$name = ::StrCl( $name );
		$timestamp = ::NumCl( $timestamp );
		$statustext = ::StrCl( $statustext );
		$size = ::NumCl( $size );
		$destsize = ::NumCl( $destsize );
		$destfree = ::NumCl( $destfree );
		if ( ( $statusbits & $bit ) == $bitvalue ) # check if bit 0 set
		{
			push( @pendinglines, ( $counter . "," . $line ) );
		};
		$counter++;
	};
	undef $ar;
	untie @lines;
	return( @pendinglines );
};
#######################################################################################
#
# UpdateStatusBits
#
# Input validation : PENDING!
#
#######################################################################################
sub UpdateStatusBits # ( $bit, $bitvalue, \@lines ) -> ()
{
	my ( $self ) = shift;
	my ( $bit ) = shift;
	my ( $bitvalue ) = shift;
	my ( $updatelines ) = shift;
	my ( @lines );
	my ( $ar ) = tie @lines, 'Tie::File', $self->{_file};
	$ar->flock();
	$bit = ( 2 ** $bit );
	foreach my $line ( @{$updatelines} )
	{
		my ( $id );
		( $id, $self->{_statusbits}, $self->{_section}, $self->{_name}, $self->{_timestamp}, $self->{_statustext}, $self->{_size}, $self->{_destsize}, $self->{_destfree} ) = split( /,/, $line );
		if  ( $bitvalue eq 1 )
		{
			$self->{_statusbits} = ( $self->{_statusbits} | $bit );
		}
		else
		{
			$self->{_statusbits} = ( $self->{_statusbits} ^ $bit );
		}
		$line = $self->{_statusbits} . "," . $self->{_section} . "," . $self->{_name} . "," . $self->{_timestamp} . "," . $self->{_statustext} . "," . $self->{_size} . "," . $self->{_destsize} . "," . $self->{_destfree};
		$lines[ $id ] = $line;	
	};
	undef $ar;
	untie @lines;
	return()
};
sub SetFile
{
	my ( $self ) = shift;
	$self->{_file} = shift;
	return();
};
sub SetMailrep
{
	my ( $self ) = shift;
	$self->{_mailrep} = shift;
	if ( $self->{_mailrep} eq 1 )
	{
		# Set bit 0 to 1
		$self->{_statusbits} = $self->{_statusbits} | 1
	}
	else
	{
		# Set bit 0 to 0
		$self->{_statusbits} = $self->{_statusbits} ^ 1
	};
	return();
};
sub SetCommrep
{
	my ( $self ) = shift;
	$self->{_commrep} = shift;
	if ( $self->{_commrep} eq 1 )
	{
		# Set bit 1 to 1
		$self->{_statusbits} = $self->{_statusbits} | 2
	}
	else
	{
		# Set bit 1 to 0
		$self->{_statusbits} = $self->{_statusbits} ^ 2
	};
	return();
};
sub SetIsHeader
{
	my ( $self ) = shift;
	$self->{_isheader} = shift;
	if ( $self->{_isheader} eq 1 )
	{
		# Set bit 2 to 1
		$self->{_statusbits} = $self->{_statusbits} | 4
	}
	else
	{
		# Set bit 2 to 0
		$self->{_statusbits} = $self->{_statusbits} ^ 4
	};
	return();
};
sub SetStatus
{
	my ( $self ) = shift;
	$self->{_status} = shift;
	# Shift the bits into position
	my ( $var ) = $self->{_status} << 3;
	# Set bits 3 & 4 to 0
	$self->{_statusbits} = $self->{_statusbits} & 231;
	# Set bits 3 & 4
	$self->{_statusbits} = $self->{_statusbits} | $var;
	return();
};
sub SetIsRemote
{
	my ( $self ) = shift;
	$self->{_isremote} = shift;
	if ( $self->{_isremote} eq 1 )
	{
		# Set bit 7 to 1
		$self->{_statusbits} = $self->{_statusbits} | 128
	}
	else
	{
		# Set bit 7 to 0
		$self->{_statusbits} = $self->{_statusbits} ^ 128
	};
	return();
};
sub SetName
{
	my ( $self ) = shift;
	$self->{_name} = shift;
	return();
};
sub SetSection
{
	my ( $self ) = shift;
	$self->{_section} = shift;
	return();
};
sub SetTimeStamp
{
	my ( $self ) = shift;
	$self->{_timestamp} = shift;
	return();
};
sub SetStatusText
{
	my ( $self ) = shift;
	$self->{_statustext} = shift;
	return();
};
sub SetSize
{
	my ( $self ) = shift;
	$self->{_size} = shift;
	return();
};
sub SetDestSize
{
	my ( $self ) = shift;
	$self->{_destsize} = shift;
	return();
};
sub SetDestFree
{
	my ( $self ) = shift;
	$self->{_destfree} = shift;
	return();
};
sub GetFile
{
	my ( $self ) = shift;
	return( $self->{_file} );
};
sub GetMailrep
{
	my ( $self ) = shift;
	return( $self->{_mailrep} );
};
sub GetCommrep
{
	my ( $self ) = shift;
	return( $self->{_commrep} );
};
sub GetIsHeader
{
	my ( $self ) = shift;
	return( $self->{_isheader} );
};
sub GetStatus
{
	my ( $self ) = shift;
	return( $self->{_status} );
};
sub GetIsRemote
{
	my ( $self ) = shift;
	return( $self->{_isremote} );
};
sub GetName
{
	my ( $self ) = shift;
	return( $self->{_name} );
};
sub GetSection
{
	my ( $self ) = shift;
	return( $self->{_section} );
};
sub GetTimeStamp
{
	my ( $self ) = shift;
	return( $self->{_timestamp} );
};
sub GetHTimeStamp
{
	my ( $self ) = shift;
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( $self->{_timestamp} );
	my ($date ) = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . sprintf( "%02d:%02d:%02d" , $hour, $min, $sec );
	return( $date );
};
sub GetStatusText
{
	my ( $self ) = shift;
	return( $self->{_statustext} );
};
sub GetSize
{
	my ( $self ) = shift;
	return( $self->{_size} );
};
sub GetDestSize
{
	my ( $self ) = shift;
	return( $self->{_destsize} );
};
sub GetDestFree
{
	my ( $self ) = shift;
	return( $self->{_destfree} );
};
##################################################################################
# End Class TableFile
##################################################################################
##################################################################################
#
# Class DoSection : Backup command block class
#
##################################################################################
package DoSection;
use File::Path;
use File::Copy;
use File::Temp qw/ tempfile tempdir /;
our @ISA = qw( TableFile );	# inherits from TableFile
sub new
{
	my ($class) = shift;
	my $self =
	{
		_section 	=> undef,
		_name 	 	=> undef,
		_type		=> undef,
		_sourcelist	=> undef,
		_excludelist => undef,
		_dest		=> undef,
		_cmd		=> undef,
		_maxsize	=> -1,
		_user		=> undef,
		_pass		=> undef,
		_status   	=> 0,
		_warning	=> 0,
		_error	  	=> 0,
		_medium 	=> undef,
	   	_size	   	=> 0,
		_flagsize	=> undef,
		_flagfail	=> undef,
		_logdate	=> undef,
		_starttime  => undef,
		_endtime	=> undef,
		_debug	  	=> undef,
		_verbose	=> undef,
		_html		=> "0",
		_histdirs	=> undef,
		_eject		=> undef,
		_options	=> undef,
		_cypher		=> undef,
		_cert		=> undef,
		_destsize	=> 0,
		_destfree	=> 0
		};
	bless $self, $class;
	return $self;
};
#load method for section load from file
sub LoadSection
{
	my ( $self ) = shift;
	my ( $configfilename ) = @_;
	my ( $cfg, $mastercfg );
	if ( -r "/etc/bck/bck.default" )
	{
		  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
		  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
	}
	else
	{
		$cfg 	= Config::IniFiles->new( -file => $configfilename );
	};
	if ($cfg->SectionExists ( $self->{_section} ) )
	{
		$self->{_name}		= $cfg->val($self->{_section}, 'name');
		$self->{_type}		= $cfg->val($self->{_section}, 'type');
		$self->{_sourcelist}	= $cfg->val($self->{_section}, 'sourcelist');
		$self->{_excludelist} 	= $cfg->val($self->{_section}, 'excludelist');
		$self->{_dest}		= $cfg->val($self->{_section}, 'dest');
		$self->{_maxsize}	= $cfg->val($self->{_section}, 'maxsize');
		$self->{_cmd}		= $cfg->val($self->{_section}, 'cmd');
		$self->{_user}		= $cfg->val($self->{_section}, 'user');
		$self->{_pass}		= $cfg->val($self->{_section}, 'pass');
		$self->{_medium} 	= $cfg->val($self->{_section}, 'medium');
		$self->{_histdirs}  = $cfg->val($self->{_section}, 'histdirs');
		$self->{_eject}  	= $cfg->val($self->{_section}, 'eject');
		$self->{_cypher}  	= $cfg->val($self->{_section}, 'cypher');
		$self->{_cert}  	= $cfg->val($self->{_section}, 'cert');
		$self->{_options}	= $cfg->val($self->{_section}, 'options');
		if ( not ( defined $self->{_cypher} ) )
		{
			$self->{_cypher} = "no";
		}
		return (0);
	}
	else
	{
		return(1);
	};
};
#accessor method for section
sub SetSection
{
	my ( $self ) = shift;
	my ( $section ) = @_;
	$self->{_section} = $section if defined($section);
};
#accessor method for starttime
sub SetStarttime
{
	my ( $self ) = shift;
	my ( $starttime ) = @_;
	$self->{_starttime} = $starttime if defined($starttime);
};
#accessor method for endtime
sub SetEndtime
{
	my ( $self ) = shift;
	my ( $endtime ) = @_;
	$self->{_endtime} = $endtime if defined($endtime);
};
#accessor method for starttime
sub GetStarttime
{
	my ( $self ) = shift;
	return( $self->{_starttime} );
};
#accessor method for endtime
sub GetEndtime
{
	my ( $self ) = shift;
	return( $self->{_endtime} );
};
#accessor method for logdate
sub SetLogDate
{
	my ( $self ) = shift;
	my ( $logdate ) = @_;
	$self->{_logdate} = $logdate if defined($logdate);
};
#accessor method for logdate
sub GetLogDate
{
	my ( $self ) = shift;
	return ( $self->{_logdate} );
};
#accessor method for section
sub GetSection
{
	my ( $self ) = shift;
	return $self->{_section};
};
#accessor method for medium
sub GetMedium
{
	my ( $self ) = shift;
	return $self->{_medium};
};
#accessor method for eject
sub GetEject
{
	my ( $self ) = shift;
	return $self->{_eject};
};
#accessor method for cypher
sub GetCypher
{
	my ( $self ) = shift;
	return $self->{_cypher};
};
#accessor method for options
sub GetOptions
{
	my ( $self ) = shift;
	return $self->{_options};
};
#accessor method for name
sub GetName
{
	my ( $self ) = shift;
	return $self->{_name};
};
#accessor method for user
sub GetUser
{
	my ( $self ) = shift;
	return $self->{_user};
};
#accessor method for pass
sub GetPass
{
	my ( $self ) = shift;
	return $self->{_pass};
};
#accessor method for status
sub SetStatus
{
	my ( $self ) = shift;
	my ( $status ) = @_;
	$self->{_status} = $status if defined($status);
};
#accessor method for status
sub GetStatus
{
	my ( $self ) = shift;
	return $self->{_status};
};
#accessor method for type
sub GetType
{
	my ( $self ) = shift;
	return $self->{_type};
};
#accessor method for size
sub GetDestsize
{
	my ( $self ) = shift;
	return $self->{_destsize};
};
#accessor method for size
sub GetDestfree
{
	my ( $self ) = shift;
	return $self->{_destfree};
};
#accessor method for size
sub GetSize
{
	my ( $self ) = shift;
	return $self->{_size};
};
#accessor method for maxsize
sub GetMaxSize
{
	my ( $self ) = shift;
	return $self->{_maxsize};
};
sub DebugPrint
{
	my ( $self ) = shift;
	my ( $string ) = @_;
	if ( $self->{_debug} )
	{
		print $string . "\n";
	};
};
sub HtmlPrint
{
	my ( $self ) = shift;
	my ( $string ) = @_;
	chomp( $string );
	$string .= "<br>";
	if ( $self->{_html} )
	{
		printf ( "%x\r\n" , ( length( $string )  ) );
		print "$string" . "\r\n";
	};
};
sub VerbosePrint
{
	my ( $self ) = shift;
	my ( $string ) = @_;
	if ( $self->{_verbose} )
	{
		if ( ! $self->{_debug} )
		{
			print $string . "\n";
		};
	};
};
#accessor method for debug
sub SetDebug
{
	my ( $self ) = shift;
	my ( $debug ) = @_;
	$self->{_debug} = $debug;
};
#accessor method for debug
sub SetVerbose
{
	my ( $self ) = shift;
	my ( $verbose ) = @_;
	$self->{_verbose} = $verbose;
};
sub SetHtml
{
	my ( $self ) = shift;
	my ( $html ) = @_;
	$self->{_html} = $html;
};
sub WriteLog
{
	my ( $self ) = shift;
	my ( $text, $lvl ) = @_;
	if ( defined $self->{_logdate} )
	{
		$self->DebugPrint( $text );
		$self->HtmlPrint( $text . "\r\n");
		if ( $lvl lt "2" )
		{
			$self->VerbosePrint( $text );
		};
		open ( LOGFILE, ">>" . $gsection->GetLogDir() . '/' . $self->{_section} . '.' . $self->{_logdate} . ".log" );
	   	print LOGFILE $text . "\n";
		close( LOGFILE );
	};
};
sub WriteList
{
	my ( $self ) = shift;
	my ( $text ) = @_;
	if ( defined $self->{_logdate} )
	{
		$self->DebugPrint( $text );
		$self->HtmlPrint( $text );
		open ( LOGFILE, ">>" . $gsection->GetLogDir() . '/' . $self->{_section} . '.' . $self->{_logdate} . ".lst" );
	   	print LOGFILE $text . "\n";
		close( LOGFILE );
	};
};
sub LabelDir
{
	my ( $self ) = shift;
	my ( $dir, $label ) = @_;
	my ( $filename ) = $dir . "/__LABEL__";
	open ( LABELFILE, ">". $filename );
	print LABELFILE $label;
	close( LABELFILE );
	return(0);
};
sub SetMarkFile
{
	my ( $self ) = shift;
	my ( $date );
	my ( $statusfile ) = $cmdln->GetStatusFileName;
	$date = $self->GetLogDate();
	open ( MARKFILE, ">>" . $gsection->GetSpoolDir() . '/' . "$statusfile" . '.mkr' );
	print MARKFILE  "0," . $self->GetSection() . "," . $self->GetName() . "," . $date . "\n";
	close ( MARKFILE );
};
sub DeleteMarkFile
{
	my ( $self ) = shift;
	my ( $statusfile ) = $cmdln->GetStatusFileName;
	unlink($gsection->GetSpoolDir() . '/' . "$statusfile" . '.mkr' );
};
##################################################################################
sub WriteTable
{
	my ( $self ) = shift;
	my ( $status, $date );
	my ( $table ) = TableFile->new();
	my ( $statusfile ) =  $cmdln->GetStatusFileName();
	$table->SetFile( $gsection->GetSpoolDir() . '/'  . "$statusfile" . '.tbl' );
	$date = $self->GetLogDate();
	if ( defined $self->GetName() )
	{
		$status = "OK";
		$table->SetStatus( 0 );
	}
	else
	{
		$status = "INVALID";
		$self->{_name} = " ";
		$self->{_size} = "0";
		$table->SetStatus( 3 ); # 11
	};
	if ( $self->{_warning} == 1 )
	{
		$status = "Warning";
		$table->SetStatus( 1 ); # 01
	};
	if ( $self->{_error} == 1 )
	{
		$status = "ERROR";
		$table->SetStatus( 2 ); # 10
	};
	$table->SetSection( $self->GetSection() );
	$table->SetName( $self->GetName() );
	$table->SetTimeStamp( $date );
	$table->SetStatusText( $status );
	$table->SetSize( $self->{_size} );
	$table->SetDestSize( $self->{_destsize} );
	$table->SetDestFree( $self->{_destfree} );
	$table->AddLine();
	return (0);
};
##################################################################################
sub CalcSpaceleft
{
	my ( $self ) = shift;
	my ( $dest ) = @_;
	my  ( $status ) = 0;
	if ( -e $dest )
	{
	   	my( $data, $cmd, $dfline);
		$cmd = 'df --block-size 1 ' . $dest;
		$self->WriteLog( "Command : " . $cmd , 3 );
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		if ( $status == 0 )
		{
	  		while ( defined ( my $line = <DATA> )  )
	   		{
	   			chomp($line);
				$self->WriteLog( $line , 2 );
				$dfline = $line;
	   		};
	   		close DATA;
	   		$status = $? >> 8;
   		};
		$self->WriteLog( "Exit status : " . $status , 3 );
		if ($status == 0)
		{
#				$dfline =~ s/\s\s/./g;
				my ( @retval ) = split(/\s+/,$dfline);
				$self->{_destsize} = ( $retval[1] );
				$self->{_destfree} = ( $retval[3] );
		 }
		 else
		 {
			 $self->{_warning} = 1;

		};
	}
	else
	{
		#dest not valid
		$self->{_destsize} = 0;
		$self->{_destfree} = 0;
	};
	$self->WriteLog( "Destination (" . $self->{_dest} . ") total: " . $self->{_destsize} . " bytes, space left: " . $self->{_destfree} . " bytes.", 1 );
	return ( 0 );
};
############################################################################
sub WinMsg # (share,text) -> ()
{
	my ( $self ) = shift;
	my (  $text ) = @_;
	my ( $cmd, $share );
	my ( $status ) = 0;
	if ( $gsection->GetWinMsg eq "yes" )
	{
		$share = $self->{_dest};
		$share =~ m/\/\/(.*)\//i; # Este regex extraye el nombre de maquina del recurso y lo mete en $1
		$cmd = "echo \"$text\" | smbclient -M $1 -U BCK-Backup";
		$self->WriteLog( "Command : " . $cmd , 3 );
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		if ( $status == 0 )
		{
  			while ( defined ( my $line = <DATA> )  )
   			{
   				chomp($line);
				$self->WriteLog( $line , 2 );
   			};
   			close DATA;
	   		$status = $? >> 8;
  		};
		$self->WriteLog( "Exit status : " . $status , 3 );
		if ($status == 0)
		{
			$self->WriteLog( "Msg sent to $1 : $text" , 3 );
		}
		else
		{
			$self->WriteLog( "Msg NOT sent to $1 : $text" , 3 );
		};
	};
	return ( 0 );
};

##################################################################################
sub CalcSize
{
	my ( $self ) = shift;
	my  ( $status ) = 0;
	# if maxsize is set to -1, do not check size before backup
	if ( not defined $self->{_maxsize} )
	{
		$self->{_maxsize} = 0;
	}
	if ( $self->{_maxsize} != -1 )
	{
		$self->HtmlPrint( "Calculating size for section [" . $self->{_section} . "]" );
		$self->DebugPrint( "Calculating size for section [" . $self->{_section} . "]" );
		$self->VerbosePrint( "Calculating size for section [" . $self->{_section} . "]" );
		if ( defined $self->{_sourcelist} )
		{
			my ( $excludelist ) = '';
			if ( defined $self->{_excludelist} )
			{
				my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
				my ( $exclude );
				foreach $exclude (@excludes)
				{
					$excludelist = $excludelist . ' --exclude=' . $exclude;
				};
			};
			my ( $sourcelist ) = '';
			my ( @sources ) = split(/[,\n]/,$self->{_sourcelist});
			my ( $source );
			my ( $size ) = 0;
			my ( $notempty ) = 0;
			foreach $source (@sources)
			{
				if (-e $source)
				{
					$sourcelist = $sourcelist . ' "' . $source . '"';
					$notempty = 1;
				};
			};
			if ( $notempty != 0 )
			{
			   	my( $data, $cmd, $duline);
				$cmd = 'du --bytes --total --summarize --apparent-size --dereference ' . $excludelist . ' ' . $sourcelist;
				$self->WriteLog( "Command : " . $cmd , 3 );
				open (DATA, "$cmd 2>&1 |" ) or $status = 1;
				if ( $status == 0 )
				{
			  		while ( defined ( my $line = <DATA> )  )
			   		{
			   			chomp($line);
						$self->WriteLog( $line , 2 );
						$duline = $line;
			   		};
			   		close DATA;
			   		$status = $? >> 8;
		   		};
				$self->WriteLog( "Exit status : " . $status , 3 );
				if ($status == 0)
				{
					my ( @retval ) = split(/\t/,$duline);
					$self->{_size} = ( $retval[0] );
				}
				else
				{
					my ( @retval ) = split(/\t/,$duline);
					$self->{_size} = ( $retval[0] );
					$self->{_warning} = 1;
				};
			}
			else
			{
				#no sources are valid
				$self->{_size} = 0;
			};
		};
		if ( $self->{_maxsize} > 0 )
		{
			if ( $self->{_size} > $self->{_maxsize} )
			{
				$self->{_flagsize} = 1;
				$self->{_error} = 1;
			}
			else
			{
				$self->{_flagsize} = 0;
			};
		}
		else
		{
			$self->{_flagsize} = 0;
		};
		$self->WriteLog( "Total size for section [" . $self->{_section} . "] : " . $self->{_size} . " bytes", 1 );
	}
	else
	{
		# size not checked
		$self->{_flagsize} = 0;
	}
	return ( $self->{_flagsize} );
};
#############################################################################
sub BackupLocal
{
	my ( $self ) = shift;
	my ( $source );
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	$self->CalcSpaceleft( $self->{_dest} );
	#check if histdirs is set
	if ( defined $self->{_histdirs} )
	{
		#make history directories
		if ( $self->{_histdirs} != -1 )
		{
			#make a number of history directories equal to histdirs
			#copy last directory into hist structure
			move( $self->{_dest} . '/' . $self->{_section} , $self->{_dest} . '/' . $self->{_section} . '1' );
			#move the oldest directory
			move(  $self->{_dest} . '/' . $self->{_section} . $self->{_histdirs} , $self->{_dest} . '/' . $self->{_section} );
			my ( $count );
			for ( $count = $self->{_histdirs} ; $count >= 1; $count--)
			{
				#shift directories one place
				move( $self->{_dest} . '/' . $self->{_section} . ( $count - 1 ), $self->{_dest} . '/' . $self->{_section} . $count );
			};
		};
	};
	#end check if histdirs is set
	#loop sources
	foreach $source (@sources)
	{
		#check if source exists
		if ( -e $source )
		{
			#build excludelist string
			my ( $excludelist ) = '';
			if ( defined $self->{_excludelist} )
			{
				my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
				my ( $exclude );
				foreach $exclude (@excludes)
				{
					$excludelist = $excludelist . ' --exclude=' . $exclude;
				};
			};
			#end build excludelist string
			my $cmd = 'rsync --recursive --copy-links --verbose --times --delete-after --modify-window=3 --stats ' . $excludelist . ' "' . $source . '" ' . $self->{_dest} . '/' . $self->{_section} . '/';
			open (DATA, "$cmd 2>&1 |" ) or $status = 1;
			$self->WriteLog( "Command : " . $cmd , 3 );
			#read stdin
			if ( $status == 0 )
			{
				my ( $flag ) = 0;
				while ( defined ( my $line = <DATA> )  )
				{
							if ( $line =~ m/total size is/ )
							{
								$line =~ m/(\d+)/;
								my ( $num ) = $1;
								if ( $self->{_maxsize} < 0 )
								{
									$self->{_size} += $num;
								}
							}
					chomp($line);
					if ( $line eq "")
					{
						$flag = 0;
					};
					if ( $flag eq 1 )
					{
			if ( $line =~ m/rsync:/ )
			{
							$self->WriteLog( $line , 3 );
			}
			else
			{
							$self->WriteList( $line );
							
			};
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
					if ( $line =~/file list/ )
					{
						$flag = 1;
					};
					
				};
				close DATA;
				$status = $? >> 8;
			};
			#end read stdin
			$self->{_status} += $status;
			#check exit status
			if ( $status != 0 )
			{
				if ( $status == 23 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files could not be copied. " , 1 );
				}
				elsif ( $status == 24 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files vanished before copying. " , 1 );
				}
				else
				{
					$self->{_error} = 1;
					$self->WriteLog( "Not copied " , 1 );
				};
			};
			#end check exit status
			$self->WriteLog( "Exit status : " . $status , 2 );
		}
		else
		{
			$self->{_status} = 1;
			$self->{_error} = 1;
			$self->WriteLog( " Source " . $source . " does not exist." , 0 );
			$status = 3;
		};
		#end check if source exists
	};
	#end loop sources
	#check status
	if ( $status == 0 )
	{
		$self->WriteLog( "All files copied." , 1 );
	}
	else
	{
		$self->WriteLog( "One or more errors/warning." , 1 );
	};
	#end check status
	$self->LabelDir( $self->{_dest} . '/' . $self->{_section} , $self->{_logdate} );
	#check if histdirs = -1
	if ( defined $self->{_histdirs} )
	{
		#make history directories
		if ( $self->{_histdirs} == -1 )
		{
			#create new derectory for infinite history
			if ( move( $self->{_dest} . '/' . $self->{_section} , $self->{_dest} . '/' . $self->{_section}. '.' . $self->{_logdate} ) )
			{
				$self->WriteLog( " Files moved into : " .  $self->{_dest} . '/' . $self->{_section} . '.' . $self->{_logdate} , 0 );
			}
			else
			{
				$self->WriteLog( " Could not move files." , 0 );
			};
		};
	};
	#end check if histdirs = -1
	return ( $status );
};
#############################################################################
sub CypherLocal
{
	my ( $self ) = shift;
	my ( $source );
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	my $tmpdir = tempdir( $gsection->GetTempDir() . "/BCKXXXXXX");
	$self->CalcSpaceleft( $self->{_dest} );
	#check if histdirs is set
	if ( defined $self->{_histdirs} )
	{
		#make history directories
		if ( $self->{_histdirs} != -1 )
		{
			#make a number of history directories equal to histdirs
			#copy last directory into hist structure
			move( $self->{_dest} . '/' . $self->{_section} , $self->{_dest} . '/' . $self->{_section} . '1' );
			#move the oldest directory
			move(  $self->{_dest} . '/' . $self->{_section} . $self->{_histdirs} , $self->{_dest} . '/' . $self->{_section} );
			my ( $count );
			for ( $count = $self->{_histdirs} ; $count >= 1; $count--)
			{
				#shift directories one place
				move( $self->{_dest} . '/' . $self->{_section} . ( $count - 1 ), $self->{_dest} . '/' . $self->{_section} . $count );
			};
		};
	};
	#end check if histdirs is set
	#loop sources
	foreach $source (@sources)
	{
		#check if source exists
		if ( -e $source )
		{
			#build excludelist string
			my ( $excludelist ) = '';
			if ( defined $self->{_excludelist} )
			{
				my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
				my ( $exclude );
				foreach $exclude (@excludes)
				{
					$excludelist = $excludelist . ' --exclude=' . $exclude;
				};
			};
			#end build excludelist string
			my $cmd = 'rsync --recursive --copy-links --verbose --times  --delete-after --modify-window=3 --stats ' . $excludelist . ' "' . $source . '" ' . $tmpdir . '/' . $self->{_section} . '/';
			open (DATA, "$cmd 2>&1 |" ) or $status = 1;
			$self->WriteLog( "Command : " . $cmd , 3 );
			#read stdin
			if ( $status == 0 )
			{
				my ( $flag ) = 0;
				while ( defined ( my $line = <DATA> )  )
				{
							if ( $line =~ m/total size is/ )
							{
								$line =~ m/(\d+)/;
								my ( $num ) = $1;
								if ( $self->{_maxsize} < 0 )
								{
									$self->{_size} += $num;
								}
							}
					chomp($line);
					if ( $line eq "")
					{
						$flag = 0;
					};
					if ( $flag eq 1 )
					{
						#Write later to listfile
			if ( $line =~ m/rsync:/ )
			{
							$self->WriteLog( $line , 3 );
			}
			else
			{
							#$self->WriteList( $line );
			};
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
					if ( $line =~/file list/ )
					{
						$flag = 1;
					};
				};
				close DATA;
				$status = $? >> 8;
			};
			#end read stdin
			$self->{_status} += $status;
			#check exit status
			if ( $status != 0 )
			{
				if ( $status == 23 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files could not be copied. " , 1 );
				}
				elsif ( $status == 24 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files vanished before copying. " , 1 );
				}
				else
				{
					$self->{_error} = 1;
					$self->WriteLog( "Not copied " , 1 );
				};
			};
			#end check exit status
			$self->WriteLog( "Exit status : " . $status , 2 );
			$self->WriteLog( "Start encryption phase", 2 );
			my ( $tmpvar ) = $tmpdir;
			my ( $pathdepth ) = ( $tmpvar =~ tr/\/// ) + 1;
			$cmd = 'rsyncrypto -r -v --delete --trim=' . $pathdepth . ' ' . $tmpdir . '/' . $self->{_section} . ' ' . $self->{_dest} . '/' . $self->{_section} . '/ ' . '/var/spool/bck/keys/' . $self->{_section} . ' ' . $self->{_cert};
			$status = 0;
			open (DATA, "$cmd 2>&1 |" ) or $status = 1;
			$self->WriteLog( "Command : " . $cmd , 3 );
			#read stdin
			if ( $status == 0 )
			{
				my ( $flag ) = 0;
				while ( defined ( my $line = <DATA> )  )
				{
					chomp($line);
					if ( $line =~ m/^Encrypting/i )
					{
						$line = substr($line, 11);
						$self->WriteList( $line );
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
				};
				close DATA;
				$status = $? >> 8;
			};
			if ( $status != 0 )
			{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files could not be encrypted. " , 1 );
			};
		}
		else
		{
			$self->{_status} = 1;
			$self->{_error} = 1;
			$self->WriteLog( " Source " . $source . " does not exist." , 0 );
			$status = 3;
		};
		#end check if source exists
	};
	#end loop sources
	#check status
	if ( $status == 0 )
	{
		$self->WriteLog( "All files copied." , 1 );
	}
	else
	{
		$self->WriteLog( "One or more errors/warning." , 1 );
	};
	#end check status
	$self->LabelDir( $self->{_dest} . '/' . $self->{_section} , $self->{_logdate} );
	#check if histdirs = -1
	if ( defined $self->{_histdirs} )
	{
		#make history directories
		if ( $self->{_histdirs} == -1 )
		{
			#create new derectory for infinite history
			if ( move( $self->{_dest} . '/' . $self->{_section} , $self->{_dest} . '/' . $self->{_section}. '.' . $self->{_logdate} ) )
			{
				$self->WriteLog( " Files moved into : " .  $self->{_dest} . '/' . $self->{_section} . '.' . $self->{_logdate} , 0 );
			}
			else
			{
				$self->WriteLog( " Could not move files." , 0 );
			};
		};
	};
	#end check if histdirs = -1
	rmtree( $tmpdir );
	return ( $status );
};
#############################################################################
sub BackupRsync
{
	my ( $self ) = shift;
	my ( $source, $options );
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	#loop sources
	foreach $source ( @sources )
	{
		#build excludelist string
		my ( $excludelist ) = '';
		if ( defined $self->{_excludelist} )
		{
			my ( @excludes ) = split(/[,\n]/,$self->{_excludelist});
			my ( $exclude );
			foreach $exclude ( @excludes)
			{
				$excludelist = $excludelist . ' --exclude=' . $exclude;
			};
		};
		#end build excludelist string
		#add options if defined
		if ( defined $self->{_options} )
		{
			$options =  $self->GetOptions() . ' ';
		}
		else
		{
			$options = '--recursive --verbose --rsh=ssh  --delete-after --modify-window=3 --times --stats --devices --specials --times --perms --owner --group --links';
		};
		my $cmd = 'rsync ' . $options . ' ' .  $excludelist . ' "' . $source . '" ' . $self->{_dest} . '/' . $self->{_section} . '/';
		open ( DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		#read stdin
		if ( $status == 0 )
		{
			my ( $flag ) = 0;
			while ( defined ( my $line = <DATA> )  )
			{
						if ( $line =~ m/total size is/ )
						{
							$line =~ m/(\d+)/;
							my ( $num ) = $1;
							if ( $self->{_maxsize} < 0 )
							{
								$self->{_size} += $num;
							}
						}
				chomp( $line );
				if ( $line eq "")
				{
					$flag = 0;
				};
				if ( $flag eq 1 )
				{
		if ( $line =~ m/rsync:/ )
		{
						$self->WriteLog( $line , 3 );
		}
		else
		{
						$self->WriteList( $line );
		};
				}
				else
				{
					$self->WriteLog( $line , 3 );
				};
				if ( $line =~/file list/ )
				{
					$flag = 1;
				};
			};
			close DATA;
			$status = $? >> 8;
		};
		#end read stdin
		$self->{_status} += $status;
		#check exit status
		if ( $status != 0 )
		{
			if ( $status == 23 )
			{
				$self->{_warning} = 1;
				$self->WriteLog( "Some files could not be copied. " , 1 );
			}
			elsif ( $status == 24 )
			{
				$self->{_warning} = 1;
				$self->WriteLog( "Some files vanished before copying. " , 1 );
			}
			else
			{
				$self->{_error} = 1;
				$self->WriteLog( "Not copied " , 1 );
			};
		};
		#end check exit status
		$self->WriteLog( "Exit status : " . $status , 2 );
	};
	#end loop sources
	#check status
	if ( $status == 0 )
	{
		$self->WriteLog( "All files copied." , 1 );
	}
	else
	{
		$self->WriteLog( "One or more errors/warning." , 1 );
	};
	#end check status
	#$self->LabelDir( $self->{_dest} . '/' . $self->{_section} , $self->{_logdate} );
	return( $status );
};
#############################################################################
sub BackupTape
{
	my ( $self ) = shift;
	my ( $source );
	my ( $sourcelist ) = '';
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	foreach $source ( @sources )
	{
		if ( -e $source )
		{
			$sourcelist = $sourcelist . ' "' . $source . '"';
		}
		else
		{
			$self->{_status} += 1 ;
			$self->{_warning} = 1 ;
		};
	};
	#mt status
	my $cmd = "mt -f " . $self->{_dest} . " status";
	#mt -f /dev/st0 status with 20/40GB tape in DAT72
	#drive type = Generic SCSI-2 tape
	#drive status = 637534208
	#sense key error = 0
	#residue count = 0
	#file number = 0
	#block number = 0
	#Tape block size 0 bytes. Density code 0x26 (unknown).
	#Soft error count since last status=0
	#General status bits on (41010000):
	# BOT ONLINE IM_REP_EN
	#mt -f /dev/st0 status with 36/72GB tape in DAT72
	#drive type = Generic SCSI-2 tape
	#drive status = 1191182336
	#sense key error = 0
	#residue count = 0
	#file number = 0
	#block number = 0
	#Tape block size 0 bytes. Density code 0x47 (unknown).
	#Soft error count since last status=0
	#General status bits on (41010000):
	# BOT ONLINE IM_REP_EN
	open (DATA, "$cmd 2>&1 |" ) or $status = 1;
	$self->WriteLog( "Command : " . $cmd , 3 );
	if ( $status == 0 )
	{
		my ( $flag ) = 0;
		while ( defined ( my $line = <DATA> )  )
		{
			chomp($line);
			if ( $line =~ m/:/ )
			{
				$self->WriteLog( $line , 1 );
			}
			else
			{
				$self->WriteLog( $line , 3 );
			}
		};
		close DATA;
		$status = $? >> 8;
	};
	$self->{_status} += $status;
	if ( $status != 0 )
	{
		$self->{_error} = 1;
	};
	if ( $status == 0 )
	{
		#tar
		my ( $excludelist ) = ' ';
		if ( defined $self->{_excludelist} )
		{
			my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
			my ( $exclude );
			foreach $exclude (@excludes)
			{
				$excludelist = $excludelist . ' --exclude=' . $exclude;
			};
		};
		#read label from tape (tar must be at least 1.15.90)
		$status = 0;
		my $cmd = 'tar --test-label --file ' . $self->{_dest};
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		if ( $status == 0 )
		{
			while ( defined ( my $line = <DATA> )  )
			{
				chomp($line);
				$self->WriteLog( "Using tape with label: " . $line , 3 );
			};
			close DATA;
			$status = $? >> 8;
	};
	$cmd = 'tar --create  --dereference --verbose --totals --label ' . $self->{_section} . "." . $self->{_logdate} . ' ' . $excludelist . ' --file ' . $self->{_dest} . ' ' . $sourcelist;
	$status = 0;	
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		if ( $status == 0 )
		{
			while ( defined ( my $line = <DATA> )  )
			{
				chomp($line);
				if ( $line =~ m/^\// )
				{
					$self->WriteList( $line );
				}
				else
				{
					if ( $line =~ m/tar:/ )
					{
						$self->WriteLog( $line , 1 );
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
				};
			};
			close DATA;
			$status = $? >> 8;
		};
		$self->{_status} += $status;
		if ( $status != 0 )
		{
			$self->{_error} = 1;
			$self->WriteLog( "Not copied " , 1 );
		};
		$self->WriteLog( "Exit status : " . $status , 2 );
		# mt rewoffl if eject = yes
		if ( $self->{_eject} eq "yes" )
		{
			my $cmd = "mt -f " . $self->{_dest} . " rewoffl";
			$status = 0;
			open (DATA, "$cmd 2>&1 |" ) or $status = 1;
			$self->WriteLog( "Command : " . $cmd , 3 );
			if ( $status == 0 )
			{
				while ( defined ( my $line = <DATA> )  )
				{
					chomp($line);
					if ( $line =~ m/:/ )
					{
						$self->WriteLog( $line , 1 );
					}
					else
					{
						$self->WriteLog( $line , 3 );
					}
				};
				close DATA;
				$status = $? >> 8;
			};
			$self->{_status} += $status;
			if ( $status != 0 )
			{
				$self->{_warning} = 1;
				$self->WriteLog( "Tape eject error" , 1 );
			}
			else
			{
				$self->WriteLog( "Tape ejected" , 1 );
			};
		};
	}
	else
	{
		$self->WriteLog ( "Tape status error, no tape found in device or wrong/defective tape.", 0);
	};
	if ( $status == 0 )
	{
		$self->WriteLog( "All files copied." , 1 );
	}
	else
	{
		$self->WriteLog( "One or more errors/warning." , 1 );
	};
	return ( $status );
};
#############################################################################
sub CypherTape
{
	my ( $self ) = shift;
	my ( $source );
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	my $tmpdir = tempdir( $gsection->GetTempDir() . "/BCKXXXXXX");
	my $tmpdir2 = tempdir( $gsection->GetTempDir() . "/BCKXXXXXX");
	#loop sources
	foreach $source (@sources)
	{
		#check if source exists
		if ( -e $source )
		{
			#build excludelist string
			my ( $excludelist ) = '';
			if ( defined $self->{_excludelist} )
			{
				my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
				my ( $exclude );
				foreach $exclude (@excludes)
				{
					$excludelist = $excludelist . ' --exclude=' . $exclude;
				};
			};
			#end build excludelist string
			my $cmd = 'rsync --recursive --copy-links --verbose --times  --delete-after --modify-window=3 --stats ' . $excludelist . ' "' . $source . '" ' . $tmpdir . '/' . $self->{_section} . '/';
			open (DATA, "$cmd 2>&1 |" ) or $status = 1;
			$self->WriteLog( "Command : " . $cmd , 3 );
			#read stdin
			if ( $status == 0 )
			{
				my ( $flag ) = 0;
				while ( defined ( my $line = <DATA> )  )
				{
					chomp($line);
					if ( $line eq "")
					{
						$flag = 0;
					};
					if ( $flag eq 1 )
					{
						#Write later to listfile
			if ( $line =~ m/rsync:/ )
			{
							$self->WriteLog( $line , 3 );
			}
			else
			{
							#$self->WriteList( $line );
			};
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
					if ( $line =~/file list/ )
					{
						$flag = 1;
					};
				};
				close DATA;
				$status = $? >> 8;
			};
			#end read stdin
			$self->{_status} += $status;
			#check exit status
			if ( $status != 0 )
			{
				if ( $status == 23 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files could not be copied. " , 1 );
				}
				elsif ( $status == 24 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files vanished before copying. " , 1 );
				}
				else
				{
					$self->{_error} = 1;
					$self->WriteLog( "Not copied " , 1 );
				};
			};
			#end check exit status
			$self->WriteLog( "Exit status : " . $status , 2 );
			$self->WriteLog( "Start encryption phase", 2 );
			my ( $tmpvar ) = $tmpdir;
			my ( $pathdepth ) = ( $tmpvar =~ tr/\/// ) + 1;
			$cmd = $gsection->GetRsyncrypto . ' --recurse --verbose --delete --trim=' . $pathdepth . ' ' . $tmpdir . '/' . $self->{_section} . ' ' . $tmpdir2 . '/' . $self->{_section} . ' /var/spool/bck/keys/' . $self->{_section} . ' ' . $self->{_cert};
			$status = 0;
			open (DATA, "$cmd 2>&1 |" ) or $status = 1;
			$self->WriteLog( "Command : " . $cmd , 3 );
			#read stdin
			if ( $status == 0 )
			{
				my ( $flag ) = 0;
				while ( defined ( my $line = <DATA> )  )
				{
					chomp($line);
					if ( $line =~ m/^Encrypting/i )
					{
						$line = substr($line, 11);
						$self->WriteList( $line );
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
				};
				close DATA;
				$status = $? >> 8;
			};
			if ( $status != 0 )
			{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files could not be encrypted. " , 1 );
			};
		}
		else
		{
			$self->{_status} = 1;
			$self->{_error} = 1;
			$self->WriteLog( " Source " . $source . " does not exist." , 0 );
			$status = 3;
		};
		#end check if source exists
	};
	#end loop sources
	#check status
	my $cmd = "mt -f " . $self->{_dest} . " status";
	#mt -f /dev/st0 status with 20/40GB tape in DAT72
	#drive type = Generic SCSI-2 tape
	#drive status = 637534208
	#sense key error = 0
	#residue count = 0
	#file number = 0
	#block number = 0
	#Tape block size 0 bytes. Density code 0x26 (unknown).
	#Soft error count since last status=0
	#General status bits on (41010000):
	# BOT ONLINE IM_REP_EN
	#mt -f /dev/st0 status with 36/72GB tape in DAT72
	#drive type = Generic SCSI-2 tape
	#drive status = 1191182336
	#sense key error = 0
	#residue count = 0
	#file number = 0
	#block number = 0
	#Tape block size 0 bytes. Density code 0x47 (unknown).
	#Soft error count since last status=0
	#General status bits on (41010000):
	# BOT ONLINE IM_REP_EN
	open (DATA, "$cmd 2>&1 |" ) or $status = 1;
	$self->WriteLog( "Command : " . $cmd , 3 );
	if ( $status == 0 )
	{
		my ( $flag ) = 0;
		while ( defined ( my $line = <DATA> )  )
		{
			chomp($line);
			if ( $line =~ m/:/ )
			{
				$self->WriteLog( $line , 1 );
			}
			else
			{
				$self->WriteLog( $line , 3 );
			}
		};
		close DATA;
		$status = $? >> 8;
	};
	$self->{_status} += $status;
	if ( $status != 0 )
	{
		$self->{_error} = 1;
	};
	if ( $status == 0 )
	{
		#tar
		my ( $excludelist ) = ' ';
		if ( defined $self->{_excludelist} )
		{
			my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
			my ( $exclude );
			foreach $exclude (@excludes)
			{
				$excludelist = $excludelist . ' --exclude=' . $exclude;
			};
		};
		#read label from tape
		my $cmd = 'tar --test-label --file ' . $self->{_dest};
		$status = 0;
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		if ( $status == 0 )
		{
			while ( defined ( my $line = <DATA> )  )
			{
				chomp($line);
				$self->WriteLog( "Using tape with label: " . $line , 3 );
			};
			close DATA;
			$status = $? >> 8;
		};
		$cmd = 'tar --create  --dereference --verbose --totals --label ' . $self->{_section} . $self->{_logdate} . ' --directory=' . $tmpdir2 . ' ' . $excludelist . ' --file ' . $self->{_dest} . ' ' . $self->{_section};
		$status = 0;
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		if ( $status == 0 )
		{
			while ( defined ( my $line = <DATA> )  )
			{
				chomp($line);
				if ( $line =~ m/^\// )
				{
					$self->WriteList( $line );
				}
				else
				{
					if ( $line =~ m/tar:/ )
					{
						$self->WriteLog( $line , 1 );
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
				};
			};
			close DATA;
			$status = $? >> 8;
		};
		$self->{_status} += $status;
		if ( $status != 0 )
		{
			$self->{_error} = 1;
			$self->WriteLog( "Not copied " , 1 );
		};
		$self->WriteLog( "Exit status : " . $status , 2 );
		# mt rewoffl if eject = yes
		if ( $self->{_eject} eq "yes" )
		{
			my $cmd = "mt -f " . $self->{_dest} . " rewoffl";
		$status = 0;
			open (DATA, "$cmd 2>&1 |" ) or $status = 1;
			$self->WriteLog( "Command : " . $cmd , 3 );
			if ( $status == 0 )
			{
				while ( defined ( my $line = <DATA> )  )
				{
					chomp($line);
					if ( $line =~ m/:/ )
					{
						$self->WriteLog( $line , 1 );
					}
					else
					{
						$self->WriteLog( $line , 3 );
					}
				};
				close DATA;
				$status = $? >> 8;
			};
			$self->{_status} += $status;
			if ( $status != 0 )
			{
				$self->{_warning} = 1;
				$self->WriteLog( "Tape eject error" , 1 );
			}
			else
			{
				$self->WriteLog( "Tape ejected" , 1 );
			};
		};
	}
	else
	{
		$self->WriteLog ( "Tape status error, no tape found in device or wrong/defective tape.", 0);
	};
	if ( $status == 0 )
	{
		$self->WriteLog( "All files copied." , 1 );
	}
	else
	{
		$self->WriteLog( "One or more errors/warning." , 1 );
	};
	#end check status
	rmtree( $tmpdir );
	rmtree( $tmpdir2 );
	return ( $status );
};
#############################################################################
sub BackupSmb
{
	my ( $self ) = shift;
	my ( $source );
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	my $tmpdir = tempdir( $gsection->GetTempDir() . "/BCKXXXXXX");
	my $cmd = "smbclient " . $self->{_dest} . " " . $self->GetPass() . " -E --command='exit' --user=" . $self->GetUser();
	#check if we can connect to smb share
	open (DATA, "$cmd 2>&1 |" ) or $status = 1;
	$self->WriteLog( "Command : " . $cmd , 3 );
	if ( $status == 0 )
	{
		my ( $flag ) = 0;
		while ( defined ( my $line = <DATA> )  )
		{
			chomp($line);
			if ( $line =~ m/:/ )
			{
				$self->WriteLog( $line , 1 );
			}
			else
			{
				$self->WriteLog( $line , 3 );
			};
		};
		close DATA;
		$status = $? >> 8;
	};
	$self->{_status} += $status;
	#check smb share connect error
	if ( $status != 0 )
	{
		$self->{_error} = 1;
	};
	$self->{_status} += $status;
	#check if smb test ok
	if ( $status == 0 )
	{
		my ( $smbd ) = $self->{_dest};
		$smbd =~ m/\/\/(.*)\//i;
		$cmd = "mount -t smbfs -o lfs,rw,username=" . $self->GetUser() . ",password=" . $self->GetPass() . " " . $smbd . " " . $tmpdir;
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		#read stdin
		if ( $status == 0 )
		{
			my ( $flag ) = 0;
			while ( defined ( my $line = <DATA> )  )
			{
				chomp($line);
				if ( $line =~ m/:/ )
				{
					$self->WriteLog( $line , 1 );
				}
				else
				{
					$self->WriteLog( $line , 3 );
				};
			};
			close DATA;
			$status = $? >> 8;
		};
		$self->{_status} += $status;
		#check if connected to smb share
		if ( $status == 0 )
		{
			$self->WinMsg( "Start " . $self->GetName() );
			$self->CalcSpaceleft( $tmpdir );
			#check if histdirs is set
			if ( defined $self->{_histdirs} )
			{
				#make history directories
				if ( $self->{_histdirs} != -1 )
				{
					#make a number of history directories equal to histdirs
					#copy last directory into hist structure
					if ( move( $tmpdir . '/' . $self->{_section} , $tmpdir . '/' . $self->{_section} . '1' ) )
					{
						#print "si\n";
					}
					else
					{
						#print "no\n";
					};
					#move the oldest directory
					move(  $tmpdir . '/' . $self->{_section} . $self->{_histdirs} , $tmpdir . '/' . $self->{_section} );
					my ( $count );
					for ( $count = $self->{_histdirs} ; $count >= 1; $count--)
					{
						#shift directories one place
						move( $tmpdir . '/' . $self->{_section} . ( $count - 1 ), $tmpdir . '/' . $self->{_section} . $count );
					};
				};
			};
			#end check if histdirs is set
			#loop sources
			foreach $source (@sources)
			{
				#check if source exists
				if ( -e $source )
				{
					my $cmd = SysCommand->new();
					my ( $excludelist ) = ' ';
					#build excludelist string
					if ( defined $self->{_excludelist} )
					{
						my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
						my ( $exclude );
						foreach $exclude (@excludes)
						{
							$excludelist = $excludelist . ' --exclude=' . $exclude;
						};
					};
					#end build excludelist string
					$cmd = 'rsync --recursive --copy-links --verbose --times  --delete-after --modify-window=3 --relative ' . $excludelist . ' ' . $source . ' ' . $tmpdir  . '/' . $self->{_section} . '/';
					open (DATA, "$cmd 2>&1 |" ) or $status = 1;
					$self->WriteLog( "Command : " . $cmd , 3 );
					#read stdin
					if ( $status == 0 )
					{
						my ( $flag ) = 0;
						while ( defined ( my $line = <DATA> )  )
						{
							if ( $line =~ m/total size is/ )
							{
								$line =~ m/(\d+)/;
								my ( $num ) = $1;
								if ( $self->{_maxsize} < 0 )
								{
									$self->{_size} += $num;
								}
							}
							chomp($line);
							if ( $line eq "")
							{
								$flag = 0;
							};
							if ( $flag eq 1 )
							{
					if ( $line =~ m/:/ )
					{
							$self->WriteLog( $line , 3 );
					}
					else
					{
								$self->WriteList( $line );
				};
							}
							else
							{
								$self->WriteLog( $line , 3 );
							};
							if ( $line =~/file list/ )
							{
								$flag = 1;
							};
						};
						close DATA;
						$status = $? >> 8;
					};
					#end read stdin
					$self->{_status} += $status;
				}
				else
				{
					$self->{_status} += 1 ;
				};
			};
			#end loop sources
			#check status
			if ( $status == 0 )
			{
				$self->WriteLog( "All files copied." , 1 );
			}
			else
			{
				$self->WriteLog( "One or more errors/warning." , 1 );
			};
			#end check status
			if ( $status != 0 )
			{
				$self->{_status} += $status;
				if ( $status == 23 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files could not be copied. " , 1 );
				}
				elsif ( $status == 24 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files vanished before copying. " , 1 );
				}
				else
				{
					$self->{_error} = 1;
					$self->WriteLog( "Not copied " , 1 );
				};
			};
			$self->LabelDir( $tmpdir . '/' . $self->{_section} , $self->{_logdate} );
			#check if histdirs = -1
			if ( defined $self->{_histdirs} )
			{
				#make history directories
				if ( $self->{_histdirs} == -1 )
				{
					#create new derectory for infinite history
					if ( move( $tmpdir . '/' . $self->{_section} , $tmpdir . '/' . $self->{_section}. '.' . $self->{_logdate} ) )
					{
						$self->WriteLog( " Files moved into : " .  $self->{_dest} . '/' . $self->{_section} . '.' . $self->{_logdate} , 0 );
					}
					else
					{
						$self->WriteLog( " Could not move files." , 0 );
					};
				};
			};
			#end check if histdirs = -1
			my $cmd = "umount " . $self->{_dest};
			open (DATA, "$cmd 2>&1 |" ) or $status = 1;
			$self->WriteLog( "Command : " . $cmd , 3 );
			if ( $status == 0 )
			{
				my ( $flag ) = 0;
				while ( defined ( my $line = <DATA> )  )
				{
					chomp($line);
					if ( $line =~ m/^:/ )
					{
						$self->WriteLog( $line , 1 );
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
				};
				close DATA;
				$status = $? >> 8;
				$self->WinMsg( "End " . $self->GetName() );
			};
		};
	}
	else
	{
		$self->{_status} += 1 ;
		$self->{_error} = 1;
		$self->WriteLog( " Samba share " . $self->{_dest} . " could not be mounted." , 1 );
	};
	#end test if smb test ok
	#delete temp dir created for mounting filesystem
	# if status is 0, umount was succesfull
	if ( $status == 0 )
	{
		rmtree( $tmpdir );
	}
	else
	{
		$self->{_warning} = 1;
		$self->WriteLog( "Samba filesystem could not be unmounted. " , 1 );
	};
	return (0);
};
#############################################################################
sub BackupPart
{
	my ( $self ) = shift;
	my ( $source );
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	my $tmpdir = tempdir( $gsection->GetTempDir() . "/BCKXXXXXX");
	my $cmd = "mount " . $self->{_dest} . " " . $tmpdir;
	open (DATA, "$cmd 2>&1 |" ) or $status = 1;
	$self->WriteLog( "Command : " . $cmd , 3 );
	if ( $status == 0 )
	{
		my ( $flag ) = 0;
		while ( defined ( my $line = <DATA> )  )
		{
			chomp($line);
			if ( $line =~ m/^:/ )
			{
				$self->WriteLog( $line , 1 );
			}
			else
			{
				$self->WriteLog( $line , 3 );
			};
		 };
		 close DATA;
		 $status = $? >> 8;
	};
	$self->{_status} += $status;
	if ( $status == 0 )
	{
		#check if histdirs is set
		$self->CalcSpaceleft( $tmpdir );
		if ( defined $self->{_histdirs} )
		{
			#make history directories
			if ( $self->{_histdirs} != -1 )
			{
				#make a number of history directories equal to histdirs
				#copy last directory into hist structure
				move( $tmpdir . '/' . $self->{_section} , $tmpdir . '/' . $self->{_section} . '1' );
				#move the oldest directory
				move(  $tmpdir . '/' . $self->{_section} . $self->{_histdirs} , $tmpdir . '/' . $self->{_section} );
				my ( $count );
				for ( $count = $self->{_histdirs} ; $count >= 1; $count--)
				{
					#shift directories one place
					move( $tmpdir . '/' . $self->{_section} . ( $count - 1 ), $tmpdir . '/' . $self->{_section} . $count );
				};
			};
		};
		foreach $source (@sources)
		{
			if ( -e $source )
			{
				my $cmd = SysCommand->new();
				my ( $excludelist ) = ' ';
				if ( defined $self->{_excludelist} )
				{
					my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
					my ( $exclude );
					foreach $exclude (@excludes)
					{
						$excludelist = $excludelist . ' --exclude=' . $exclude;
					};
				};
				$cmd = 'rsync --recursive --copy-links --verbose --times  --delete-after --modify-window=3 --relative ' . $excludelist . ' ' . $source . ' ' . $tmpdir  . '/' . $self->{_section} . '/';
				open (DATA, "$cmd 2>&1 |" ) or $status = 1;
				$self->WriteLog( "Command : " . $cmd , 3 );
				if ( $status == 0 )
				{
					my ( $flag ) = 0;
					while ( defined ( my $line = <DATA> )  )
					{
						if ( $line =~ m/total size is/ )
						{
							$line =~ m/(\d+)/;
							my ( $num ) = $1;
							if ( $self->{_maxsize} < 0 )
							{
								$self->{_size} += $num;
							};
						};
					chomp($line);
					if ( $line eq "")
					{
						$flag = 0;
					};
					if ( $flag eq 1 )
					{
						if ( $line =~ m/:/ )
						{
							$self->WriteLog( $line , 3 );
						}
						else
						{
							$self->WriteList( $line );
						};
					}
					else
					{
						$self->WriteLog( $line , 3 );
					};
					if ( $line =~/file list/ )
						{
							$flag = 1;
						};
					};
					close DATA;
					$status = $? >> 8;
				};
				$self->{_status} += $status;
			}
			else
			{
				$self->{_status} += 1 ;
					   if ( $status == 23 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files could not be copied. " , 1 );
				}
				elsif ( $status == 24 )
				{
					$self->{_warning} = 1;
					$self->WriteLog( "Some files vanished before copying. " , 1 );
				}
				else
				{
					$self->{_error} = 1;
					$self->WriteLog( "Not copied " , 1 );
				};
			};
		};
		$self->LabelDir( $tmpdir . '/' . $self->{_section} , $self->{_logdate} );
		if ( defined $self->{_histdirs} )
		{
			#make history directories
			if ( $self->{_histdirs} == -1 )
			{
				#create new derectory for infinite history
				if ( move( $tmpdir . '/' . $self->{_section} , $tmpdir . '/' . $self->{_section}. '.' . $self->{_logdate} ) )
				{
					$self->WriteLog( " Files moved into : " .  $self->{_dest} . '/' . $self->{_section} . '.' . $self->{_logdate} , 0 );
				}
				else
				{
					$self->WriteLog( " Could not move files." , 0 );
				};
			};
		};
		my $cmd = "umount " . $self->{_dest};
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		if ( $status == 0 )
		{
			my ( $flag ) = 0;
			while ( defined ( my $line = <DATA> )  )
			{
				chomp($line);
				if ( $line =~ m/^:/ )
				{
					$self->WriteLog( $line , 1 );
				}
				else
				{
					$self->WriteLog( $line , 3 );
				};
			};
			close DATA;
			$status = $? >> 8;
		};
		$self->{_status} += $status;
	}
	else
	{
		$self->{_status} += 1 ;
		$self->{_error} = 1;
		$self->WriteLog( " Partition share " . $self->{_dest} . " could not be mounted." , 1 );
	};
	# if status is 0, umount was succesfull
	if ( $status == 0 )
	{
		rmtree( $tmpdir );
	}
	else
	{
		$self->{_warning} = 1;
		$self->WriteLog( "Filesystem could not be unmounted. " , 1 );
	};
	if ( $status == 0 )
	{
		 $self->WriteLog( "All files copied." , 1 );
	}
	else
	{
		$self->WriteLog( "One or more errors/warning." , 1 );
	};
	return (0);
};

sub BackupFirebird
{
	my ( $self ) = shift;
	my ( $source, $options );
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	$self->CalcSpaceleft( $self->{_dest} );
	#check if histdirs is set
	if ( defined $self->{_histdirs} )
	{
		#make history files
		if ( $self->{_histdirs} != -1 )
		{
			#make a number of history files equal to histdirs
			#copy last file into hist structure
			move( $self->{_dest} . '/' . $self->{_section} . '.gbk' , $self->{_dest} . '/' . $self->{_section} . '1.gbk' );
			move( $self->{_dest} . '/' . $self->{_section} . '.fdb' , $self->{_dest} . '/' . $self->{_section} . '1.fdb' );
			#move the oldest file
			move(  $self->{_dest} . '/' . $self->{_section} . $self->{_histdirs} . '.gbk' , $self->{_dest} . '/' . $self->{_section} . '.gbk' );
			move(  $self->{_dest} . '/' . $self->{_section} . $self->{_histdirs} . '.fdb' , $self->{_dest} . '/' . $self->{_section} . '.fdb' );
			my ( $count );
			for ( $count = $self->{_histdirs} ; $count >= 1; $count--)
			{
				#shift files one place
				move( $self->{_dest} . '/' . $self->{_section} . ( $count - 1 ) . '.gbk', $self->{_dest} . '/' . $self->{_section} . $count . '.gbk' );
				move( $self->{_dest} . '/' . $self->{_section} . ( $count - 1 ) . '.fdb', $self->{_dest} . '/' . $self->{_section} . $count . '.fdb' );
			};
		};
	};
	$source = shift(@sources);
	#check if source exist
	if ( defined $self->{_options} )
	{
		$options =  $self->GetOptions() . ' ';
	}
	else
	{
		$options = '-B -V -L -T -USER SYSDBA -PASSWORD masterkey ';
	};
	if ( -e $source )
	{
		my $cmd = $self->{_cmd} . " " . $options . $source . " " . $self->{_dest} . '/' . $self->{_section} . ".gbk";
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		if ( $status == 0 )
		{
			my ( $flag ) = 0;
			while ( defined ( my $line = <DATA> )  )
			{
				chomp($line);
				if ( $line =~ m/^ERROR:/ )
				{
					$self->WriteLog( $line , 1 );
				}
				else
				{
					$self->WriteList( $line , 3 );
				};
			};
			close DATA;
			$status = $? >> 8;
		};
		$self->{_status} += $status;
		if ( $status == 0 )
		{
			$self->WriteLog( "Database backup (gbk) created." , 1 );
		}
		else
		{
			$self->WriteLog( "One or more errors/warning." , 1 );
			$self->{_error} = 1;
		};
		# We also copy the database file itself just to be sure
		if ( copy( $source, $self->{_dest} . '/' . $self->{_section} . ".fdb" ) )
		{
			$self->WriteLog( "Database (fdb) copied." , 1 );
		}
		else
		{
			$self->WriteLog( "One or more errors/warning." , 1 );
			$self->{_error} = 1;
		};
		$self->LabelDir( $self->{_dest} , $self->{_logdate} );
		if ( defined $self->{_histdirs} )
		{
			#make history files
			if ( $self->{_histdirs} == -1 )
			{
				#create new file for infinite history
				if ( move( $self->{_dest} . '/' . $self->{_section} . '.gbk' , $self->{_dest} . '/' . $self->{_section}. '.' . $self->{_logdate} . '.gbk' ) and move( $self->{_dest} . '/' . $self->{_section} . '.fdb' , $self->{_dest} . '/' . $self->{_section}. '.' . $self->{_logdate} . '.fdb' ))
				{
					$self->WriteLog( " Files moved into : " .  $self->{_dest} . '/' . $self->{_section} . '.' . $self->{_logdate} . '.gbk' , 0 );
				}
				else
				{
					$self->WriteLog( " Could not move files." , 0 );
				};
			};
		};
	}
	else
	{
		$self->WriteLog( " Database source file does not exist." , 0 );
		$self->{_error} = 1;
		$self->{_status} = 1;
	};
	return(0);
};
########################################################################################
sub ExecSection
{
	my ( $self ) = shift;
	my ( $source);
	my ( $status ) = 0;
	my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
	#check if histdirs is set
	$source = shift(@sources);
	#check if source exist
	if ( -e $source )
	{
		my $cmd = "cd " . $source . " ; " . $self->{_cmd};
		open (DATA, "$cmd 2>&1 |" ) or $status = 1;
		$self->WriteLog( "Command : " . $cmd , 3 );
		if ( $status == 0 )
		{
			my ( $flag ) = 0;
			while ( defined ( my $line = <DATA> )  )
			{
				chomp($line);
				$self->WriteLog( $line , 1 );
			};
			close DATA;
			$status = $? >> 8;
		};
		$self->{_status} += $status;
		if ( $status == 0 )
		{
			$self->WriteLog( "Done & OK." , 1 );
		}
		else
		{
			$self->WriteLog( "One or more errors/warning." , 1 );
			$self->{_error} = 1;
		}
	}
	else
	{
		$self->WriteLog( " Source directory does not exist." , 0 );
		$self->{_error} = 1;
		$self->{_status} = 1;
	};
	return(0);
};
###################################################################
sub Backup
{
	my ( $self ) = shift;
	$self->{_starttime} = time();
	$self->SetMarkFile();
	#local copy
	if ( $self->{_type} eq 'local' )
	{
		if ( $self->{_cypher} eq "yes" )
		{
		 	$self->CypherLocal();
		}
		else
		{
			$self->BackupLocal();
		};
	};
	#copy on tape
	if ( $self->{_type} eq 'tape' )
	{
		if ( $self->{_cypher} eq "yes" )
		{
		 	$self->CypherTape();
		}
		else
		{
			$self->BackupTape();
		};
	};
	#copy to samba share
	if ( $self->{_type} eq 'samba' )
	{
		$self->BackupSmb();
	};
	#copy to partition
	if ( $self->{_type} eq 'part' )
	{
		$self->BackupPart();
	};
	# firebird section
	if ( $self->{_type} eq 'firebird' )
	{
		$self->BackupFirebird();
	};
	# rsync section
	if ( $self->{_type} eq 'rsync' )
	{
		$self->BackupRsync();
	};
	# exec section
	if ( $self->{_type} eq 'exec' )
	{
		$self->ExecSection();
	};
	# optical section
	if ( $self->{_type} eq 'optical' )
	{
		my ( $source, $status );
		my ( @sources ) = split(/[,\n]/,$self->{_sourcelist} );
		my ( $sourcelist ) = "";
		foreach $source (@sources)
		{
			if ( -e $source )
			{
				$source =~ s/^\s+//; # Remove leading spaces
				$source =~ s/\s+$//;  # Remove trailing spaces
				$sourcelist = $sourcelist . "  " . $source . "=" . $source; # Building filelist for mkisofs
			}
			else
			{
				$self->{_status} += 1 ;
			};
		};
	# [DVD|CD|DVDRW|CDRW|DVD9|DVD9RW]
	if($self->{_medium} eq "DVD")
		{
		$self->CloseTray();
		$self->WriteDvd($sourcelist);
		$self->OpenTray();
		}
	elsif($self->{_medium} eq "CD")
		{
		$self->CloseTray();
		$self->WriteCd($sourcelist);
		$self->OpenTray();
		}
	elsif($self->{_medium} eq "DVDRW")
		{
		$self->CloseTray();
		$self->FormatDvd();
		$self->WriteDvd($sourcelist);
		$self->OpenTray();
		}
	elsif($self->{_medium} eq "CDRW")
		{
		$self->CloseTray();
		$self->FormatCd();
		$self->WriteCd($sourcelist);
		$self->OpenTray();
		}
	elsif($self->{_medium} eq "DVD9")
		{
		# No implementado
		}
	elsif($self->{_medium} eq "DVD9RW")
		{
		# No implementado
		}
	else
		{
		};
	};
	if ( not defined $self->{_status} )
	{
		$self->{_status} = -1;
	};
	$self->DeleteMarkFile();
	$self->{_endtime} = time();
	return ( $self->{_status}, $self->{_error}, $self->{_warning} );
};

############################################################################
##
## Sub OpenTray : Open Tray
##
############################################################################
sub OpenTray
{
	my ( $self ) = shift;
	my $cmd = SysCommand->new();
	my $cmdline = $gsection->GetCdRecord() . " -eject -dev=" . $self->{_dest};
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	return(0);
};
############################################################################
##
## Sub CloseTray : Close tray
##
############################################################################
sub CloseTray
{
	my ( $self ) = shift;
	my $cmd = SysCommand->new();
	my ( $cmdline ) = $gsection->GetCdRecord() . " -load -dev=" . $self->{_dest};
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	return(0);
};
############################################################################
##
## Sub FormatDvd : Format DVD
##
############################################################################
sub FormatDvd
{
	my ( $self ) = shift;
	my $cmd = SysCommand->new();
	my $cmdline = $gsection->GetDvdFormat() . " -force " . $self->{_dest};
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	return(0);
};
############################################################################
##
## Sub FormatCd : Format CD
##
############################################################################
sub FormatCd
{
	my ( $self ) = shift;
	my $cmd = SysCommand->new();
	my $cmdline = $gsection->GetCdRecord() . " -blank=fast -dev=" . $self->{_dest};
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
};
############################################################################
##
## Sub WriteDvd : Write DVD
##
############################################################################
sub WriteDvd
{
	my ( $self ) = shift;
	my ( $filelist ) = @_;
	my ( @daynames ) = qw( sunday monday tuesday wednesday thursday friday saturday );
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	my ( $wdname ) = $daynames[$wday];
	my $cmd = SysCommand->new();
	my ( $excludelist ) = ' ';
	if ( defined $self->{_excludelist} )
	{
		my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
		my ( $exclude );
		foreach $exclude (@excludes)
		{
			$excludelist = $excludelist . ' -m ' . $exclude;
		};
	};
	my $cmdline = $gsection->GetDvdRecord() . ' -Z ' . $self->{_dest} . ' -joliet-long  -J ' . $excludelist . ' -R -V "' . $gsection->GetClient() . " " . $wdname . '" -graft-points '. $filelist;
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
};
############################################################################
##
## Sub WriteCd : Write CD
##
############################################################################
sub WriteCd
{
	my ( $self ) = shift;
	my ( $filelist ) = @_;
	my ( @daynames ) = qw( sunday monday tuesday wednesday thursday friday saturday );
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	my ( $wdname ) = $daynames[$wday];
	my $tmpdir = tempdir("/var/tmp/BCKXXXXXX");
	my $cmd = SysCommand->new();
	my ( $excludelist ) = ' ';
	if ( defined $self->{_excludelist} )
	{
		my (@excludes ) = split(/[,\n]/,$self->{_excludelist});
		my ( $exclude );
		foreach $exclude (@excludes)
		{
			$excludelist = $excludelist . ' -m ' . $exclude;
		};
	};
	my $cmdline = 'mkisofs -joliet-long -o ' . $tmpdir . '/cd.iso -J ' . $excludelist . ' -R -V "' . $gsection->GetClient() . ' ' . $wdname . '" -graft-points '. $filelist;
	$cmd->Exec($cmdline);
	my $status = $cmd->GetStatus();
	$self->{_status} += $status;
	my $cmd2 = SysCommand->new();
	$cmdline = "cdrecord -v -speed=8 -dev=" . $self->{_dest} . " " . $tmpdir . "/cd.iso";
	$cmd2->Exec($cmdline);
	$status = $cmd2->GetStatus();
	$self->{_status} += $status;
	rmtree( $tmpdir );
}
##################################################################################
# End Class DoSection
##################################################################################
##################################################################################
#
# Class ParseOutput : Command output error parsing and filtering for various
#
##################################################################################
package ParseOutput;
sub new
{
	my ($class) = shift;
	my $self =
	{
			_cmd 	 => undef,
			_log		=> [],
			_errorlog => [],
			_status   	=> 0,
		};
	bless $self, $class;
	return $self;
};
##################################################################################
# End Class ParseOutput
##################################################################################
##################################################################################
#
# Class SysCommand : Command line execution class
#
##################################################################################
package SysCommand;
sub new
{
	my ($class) = shift;
	my $self =
	{
			_cmd 	 => undef,
			_status   	=> 0,
			_logfile	=> undef
		};
	bless $self, $class;
	return $self;
};
sub Exec
{
	my ( $self ) = shift;
	$self->{_cmd} = shift;
	my($data,$status,$cmd,$log);
	$cmd = $self->{_cmd};
	open (DATA, "$cmd 2>&1 |" ) or $self->{_status} = 1;
	if ( defined $self->{_logfile} )
	{
		open ( LOGFILE, ">>" . $self->{_logfile} );
		print LOGFILE "Exec command : " . $cmd . "\n";
	};
	if ( $self->{_status} == 0 )
	{
		while ( defined ( my $line = <DATA> )  )
		{
			chomp($line);
			if ( defined $self->{_logfile} )
			{
				print LOGFILE "$line\n";
			};
		};
		close DATA;
		$self->{_status} = $? >> 8;
	};
	if ( defined $self->{_logfile} )
	{
		print LOGFILE "Command : " . $cmd . " exit status : " . $self->{_status} . "\n";
		close LOGFILE;
	};
};
sub GetStatus
{
	my ( $self ) = shift;
	return $self->{_status};
};
sub SetLogfilename
{
	my ( $self ) = shift;
	my ( $filename ) = @_;
	$self->{_logfile} = $filename;
};
##################################################################################
# End Class SysCommand
##################################################################################
##################################################################################
#
# Class Report : Report summary class
#
##################################################################################
package Report;
use MIME::QuotedPrint;
use Sys::Syslog;
# Configuracion para el perl module Mail::Sendmail
our @ISA = qw(TableLine Mail);	# inherits from TableLine, Mail
sub new
{
	my ( $class ) = shift;
	my ( $level );
	my $self =
	{
		_title		=> undef,
		_mail		=> [],
		_table		=> [],
		_ip		=> "",
		_state		=> 0,
	};
	bless $self, $class;
	return $self;
};
#accessor method for ip
sub SetIP
{
	my ( $self ) = shift;
	my ( $ip ) = @_;
	$self->{_ip} = $ip;
};
#accessor method for ip
sub GetIP
{
	my ( $self ) = shift;
	return ( $self->{_ip} );
};
#accessor method for title
sub SetTittle
{
	my ( $self ) = shift;
	my ( $title ) = @_;
	$self->{_title} = $title;
};
#accessor method for state
sub GetState
{
	my ( $self ) = shift;
	return ( $self->{_state} );
};
#accessor method for state
sub SetState
{
	my ( $self ) = shift;
	my ( $state ) = @_;
	if ( $self->{_state} < $state )
	{
		$self->{_state} = $state;
	};
};
#accessor method for table array
sub AddTable
{
	my ( $self ) = shift;
	my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree) = @_;
	if( $section ne "" )
	{
		push( @{$self->{_table}}, TableLine->new( $section, $name, $timestamp, $status, $size, $destsize, $destfree ) );
	};
};
#accessor method for mail array
sub AddMail
{
	my ( $self ) = shift;
	my ( $address, $level, $mode ) = @_;
	push( @{$self->{_mail}}, Mail->new( $address, $level, $mode ) );
};
sub SendReports
{
	my ( $self ) = shift;
	my ( $mail );
	my ( $mailstat ) = 1;
	my ( $subject ) = "[" . $gsection->GetErrortag() . "] Backup report (" . $gsection->GetClient() . ")";
	if ( $self->GetState() == 0 )
	{
		$subject = "[" . $gsection->GetOktag() . "] Backup report (" . $gsection->GetClient() . ")";
	}
	elsif ( $self->GetState() == 1 )
	{
		$subject = "[". $gsection->GetWarningtag() . "] Backup report (" . $gsection->GetClient() . ")";
	}
	elsif ( $self->GetState() == 2 )
	{
		$subject = "[" . $gsection->GetErrortag() . "] Backup report (" . $gsection->GetClient() . ")";
	};
	# Get mailtext from config file, if it points to a file, read it and get the text into $mailtext
	my ( $cfg, $mastercfg );
	my ( $configfilename ) = cmdln->GetConfigFileName();
	if ( -r "/etc/bck/bck.default" )
	{
		  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
		  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
	}
	else
	{
		$cfg 	= Config::IniFiles->new( -file => $configfilename );
	};
	my ( $mailtext ) = $cfg->val('global', 'mailtext');
	if ( not defined $mailtext )
	{
		$mailtext = "";
	}; 
	if ( -e $mailtext )
	{
		if ( (-r $mailtext) && (-T $mailtext) )
		{
			my ( $string );
			local $/=undef;
			open FILE, "<", $mailtext or die $!;
			$string = <FILE>;
			close FILE;
			$mailtext = $string;
		}	
		else
		{
			$mailtext = "...";
		};
	}
	foreach $mail ( @{ $self->{_mail}} )
	{
		my ( $address, $level, $mode ) = $mail->Get();
		if ( ( $level > 1 ) or ( $self->GetState() > 1 ) or ( ( $level == 1 ) and ( $self->GetState() == 1 ) ) )
		{
			my ( $tableentry, $html, $plaintext );
			my ( $tablestat ) = 0;
			$plaintext = "----------------------------------------------------------------\n"
			. "| " . sprintf("%-49s","Backup report ( Level : $level )") . "			|\n"
			. "----------------------------------------------------------------\n";
			$html = "<table style=\"width: 80%; text-align: left;\" border=\"2\" cellpadding=\"2\"\n"
			. "cellspacing=\"2\">\n"
			. "<tbody>"
			. "<tr align=\"center\">\n"
			. "<th colspan=\"4\" rowspan=\"1\" style=\"background-color: rgb(255, 255, 204); vertical-align: top;\">"
			. "<font size=\"+2\">Backup report </font>"
			. "<div align=\"right\"><font size=\"-2\" color=\"#888888\"> [ Level : $level - Version: $version - IP: " . $self->GetIP() . " ]</font></div>"
			. "\n"
			. "</th>\n"
			. "</tr>\n"
			. "<tr>\n"
			. "<th style=\"vertical-align: top; text-align: center;\">Operation<br>\n"
			. "</th>\n"
			. "<th style=\"vertical-align: top; width: 130px; text-align: center;\">Date/Time<br>\n"
			. "</th>\n"
			. "<th style=\"vertical-align: top; width: 120px; text-align: center;\">Size (Use%)<br>\n"
			. "</th>\n"
			. "<th style=\"vertical-align: top; width: 100px; text-align: center;\">Status<br>\n"
			. "</th>"
			. "</tr>\n";
			my ( $notempty ) = 0;
			foreach $tableentry ( @{$self->{_table}} )
			{
				$notempty = 1;
				my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree ) = $tableentry->Get();
				my ( $text ) = "[" . $section . "] " . $name;
				my ( $date ) = substr( $timestamp, 0,2 ) . "/" . substr( $timestamp, 2,2 ) . "/" . substr( $timestamp, 4,4 ) . " " . substr( $timestamp, 8,2 ) . ":" . substr( $timestamp, 10,2 );
				$plaintext .= "| " . sprintf("%-35s" ,$text . " Date : " . $date );
				$html .= "<tr>\n" . "<td style=\"vertical-align: top;\">$text<br>\n" . "</td>\n";
				$html .= "<td style=\"vertical-align: top;\">$date<br>\n" . "</td>\n";
				$html .= "<td style=\"vertical-align: middle; margin: 0 0 0 0; border: 1; padding: 0; width: 104px; background: rgb(120,120,255)\">";
				if ( $destsize ne 0 )
				{
					$html .= "<div>\n";
				};
				$html .= ::HumanBytes( $size );
				if ( $destsize ne 0 )
				{
					$html .= "&nbsp;(" . int( 100 - ($destfree / $destsize)*100) . "%)\n";
					$html .= "<div nowrap style=\"background: rgb(255,0,0); color: rgb(255,255,0); overflow: hidden; border: 1; margin: 0px 0px 0px 0px; height: 2px; padding: 0; width: " . int( 100 - ($destfree / $destsize)*100)  . "% \">";
					$html .= "</div>\n</div>\n";
				}
				$html .= "</td>\n";
				if ( $status eq "OK" )
				{
					$html .= "<td style=\"background-color: rgb(51, 255, 51); vertical-align: top; width: 100px; text-align: center;\">OK<br>\n";
					$plaintext .= "| " . sprintf("%11s"," - OK - ") . " |\n"
					. "----------------------------------------------------------------\n";
				}
				elsif ( $status eq "Warning" )
				{
					$html .= "<td style=\"background-color: rgb(255, 153, 0); vertical-align: top; width: 100px; text-align: center;\">Warning<br>\n";
					$plaintext .= "| " . sprintf("%11s","  Warning  ") . " |\n"
					. "----------------------------------------------------------------\n";
				}
				else
				{
					$html .= "<td style=\"background-color: rgb(255, 0, 0); vertical-align: top; width: 100px; text-align: center;\">ERROR<br>\n";
					$plaintext .= "| " . sprintf("%11s"," * ERROR * ") . " |\n"
					. "----------------------------------------------------------------\n"
					. "[ Level : $level - Version: $version - IP: " . $self->GetIP() . " ]";
				};
				$html .= "</td>\n"
				."</tr>\n";
			};
			$plaintext .= "\n";
			$plaintext .= $mailtext;
			$html .= "</tbody>\n" . "</table>\n" . "<br>\n";
			$html .= "<br>\n";
			$html .= "$mailtext<br>\n";
			if ( $mode  eq "html" )
			{
				$plaintext = "Only html reports for this e-mail";
			}
			elsif ( $mode eq "plain" )
			{
				$html = "Only plaintext reports for this e-mail";
			};
			if ( $notempty == 1 )
			{
				$mailstat = $self->MailReport( $address, $subject , $html, $plaintext, $self->GetState(), $level );
			}
			else
			{
				$mailstat = 1;
			};
		};
	};
	return ( $mailstat );
};
sub MailReport
{
	my ( $self ) = shift;
	my ( $mailaddr, $subject, $html, $plain, $state, $level ) = @_;
	my ( $rc );
	my ( $tableentry );
	my ( $configfilename ) =  $cmdln->GetConfigFileName();
	my ( $cfg, $mastercfg );
	if ( -r "/etc/bck/bck.default" )
	{
		  $mastercfg  = Config::IniFiles->new( -file => "/etc/bck/bck.default" );
		  $cfg = Config::IniFiles->new( -file => $configfilename, -import => $mastercfg );
	}
	else
	{
		$cfg 	= Config::IniFiles->new( -file => $configfilename );
	};
	my ( $smtpserver ) = $cfg->val( 'global', 'smtpserver' );
	my ( $smtpuser )	= $cfg->val( 'global', 'smtpuser' );
	my ( $smtppass )	= $cfg->val( 'global', 'smtppass' );
	my ( $smtpfrom ) 	= $cfg->val( 'global', 'smtpfrom' );
	my ( $smtpport )	= $cfg->val( 'global', 'smtpport' );
	my $sm = SendMail->new( $smtpserver, $smtpport );
	#
	#
	# Set SMTP AUTH login profile.
	#
	$sm->setAuth($sm->AUTHLOGIN, $smtpuser , $smtppass);
	#$sm->setAuth($sm->AUTHPLAIN, $smtpuser , $smtppass );
	#
	# We set the debug mode to global debug flag [$cmdln->GetDebugFlag()].
	#
	if ( $cmdln->GetDebugFlag() )
	{
	    $sm->setDebug($sm->ON);
	}
	else
	{
	    $sm->setDebug($sm->OFF);
	}
	#
	# We set the sender.
	#
	$sm->From($smtpfrom);
	#
	# We set the subject.
	#
	$sm->Subject($subject);
	#
	# We set the recipient.
	#
	$sm->To($mailaddr);
	#
	# We set the mail headers
	#
	$sm->setMailHeader('X-Mailer', "bck mailobject " . $sm->version . "");
	$sm->setMailHeader('User-Agent', "bck $version");
	$sm->setMailHeader('Message-Id',"BCK". join("", ('a'..'z','A'..'Z', 0..9)[map rand $_, (62)x25]));
	my ($mytime);
	my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = localtime( time );
	$mytime = $mday . "/" . ( $mon + 1 ) . "/" . ( $year + 1900 ) . " " . $hour . ":" . $min . ":" . $sec . " (" . ($wday) . ")";
	#$sm->setMailHeader('Date' , $mytime );
	#
	# We set the content of the mail.
	#
	# Set body content
	#
	$html = "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
		."<html>\n"
		."<head>\n"
		."<meta content=\"text/html; charset=ISO-8859-1\"\n"
		."http-equiv=\"content-type\">\n"
		."<title></title>\n"
		."</head>\n"
		."<body>\n"
		."$html"
		."</body>\n"
		."</html>\n";
	my($boundary) = "==__BCK__" . join("", ('a'..'z','A'..'Z', 0..9)[map rand $_, (62)x25]) . "__==";
	my ( $mailbody );
	$mailbody = 'Content-Type: multipart/alternative;';
	$mailbody .= "\r\n boundary=\"$boundary\"\r\n\r\n";
	$mailbody .= "--$boundary\r\n";
	$mailbody .= 'Content-Type: text/plain; charset=ISO-8859-1; format=flowed' . "\r\n";
	$mailbody .= 'Content-Transfer-Encoding: 7bit' . "\r\n\r\n";
	$mailbody .= $plain . "\r\n";
	$mailbody .= "--$boundary\r\n";
	$mailbody .= 'Content-Type: text/html; charset=ISO-8859-1;' . "\r\n";
	$mailbody .= 'Content-Transfer-Encoding: 7bit' . "\r\n\r\n";
	$mailbody .= $html . "\r\n\r\n";
	$mailbody .= "--$boundary--\r\n";
	$sm->setMailBody( $mailbody );
	# Clear attachments
	#$sm->clearAttach();
	#
	# Attach log as a file.
	#
	#$sm->Inline("log.txt", \$test);
	#
	# To attach config file, uncomment this.
	#
	if ( $level > 3 )
	{
		$sm->Inline( $configfilename );
	};
	if ( $level > 1 )
	{
		foreach $tableentry ( @{$self->{_table}} )
		{
			my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree ) = $tableentry->Get();
			$sm->Inline( $gsection->GetLogDir() . '/' . $section . '.' . $timestamp . '.log' );
		};
	};
	if ( $level > 2 )
	{
		foreach $tableentry ( @{$self->{_table}} )
		{
			my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree ) = $tableentry->Get();
			$sm->Attach( $gsection->GetLogDir() . '/' . $section . '.' . $timestamp . '.lst' );
		};
	};
	#
	# Check if the mail sent successfully or not.
	#
	if ($sm->sendMail() != 0)
	{
		$rc = 1;
	}
	else
	{
		$rc = 0;
	};
	return( $rc );
};
##################################################################################
# End Class Report
##################################################################################
##################################################################################
#
# Class Mail : Mail container class
#
##################################################################################
package Mail;
sub new
{
	my ( $class ) = shift;
	my ( $address, $level, $mode) = @_;
	my $self =
	{
		_address	=> $address,
		_lvl		=> $level,
		_mode 		=> $mode,
		};
	bless $self, $class;
	return $self;
};
#accessor method for address
sub Get
{
	my ( $self ) = shift;
	return ( $self->{_address}, $self->{_lvl}, $self->{_mode} );
};
##################################################################################
# End Class Mail
##################################################################################
##################################################################################
#
# Class TableLine : TableLine class
#
##################################################################################
package TableLine;
sub new
{
	my ( $class ) = shift;
	my ( $section, $name, $timestamp, $status, $size, $destsize, $destfree) = @_;
	my $self =
	{
		_section	=> $section,
		_name		=> $name,
		_timestamp	=> $timestamp,
		_status		=> $status,
		_size		=> $size,
		_destsize	=> $destsize,
		_destfree	=> $destfree
		};
	bless $self, $class;
	return $self;
};
#accessor method for tableline
sub Get
{
	my ( $self ) = shift;
	return ( $self->{_section}, $self->{_name}, $self->{_timestamp}, $self->{_status}, $self->{_size}, $self->{_destsize}, $self->{_destfree} );
};
##################################################################################
# End Class TableLine
##################################################################################
##################################################################################
#
# Class SendMail : Sendmail object
#
##################################################################################
#
#
##################################################################################
#
# Code taken from perl modules below this line!
#
##################################################################################
package SendMail;
#===============================================================================
#
# Constructor:
#	$obj = new SendMail;
#	$obj = new SendMail($smtpserver);
#	$obj = new SendMail($smtpserver, $smtpport);
#
# Methods:
#	$obj->Attach($filename, [\$data]);
#	$obj->Bcc($bccemailadd1, [$bccemailadd2, ...]);
#	$obj->Cc($ccemailadd1, [$ccemailadd2, ...]);
#	$obj->ErrorsTo($errorstoadd1, [$errorstoadd2, ...]);
#	$obj->From($sender);
#	$obj->Inline($filename, [\$data]);
#	$obj->AUTHLOGIN;
#	$obj->AUTHPLAIN;
#	$obj->OFF;
#	$obj->ON;
#	$obj->ReplyTo($replytoadd1, [$replytoadd2, ...]);
#	$obj->Subject($subject);
#	$obj->To($recipient1, [$recipient2, ...]);
#	$obj->attach(\%hash);
#	$obj->clearAttach();
#	$obj->clearBcc();
#	$obj->clearCc();
#	$obj->clearTo();
#	$obj->createMailData();
#	$obj->getEmailAddress($emailaddstr);
#	$obj->getRcptLists();
#	$obj->isMailReady();
#	$obj->receiveFromServer(\*SOCKET);
#	$obj->reset();
#	$obj->sendMail();
#	$obj->sendToServer(\*SOCKET, $message);
#	$obj->setAuth($authtype, $userid, $password);
#	$obj->setDebug($obj->ON);
#	$obj->setError($errormessage);
#	$obj->setMailBody($htmlbody, $plainbody);
#	$obj->setMailHeader($mailheader, $mailheadervalue);
#	$obj->setSMTPPort($smtpport);
#	$obj->setSMTPServer($smtpserver);
#	$obj->version;
#
# *p/s: For more details, please refer to the description below.
#
#===============================================================================

#
# We are using Socket.pm to connect to the SMTP port.
#
use Socket;

#
# We are using MIME::Base64 and MIME::QuotedPrint to encode MIME data.
#
use MIME::Base64;
use MIME::QuotedPrint;

#use Exporter;
use strict;
#use vars qw($_LOCALHOST $VERSION $_MAILER @ISA @EXPORT @EXPORT_OK $_ERR);
#use vars qw($_DEFAULT_SMTP_PORT);
#@EXPORT = qw();
#@EXPORT_OK = qw();
my ($_LOCALHOST, $ver, $_MAILER,$_ERR,$_DEFAULT_SMTP_PORT);


#===============================================================================
#
# CONSTRUCTOR:	$obj = new SendMail;
#		$obj = new SendMail($smtpserver);
#		$obj = new SendMail($smtpserver, $smtpport);
#
# DESCRIPTION:	This is the constructor of the SendMail object.
#
#===============================================================================
sub new {
	my($pkg) 		= shift;
	my($smtpserver) 	= shift;
	my($smtpport) 	= shift;
	my($self) 		= {};
	bless $self, $pkg;
	$ver = "2.09";
	$_DEFAULT_SMTP_PORT = 25;
	$_MAILER  = "Bck Sendmail($ver)";
	#
	# The mail server.
	#
	$self->{'smtpserver'}  = ($smtpserver && $smtpserver !~ /^\s*$/) ? $smtpserver : "localhost";
	#
	# The port number for smtp.
	#
	$self->{'smtpport'}	= ($smtpport && $smtpport =~ /^\d+$/) ? $smtpport :
		$_DEFAULT_SMTP_PORT;
	#
	# The default debug mode is "OFF".
	#
	$self->{'debugmode'}   = $self->OFF;
	#
	# Set the default mailer.
	#
	$self->setMailHeader("X-MAILER", $_MAILER);
	#
	# Create empty attachment array.
	#
	$self->{'attachmentArr'} = [];
	#
	# SMTP AUTH
	#
	$self->{'authtype'} = "";
	$self->{'authuserid'} = "";
	$self->{'authpassword'} = "";
	$self->{'log'} = "";
	#
	# Some of the SMTP server needs to say "HELO domain.address".
	#
	eval {
		require Sys::Hostname;
		$_LOCALHOST = Sys::Hostname::hostname();
	};
	$_LOCALHOST = $_MAILER if $@;
	return $self;
}

#===============================================================================
#
# METHOD:	$obj->Attach($filename, [\$data]);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of
#		reading from the file.
#
#===============================================================================
sub Attach ($;$) {
	my($self) = shift;
	my($filename) = shift;
	my($dataRef) = shift;
	my(%hash, $dump);
	return $self->setError("No attachment has been specified.")
	if $filename =~ /^\s*$/;
	if ($filename =~ /(\\|\/)/) {
	  ($hash{'filename'}) = $filename =~ /^.*[\\\/]([^\\\/]+)$/;
	}
	else {
	  $hash{'filename'} = $filename;
	}
	$hash{'filepath'} = $filename;
	$hash{'dataref'} = $dataRef if ref($dataRef) !~ /^\s*$/;
	$hash{'attachtype'} = "attachment";
	return $self->attach(\%hash);
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->Bcc($bccemailadd1, [$bccemailadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the blind carbon copy
#		list.
#
#===============================================================================
sub Bcc ($) {
	my($self)	  = shift;
	my(@bcc)	   = @_;
	my($currEmail) = undef;
	for $currEmail (@bcc) {
	  push(@{$self->{'mailheaders'}->{'BCC'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->Cc($ccemailadd1, [$ccemailadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the carbon copy list.
#
#===============================================================================
sub Cc ($) {
	my($self)	  = shift;
	my(@cc)		= @_;
	my($currEmail) = undef;
	for $currEmail (@cc) {
	  push(@{$self->{'mailheaders'}->{'CC'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->ErrorsTo($errorstoadd1, [$errorstoadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address into the "Errors-To" list.
#
#===============================================================================
sub ErrorsTo ($) {
	my($self)	  = shift;
	my(@errorsto)  = @_;
	my($currEmail) = undef;
	for $currEmail (@errorsto) {
	  push(@{$self->{'mailheaders'}->{'ERRORS-TO'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->From($sender);
#
# DESCRIPTION:	Set the sender of the email.
#
#===============================================================================
sub From ($) {
	my($self) = shift;
	my($from) = shift;
	$self->{'mailheaders'}->{'FROM'} = $from;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->Inline($filename, [\$data]);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of
#		reading from the file.
#
#===============================================================================
sub Inline ($;$) {
	my($self) = shift;
	my($filename) = shift;
	my($dataRef) = shift;
	my(%hash, $dump);
	return $self->setError("No attachment has been specified.")
	if $filename =~ /^\s*$/;
	if ($filename =~ /(\\|\/)/) {
	  ($hash{'filename'}) = $filename =~ /^.*[\\\/]([^\\\/]+)$/;
	}
	else {
	  $hash{'filename'} = $filename;
	}
	$hash{'filepath'} = $filename;
	$hash{'dataref'} = $dataRef if ref($dataRef) !~ /^\s*$/;
	$hash{'attachtype'} = "inline";
	return $self->attach(\%hash); print $hash{'dataref'};
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->OFF;
#
# DESCRIPTION:	Will return 0. Basically, it is used to set the debug mode OFF.
#		Eg. $obj->setDebug($obj->OFF);
#
#===============================================================================
sub OFF () {
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->ON;
#
# DESCRIPTION:	Will return 1. Basically, it is used to set the debug mode ON.
#		Eg. $obj->setDebug($obj->ON);
#
#===============================================================================
sub ON () {
	return 1;
}
#===============================================================================
#
# METHOD:	$obj->AUTHLOGIN;
#
# DESCRIPTION:	Will return string 'AUTH LOGIN'.
#		Eg. $obj->setAuth($obj->AUTHLOGIN, $userid, $password);
#
#===============================================================================
sub AUTHLOGIN () {
  return 'AUTH LOGIN';
}
#===============================================================================
#
# METHOD:	$obj->AUTHPLAIN;
#
# DESCRIPTION:	Will return string 'AUTH PLAIN'.
#		Eg. $obj->setAuth($obj->AUTHPLAIN, $userid, $password);
#
#===============================================================================
sub AUTHPLAIN () {
  return 'AUTH PLAIN';
}
#===============================================================================
#
# METHOD:	$obj->ReplyTo($replytoadd1, [$replytoadd2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address into the "Reply-To" list.
#
#===============================================================================
sub ReplyTo ($;@) {
	my($self)	  = shift;
	my(@replyto)   = @_;
	push(@{$self->{'mailheaders'}->{'REPLY-TO'}}, @replyto);
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->Subject($subject);
#
# DESCRIPTION:	Set the subject of the email.
#
#===============================================================================
sub Subject ($) {
	$_[0]->{'mailheaders'}->{'SUBJECT'} = $_[1];
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->To($recipient1, [$recipient2, ...]);
#
# DESCRIPTION:	Add a list of the name/email address to the recipient list.
#
#===============================================================================
sub To ($;@) {
	my($self)	  = shift;
	my(@to)		= @_;
	for (@to) {
	  my($currEmail) = $_;
	  push(@{$self->{'mailheaders'}->{'TO'}}, $currEmail) if
		($self->getEmailAddress($currEmail) !~ /^\s*$/);
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->attach(\%hash);
#
# DESCRIPTION:	This method will attach file to the mail. If the data has been
#		specified, will use the filename and the data, instead of
#		reading from the file.
#
#===============================================================================
sub attach ($) {
	my($self) = shift;
	my($dataRef) = shift;
	return $self->setError("No attachment has been specified.")
	if $dataRef->{'filename'} =~ /^\s*$/;
	push(@{$self->{'attachmentArr'}}, $dataRef);
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->clearAttach();
#
# DESCRIPTION:	This method will clear the attachment stack.
#
#===============================================================================
sub clearAttach () {
	my($self) = shift;
	$self->{'attachmentArr'} = [];
}
#===============================================================================
#
# METHOD:	$obj->clearBcc();
#
# DESCRIPTION:	This method will clear the email addresses specified for Bcc:.
#
#===============================================================================
sub clearBcc () {
	my($self) = shift;
	$self->{'mailheaders'}->{'BCC'} = [];
}
#===============================================================================
#
# METHOD:	$obj->clearCc();
#
# DESCRIPTION:	This method will clear the email addresses specified for Cc:.
#
#===============================================================================
sub clearCc () {
	my($self) = shift;
	$self->{'mailheaders'}->{'CC'} = [];
}
#===============================================================================
#
# METHOD:	$obj->clearTo();
#
# DESCRIPTION:	This method will clear the email addresses specified for To:.
#
#===============================================================================
sub clearTo () {
	my($self) = shift;
	$self->{'mailheaders'}->{'TO'} = [];
}
#===============================================================================
#
# METHOD:	$obj->createMailData();
#
# DESCRIPTION:	This method will create the mail data which will be sent to the
#		SMTP server. It will contain some mail headers and mail body.
#
#===============================================================================
sub createMailData () {
	my($self) = shift;
	my($currHeader) = undef;
	return -1 if $self->isMailReady() != 0;
	$self->{'maildata'} = undef;
	$self->{'maildata'} = "To: ";
	$self->{'maildata'} .= join(",\r\n\t", @{$self->{'mailheaders'}->{'TO'}});
	$self->{'maildata'} .= "\r\nFrom: ".$self->{'mailheaders'}->{'FROM'}."\r\n";
	if (defined $self->{'mailheaders'}->{'CC'} &&
		@{$self->{'mailheaders'}->{'CC'}} > 0) {
	  $self->{'maildata'} .= "Cc: ";
	  $self->{'maildata'} .= join(",\r\n\t", @{$self->{'mailheaders'}->{'CC'}});
	  $self->{'maildata'} .= "\r\n";
	}
	if (defined $self->{'mailheaders'}->{'REPLY-TO'} &&
		@{$self->{'mailheaders'}->{'REPLY-TO'}} > 0) {
	  $self->{'maildata'} .= "Reply-To: ";
	  $self->{'maildata'} .= join(",\r\n\t",
		@{$self->{'mailheaders'}->{'REPLY-TO'}})."\r\n";
	}
	if (defined $self->{'mailheaders'}->{'ERRORS-TO'} &&
		@{$self->{'mailheaders'}->{'ERRORS-TO'}} > 0) {
	  $self->{'maildata'} .= "Errors-To: ";
	  $self->{'maildata'} .= join(",\r\n\t",
		@{$self->{'mailheaders'}->{'ERRORS-TO'}})."\r\n";
	}
	for $currHeader (sort keys %{$self->{'mailheaders'}->{'OTHERS'}}) {
	  my($currMailHeader) = undef;
	  ($currMailHeader = $currHeader) =~ s/\b(\w)(\w+)\b/$1\L$2/g;
	  $self->{'maildata'} .= "$currMailHeader: ";
	  $self->{'maildata'} .= $self->{'mailheaders'}->{'OTHERS'}->{$currHeader};
	  $self->{'maildata'} .= "\r\n";
	};
	$self->{'maildata'} .= "Subject: ".$self->{'mailheaders'}->{'SUBJECT'};
	if (scalar(@{$self->{'attachmentArr'}}) > 0) {
	  my($currHash);
	  srand(time ^ $$);
	  my($boundary) = "==__BCK__".
		join("", ('a'..'z','A'..'Z', 0..9)[map rand $_, (62)x25]).
		"__==";
	  $self->{'maildata'} .= "\r\nMIME-Version: 1.0\r\n";
	  $self->{'maildata'} .= "Content-Type: multipart/mixed; ";
	  $self->{'maildata'} .= "boundary=\"$boundary\"\r\n";
	  $self->{'maildata'} .= "\r\n";
	  if (defined $self->{'mailbody'}) {
		$self->{'maildata'} .= "\-\-$boundary\r\n";
		#$self->{'maildata'} .= "Content-Type: text/plain; charset=\"iso-8859-1\"\r\n";
		#$self->{'maildata'} .= "Content-Transfer-Encoding: base64\r\n\r\n";
		$self->{'maildata'} .= $self->{'mailbody'} . "\r\n\r\n";
	  }
	  for $currHash (@{$self->{'attachmentArr'}}) {
		$currHash->{'content-type'} =
		$self->getMIMEType($currHash->{'filename'});
		$self->{'maildata'} .= "\-\-$boundary\r\n";
		$self->{'maildata'} .= "Content-Type: $currHash->{'content-type'}; name=\"$currHash->{'filename'}\"\r\n";
		$self->{'maildata'} .= "Content-Transfer-Encoding: base64\r\n";
		$self->{'maildata'} .= "Content-Disposition: $currHash->{'attachtype'}; filename=\"$currHash->{'filename'}\"\r\n";
		$self->{'maildata'} .= "\r\n";
	if (defined $currHash->{'dataref'}) {
	  if (ref($currHash->{'dataref'}) eq "SCALAR") {
		$self->{'maildata'} .= encode_base64(${$currHash->{'dataref'}}, "\r\n");
	  }
	  else {
		my($data) = undef;
		my($buff) = "";
		my($pos) = 0;
		(defined ($pos = tell($currHash->{'dataref'}))) ||
			return $self->setError("Error in tell(): $!");
		while (read($currHash->{'dataref'}, $buff, 1024)) {
		  $data .= $buff;
			}
		$self->{'maildata'} .= encode_base64($data, "\r\n");
		seek($currHash->{'dataref'}, $pos, 0) ||
			return $self->setError("Error in seek(): $!");
	  }
	}
	elsif (-f $currHash->{'filepath'}) {
		  my($data) = undef;
	  my($buff) = "";
		  open(FILE, $currHash->{'filepath'});
	  # In Windows platform, non-text file should use binmode() function.
	  if (! -T $currHash->{'filepath'}) {
		binmode(FILE);
	  }
	  while (sysread(FILE, $buff, 1024)) {
		$data .= $buff;
		  }
		  close(FILE);
		  $self->{'maildata'} .= encode_base64($data, "\r\n");
	}
	else {
	  $self->{'maildata'} .= encode_base64("", "\r\n");
	}
		$self->{'maildata'} .= "\r\n";
	  }
	  $self->{'maildata'} .= "\-\-${boundary}\-\-\r\n";
	}
	else {
	  my($tmpbody) = $self->{'mailbody'};
	  #$tmpbody =~ s/([^\r])\n/$1\r\n/g;
	  $self->{'maildata'} .= "\r\n";
	  $self->{'maildata'} .= "$tmpbody\r\n";
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->getEmailAddress($emailaddstr);
#
# DESCRIPTION:	Get the email address from the email address string which might
#		contain email account owner's name, what we want is the email
#		address only.
#
#===============================================================================
sub getEmailAddress ($) {
	my($self)  = shift;
	my($value) = shift;
	my($retvalue) = undef;
	if ($value =~ /^\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/) {
	  ($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
	  return $retvalue;
	}
	if ($value =~ /^[^\<]+\<([^\>\@]+\@[\w\-]+(\.[\w\-]+)+)\>/) {
	  ($retvalue = $1) =~ tr/[A-Z]/[a-z]/;
	  return $retvalue;
	}
	return "" if $value =~ /\s+/;
	$value =~ tr/[A-Z]/[a-z]/;
	return $value if $value =~ /^[^\@]+\@[\w\-]+(\.[\w\-]+)+$/;
	return "";
}
#===============================================================================
#
# METHOD:	$obj->getMIMEType($filename);
#
# DESCRIPTION:	This will return MIME type for $filename.
#
#===============================================================================
sub getMIMEType ($) {
	my($self) = shift;
	my($filename) = shift;
	my($ext, %MIMEHash);
	%MIMEHash = (
	'au'	=> 'audio/basic',
	'avi'	=> 'video/x-msvideo',
	'class'	=> 'application/octet-stream',
	'cpt'	=> 'application/mac-compactpro',
	'dcr'	=> 'application/x-director',
	'dir'	=> 'application/x-director',
	'doc'	=> 'application/msword',
	'exe'	=> 'application/octet-stream',
	'gif'	=> 'image/gif',
	'gtx'	=> 'application/x-gentrix',
	'jpeg'	=> 'image/jpeg',
	'jpg'	=> 'image/jpeg',
	'js'	=> 'application/x-javascript',
	'log'	=> 'text/plain',
	'lst'	=> 'text/plain',
	'hqx'	=> 'application/mac-binhex40',
	'htm'	=> 'text/html',
	'html'	=> 'text/html',
	'mid'	=> 'audio/midi',
	'midi'	=> 'audio/midi',
	'mov'	=> 'video/quicktime',
	'mp2'	=> 'audio/mpeg',
	'mp3'	=> 'audio/mpeg',
	'mpeg'	=> 'video/mpeg',
	'mpg'	=> 'video/mpeg',
	'pdf'	=> 'application/pdf',
	'pm'	=> 'text/plain',
	'pl'	=> 'text/plain',
	'ppt'	=> 'application/powerpoint',
	'ps'	=> 'application/postscript',
	'qt'	=> 'video/quicktime',
	'ram'	=> 'audio/x-pn-realaudio',
	'rtf'	=> 'application/rtf',
	'tar'	=> 'application/x-tar',
	'tif'	=> 'image/tiff',
	'tiff'	=> 'image/tiff',
	'txt'	=> 'text/plain',
	'wav'	=> 'audio/x-wav',
	'xbm'	=> 'image/x-xbitmap',
	'zip'	=> 'application/zip',
	);
	($ext) = $filename =~ /\.([^\.]+)$/;
	$ext =~ tr/[A-Z]/[a-z]/;
	return defined $MIMEHash{$ext} ? $MIMEHash{$ext} : "application/octet-stream";
}
#===============================================================================
#
# METHOD:	$obj->getRcptLists();
#
# DESCRIPTION:	This will generate an array of the recipients' email address.
#		Basically, this method only called by $obj->sendMail() method,
#		which needs to send "RCPT TO:" request to the SMTP server.
#
#===============================================================================
sub getRcptLists () {
	my($self) = shift;
	my(@rcptLists) = ();
	my($currEmail) = undef;
	for $currEmail (@{$self->{'mailheaders'}->{'TO'}}) {
	  my($currEmail) = $self->getEmailAddress($currEmail);
	  push(@rcptLists, $currEmail) if
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
	}
	if (defined $self->{'mailheaders'}->{'BCC'} &&
		@{$self->{'mailheaders'}->{'BCC'}} > 0) {
	  for $currEmail (@{$self->{'mailheaders'}->{'BCC'}}) {
		my($currEmail) = $self->getEmailAddress($currEmail);
		push(@rcptLists, $currEmail) if
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
	  }
	}
	if (defined $self->{'mailheaders'}->{'CC'} &&
		@{$self->{'mailheaders'}->{'CC'}} > 0) {
	  for $currEmail (@{$self->{'mailheaders'}->{'CC'}}) {
		my($currEmail) = $self->getEmailAddress($currEmail);
		push(@rcptLists, $currEmail) if
		($currEmail !~ /^\s*$/ && (! grep(/^$currEmail$/, @rcptLists)));
	  }
	}
	return \@rcptLists;
}
#===============================================================================
#
# METHOD:	$obj->isMailReady();
#
# DESCRIPTION:	Check if the basic mail headers and the mail body have been set
#		or not.
#		p/s: The "From:", "To:" and "Subject:" mail headers are required
#		here, I feel that a mail should contain these headers. It is
#		just a personal opinion, if you do not think so, just comment
#		them out.
#
#===============================================================================
sub isMailReady () {
	my($self) = shift;
	return $self->setError("No sender has been specified.") if
	! defined $self->{'mailheaders'}->{'FROM'};
	return $self->setError("No recipient has been specified.") if
	((! defined $self->{'mailheaders'}->{'TO'}) ||
		(defined @{$self->{'mailheaders'}->{'TO'}} &&
		 @{$self->{'mailheaders'}->{'TO'}} < 1));
	return $self->setError("No subject has been specified.") if
	! defined $self->{'mailheaders'}->{'SUBJECT'};
	return $self->setError("No mail body has been set.") if
	((! defined $self->{'mailbody'}) &&
		(scalar(@{$self->{'attachmentArr'}}) < 1));
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->receiveFromServer(\*SOCKET);
#
# DESCRIPTION:	This will receive the data replied from the server.
#
#===============================================================================
sub receiveFromServer ($) {
	my($self) = shift;
	my($socket) = shift;
	my($reply);
	#
	# We keep receiveing the data from the server until
	# it waits for next command.
	#
	while ($socket && ($reply = <$socket>)) {
	  return $self->setError($reply) if $reply =~ /^5/;
	  print $reply if $self->{'debugmode'};
	  $self->{'log'} .= $reply;
	  last if $reply =~ /^\d+ /;
	}
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->reset();
#
# DESCRIPTION:	This will clear the data that have been set before.
#
#===============================================================================
sub reset () {
	my($self) = shift;
	$self->{'debugmode'} = $self->OFF;
	$self->{'mailbody'} = undef;
	$self->{'maildata'} = undef;
	$self->{'mailheaders'} = undef;
	$self->{'sender'} = undef;
	$self->{'attachmentArr'} = [];
	$self->{'authtype'} = "";
	$self->{'authuserid'} = "";
	$self->{'authpassword'} = "";
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->sendMail();
#
# DESCRIPTION:	This will use the Socket to connect to the SMTP port to send the
#		mail.
#
#===============================================================================
sub sendMail () {
	my($self) = shift;
	my($iaddr, $paddr, $proto, $rcptlistRef, $currEmail) = undef;
	#
	# Get the sender's email address, this will be used in "MAIL FROM:" request.
	#
	$self->{'sender'} = $self->getEmailAddress($self->{'mailheaders'}->{'FROM'});
	#
	# Invalid email address format.
	#
	return $self->setError("Please check the sender's email address setting.")
	if $self->{'sender'} =~ /^\s*$/;
	#
	# We create the mail data here.
	#
	return -1 if $self->createMailData() != 0;
	#
	# We get the recipients' email addresses.
	#
	$rcptlistRef = $self->getRcptLists();
	#
	# If no recipient has been specified, this is an error.
	#
	return $self->setError("No recipient has been specified.") if
		@{$rcptlistRef} == 0;
	#
	# Please refer to Socket module manual. (perldoc Socket)
	#
	$iaddr = inet_aton($self->{'smtpserver'}) ||
		return $self->setError("no host: $self->{'smtpserver'}, please specify SMTP server with \"\$obj = new SendMail('your.smtp.server');\"");
	$paddr = sockaddr_in($self->{'smtpport'}, $iaddr);
	$proto = getprotobyname('tcp');
	socket(SOCK, PF_INET, SOCK_STREAM, $proto) ||
		return $self->setError("Socket error: $!");
	connect(SOCK, $paddr) ||
	return $self->setError("Error in connecting to $self->{'smtpserver'} at port $self->{'smtpport'}: $!");
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	return -1 if $self->sendToServer(\*SOCK, "EHLO $_LOCALHOST") != 0;
	if ($self->receiveFromServer(\*SOCK) != 0) {
	  return -1 if $self->sendToServer(\*SOCK, "HELO $_LOCALHOST") != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	}
	#
	# SMTP AUTH LOGIN type.
	#
	if ($self->{'authtype'} eq $self->AUTHLOGIN) {
	  return -1 if $self->sendToServer(\*SOCK, $self->{'authtype'});
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	  return -1 if $self->sendToServer(\*SOCK,
		encode_base64($self->{'authuserid'}, "")) != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	  return -1 if $self->sendToServer(\*SOCK,
		encode_base64($self->{'authpassword'}, "")) != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	}
	#
	# SMTP AUTH PLAIN type.
	#
	if ($self->{'authtype'} eq $self->AUTHPLAIN) {
	  return -1 if $self->sendToServer(\*SOCK,
		$self->{'authtype'}." ".
		encode_base64(
			join("\0", "", $self->{'authuserid'},
			$self->{'authpassword'}), "")) != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	}
	return -1 if $self->sendToServer(\*SOCK, "MAIL FROM: <$self->{'sender'}>") != 0;
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	for $currEmail (@{$rcptlistRef}) {
	  return -1 if $self->sendToServer(\*SOCK, "RCPT TO: <$currEmail>") != 0;
	  return -1 if $self->receiveFromServer(\*SOCK) != 0;
	}
	return -1 if $self->sendToServer(\*SOCK, "DATA") != 0;
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	return -1 if $self->sendToServer(\*SOCK, "$self->{'maildata'}\r\n.") != 0;
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	return -1 if $self->sendToServer(\*SOCK, "QUIT") != 0;
	return -1 if $self->receiveFromServer(\*SOCK) != 0;
	eof(SOCK) || close(SOCK) ||
	return $self->setError("Fail close connectiong socket: $!");
	print "The mail has been sent to ".scalar(@{$rcptlistRef}) if
		$self->{'debugmode'};
	$self->{'log'} .= "The mail has been sent to ".scalar(@{$rcptlistRef});
	print " person/s successfully.\n" if $self->{'debugmode'};
	$self->{'log'} .= " person/s successfully.";
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setAuth($authtype, $userid, $password);
#
# DESCRIPTION:	This will set the authentication information.
#		$obj->setAuth($obj->AUTHLOGIN, $userid, $password);
#		$obj->setAuth($obj->AUTHPLAIN, $userid, $password);
#
#===============================================================================
sub setAuth ($$$) {
	my($self) = shift;
	$self->{'authtype'} = shift;
	$self->{'authuserid'} = shift;
	$self->{'authpassword'} = shift;
}
#===============================================================================
#
# METHOD:	$obj->sendToServer(\*SOCKET, $message);
#
# DESCRIPTION:	This will send the message to the SMTP server.
#
#===============================================================================
sub sendToServer ($$) {
	my($self) = shift;
	my($socket) = shift;
	my($message) = shift;
	print "$message\r\n" if $self->{'debugmode'};
	#$self->{'log'} .= "$message\r\n";
	# Fix BareLf problem.
	$message =~ s/\n/\r\n/g;
	$message =~ s/\r\r\n/\r\n/g;
	#
	# Sending data to the server.
	#
	send($socket, "$message\r\n", 0) ||
		return $self->setError("Fail to send $message: $!");
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setDebug($obj->ON);
#		$obj->setDebug($obj->OFF);
#
# DESCRIPTION:	Set the debug mode as ON/OFF.
#		Also see: $obj->ON and $obj->OFF methods.
#
#===============================================================================
sub setDebug ($) {
	my($self) = shift;
	$self->{'debugmode'} = shift;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setError($errormessage);
#
# DESCRIPTION:	This will set the error message to "error" attribute in the
#		object and return -1 value.
#
#===============================================================================
sub setError ($) {
	my($self)	 = shift;
	my($errorMsg) = shift;
	$self->{'error'} = $errorMsg if $errorMsg !~ /^\s*$/;
	return -1;
}
#===============================================================================
#
# METHOD:	$obj->setMailBody($htmlbody, $plainbody);
#
# DESCRIPTION:	Set the mail body content.
#
#===============================================================================
sub setMailBody ($) {
	my($self)	  = shift;
	my($mailbody) = shift;
	$self->{'mailbody'} = $mailbody;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setMailHeader($mailheader, $mailheadervalue);
#
# DESCRIPTION:	This method is used for setting custom email headers.
#
#===============================================================================
sub setMailHeader ($$) {
	my($self)	  	 = shift;
	my($mailheader)	 = shift;
	my($mailheadervalue) = shift;
	$mailheader =~ tr/[a-z]/[A-Z]/;
	$self->{'mailheaders'}->{'OTHERS'}->{$mailheader} = $mailheadervalue;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setSMTPPort($smtpport);
#
# DESCRIPTION:	Set the SMTP port.
#
#===============================================================================
sub setSMTPPort ($) {
	my($self)	 = shift;
	my($smtpport) = shift;
	$self->{'smtpport'} = $smtpport if $smtpport =~ /^\d+$/;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->setSMTPServer($smtpserver);
#
# DESCRIPTION:	Set the SMTP server.
#
#===============================================================================
sub setSMTPServer ($) {
	my($self)	   = shift;
	my($smtpserver) = shift;
	$smtpserver =~ s/\s*//g;
	$self->{'smtpserver'} = $smtpserver if $smtpserver !~ /^\s*$/;
	return 0;
}
#===============================================================================
#
# METHOD:	$obj->version;
#
# DESCRIPTION:	Get the version of the module.
#
#===============================================================================
sub version () {
	my($self) = shift;
	return $ver;
}
#===============================================================================
#
# END of the module.
#
#===============================================================================
package Config::IniFiles;
$Config::IniFiles::VERSION = (qw($Revision: 2.39 $))[1];
require 5.004;
use strict;
use Carp;
use Symbol 'gensym','qualify_to_ref';   # For the 'any data type' hack
@Config::IniFiles::errors = ( );
sub new {
  my $class = shift;
  my %parms = @_;
  my $errs = 0;
  my @groups = ( );
  my $self		   = {};
  # Set config file to default value, which is nothing
  $self->{cf}		= undef;
  if( ref($parms{-import}) && ($parms{-import}->isa('Config::IniFiles')) ) {
	# Import from the import object by COPYing, so we
	# don't clobber the old object
	%{$self} = %{$parms{-import}};
  } else {
	$self->{firstload} = 1;
	$self->{default}   = '';
	$self->{imported}  = [];
	if( defined $parms{-import} ) {
	  carp "Invalid -import value \"$parms{-import}\" was ignored.";
	  delete $parms{-import};
	} # end if
  } # end if
  # Copy the original parameters so we
  # can use them when we build new sections
  %{$self->{startup_settings}} = %parms;
  # Parse options
  my($k, $v);
  local $_;
  $self->{nocase} = 0;
  $self->{allowcode} = 1;
  # Handle known parameters first in this order,
  # because each() could return parameters in any order
  if (defined ($v = delete $parms{'-import'})) {
	# Store the imported object's file parameter for reload
	if( $self->{cf} ) {
		push( @{$self->{imported}}, $self->{cf} );
	} else {
		push( @{$self->{imported}}, "<Un-named file>" );
	} # end if
  }
  if (defined ($v = delete $parms{'-file'})) {
	# Should we be pedantic and check that the file exists?
	# .. no, because now it could be a handle, IO:: object or something else
	$self->{cf} = $v;
  }
  if (defined ($v = delete $parms{'-default'})) {
	$self->{default} = $v;
  }
  if (defined ($v = delete $parms{'-nocase'})) {
	$self->{nocase} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-reloadwarn'})) {
	$self->{reloadwarn} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-allowcontinue'})) {
	$self->{allowcontinue} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-allowcode'})) {
	$self->{allowcode} = $v ? 1 : 0;
  }
  if (defined ($v = delete $parms{'-commentchar'})) {
	if(!defined $v || length($v) != 1) {
	  carp "Comment character must be unique.";
	  $errs++;
	}
	elsif($v =~ /[\[\]=\w]/) {
	  # must not be square bracket, equal sign or alphanumeric
	  carp "Illegal comment character.";
	  $errs++;
	}
	else {
	  $self->{comment_char} = $v;
	}
  }
  if (defined ($v = delete $parms{'-allowedcommentchars'})) {
	# must not be square bracket, equal sign or alphanumeric
	if(!defined $v || $v =~ /[\[\]=\w]/) {
	  carp "Illegal value for -allowedcommentchars.";
	  $errs++;
	}
	else {
	  $self->{comment_char} = $v;
	}
  }
  $self->{comment_char} = '#' unless exists $self->{comment_char};
  $self->{allowed_comment_char} = ';' unless exists $self->{allowed_comment_char};
  # make sure that comment character is always allowed
  $self->{allowed_comment_char} .= $self->{comment_char};
  # Any other parameters are unkown
  while (($k, $v) = each %parms) {
	carp "Unknown named parameter $k=>$v";
	$errs++;
  }
  return undef if $errs;
  bless $self, $class;
  # No config file specified, so everything's okay so far.
  if (not defined $self->{cf}) {
	return $self;
  }
  if ($self->ReadConfig) {
	return $self;
  } else {
	return undef;
  }
}
###########################################
#
# eval perl hooks in Inifile values
# GCARLS 04/29/2005
sub eval_if_perl {
###########################################
	my($self, $value) = @_;
	if(my $cref = $self->compile_if_perl($value)) {
		return $cref->();
	}
	return $value;
}
###########################################
#
# compile perl-hooks in Inifile values
# GCARLS 04/29/2005
sub compile_if_perl {
###########################################
	my($self, $value) = @_;
	if(defined $value && $value =~ /^\s*sub\s*{/ ) {
		my $mask;
		unless( $self->{allowcode} ) {
			die "-allowcode => 0 setting " .
				"prohibits Perl code in ini file";
		}
		if( $self->{allowcode} == 1 ) {
			# eval without restriction
			my $cref = eval "package main; $value" or
				die "Can't evaluate '$value' ($@)";
			return $cref;
		}
		else {
			die "Invalid value for -allowcode in __PACKAGE__ initialisation";
		}
	}
	return undef;
}
sub val {
  my ($self, $sect, $parm, $def) = @_;
  my ($elem, @ary);
  # Always return undef on bad parameters
  return undef if not defined $sect;
  return undef if not defined $parm;
  if ($self->{nocase}) {
	$sect = lc($sect);
	$parm = lc($parm);
  }
  my $val = defined($self->{v}{$sect}{$parm}) ?
	$self->{v}{$sect}{$parm} :
	$self->{v}{$self->{default}}{$parm};
  # If the value is undef, make it $def instead (which could just be undef)
  $val = $def unless defined $val;
  # Return the value in the desired context
  if (wantarray and ref($val) eq "ARRAY") {
	# GCARLS 04/29/2005
	@ary=@$val; # save original values (probably perl code)
	foreach $elem ( @ary ) {
	  $elem=$self->eval_if_perl($elem);
	}
	return @ary;
  } elsif (ref($val) eq "ARRAY") {
  	# GCARLS 04/29/2005:
  	@ary=@$val;
  	foreach $elem ( @ary ) {
		   $elem=$self->eval_if_perl($elem);
		}
  	if (defined ($/)) {
		return join "$/", @ary;
	} else {
		return join "\n", @ary;
	}
  } else {
	return $self->eval_if_perl($val);
  }
}
sub setval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  my @val  = @_;
  return undef if not defined $sect;
  return undef if not defined $parm;
# tom@ytram.com +
  if ($self->{nocase}) {
	$sect = lc($sect);
	$parm = lc($parm);
  }
# tom@ytram.com -
  if (defined($self->{v}{$sect}{$parm})) {
	if (@val > 1) {
	  $self->{v}{$sect}{$parm} = \@val;
	  $self->{EOT}{$sect}{$parm} = 'EOT';
	} else {
	  $self->{v}{$sect}{$parm} = shift @val;
	}
	return 1;
  } else {
	return undef;
  }
}
sub newval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  my @val  = @_;
  return undef if not defined $sect;
  return undef if not defined $parm;
# tom@ytram.com +
  if ($self->{nocase}) {
	$sect = lc($sect);
	$parm = lc($parm);
  }
# tom@ytram.com -
	$self->AddSection($sect);
	push(@{$self->{parms}{$sect}}, $parm)
	  unless (grep {/^\Q$parm\E$/} @{$self->{parms}{$sect}} );
  if (@val > 1) {
	$self->{v}{$sect}{$parm} = \@val;
	$self->{EOT}{$sect}{$parm} = 'EOT' unless defined
				$self->{EOT}{$sect}{$parm};
  } else {
	$self->{v}{$sect}{$parm} = shift @val;
  }
  return 1
}
sub delval {
  my $self = shift;
  my $sect = shift;
  my $parm = shift;
  return undef if not defined $sect;
  return undef if not defined $parm;
# tom@ytram.com +
  if ($self->{nocase}) {
	$sect = lc($sect);
	$parm = lc($parm);
  }
# tom@ytram.com -
	@{$self->{parms}{$sect}} = grep !/^\Q$parm\E$/, @{$self->{parms}{$sect}};
	delete $self->{v}{$sect}{$parm};
	return 1
}
sub ReadConfig {
  my $self = shift;
  my($lineno, $sect);
  my($group, $groupmem);
  my($parm, $val);
  my @cmts;
  my %loaded_params = ();			# A has to remember which params are loaded vs. imported
  @Config::IniFiles::errors = ( );
  # Initialize (and clear out) storage hashes
  # unless we imported them from another file [JW]
  if( @{$self->{imported}} ) {
	  #
	  # Run up the import tree to the top, then reload coming
	  # back down, maintaining the imported file names and our
	  # file name.
	  # This is only needed on a re-load though
	  unless( $self->{firstload} ) {
		my $cf = $self->{cf};
		$self->{cf} = pop @{$self->{imported}};
		$self->ReadConfig;
		push @{$self->{imported}}, $self->{cf};
		$self->{cf} = $cf;
	  } # end unless
  } else {
	  $self->{sects}  = [];		# Sections
	  $self->{group}  = {};		# Subsection lists
	  $self->{v}	  = {};		# Parameter values
	  $self->{sCMT}   = {};		# Comments above section
  } # end if
  return undef if (
	(not exists $self->{cf}) or
	(not defined $self->{cf}) or
	($self->{cf} eq '')
  );
  my $nocase = $self->{nocase};
  # If this is a reload and we want warnings then send one to the STDERR log
  unless( $self->{firstload} || !$self->{reloadwarn} ) {
	my ($ss, $mm, $hh, $DD, $MM, $YY) = (localtime(time))[0..5];
	printf STDERR
	  "PID %d reloading config file %s at %d.%02d.%02d %02d:%02d:%02d\n",
	  $$, $self->{cf}, $YY+1900, $MM+1, $DD, $hh, $mm, $ss;
  }
  # Turn off. Future loads are reloads
  $self->{firstload} = 0;
  # Get a filehandle, allowing almost any type of 'file' parameter
  my $fh = $self->_make_filehandle( $self->{cf} );
  if (!$fh) {
	carp "Failed to open $self->{cf}: $!";
	return undef;
  }
  # Get mod time of file so we can retain it (if not from STDIN)
  my @stats = stat $fh;
  $self->{file_mode} = sprintf("%04o", $stats[2]) if defined $stats[2];
  # Get the entire file into memory (let's hope it's small!)
  local $_;
  my @lines = split /\015\012?|\012|\025|\n/, join( '', <$fh>);
  # Only close if this is a filename, if it's
  # an open handle, then just roll back to the start
  if( !ref($fh) ) {
	close($fh);
  } else {
	# But we can't roll back STDIN so skip that one
	if( $fh != 0 ) {
	  seek( $fh, 0, 0 );
	} # end if
  } # end if
  # If there's a UTF BOM (Byte-Order-Mark) in the first character of the first line
  # then remove it before processing (http://www.unicode.org/unicode/faq/utf_bom.html#22)
  ($lines[0] =~ s/^ï»¿//);
# Disabled the utf8 one for now (JW) because it doesn't work on all perl distros
# e.g. 5.6.1 works with or w/o 'use utf8' 5.6.0 fails w/o it. 5.005_03
# says "invalid hex value", etc. If anyone has a clue how to make this work
# please let me know!
#  ($lines[0] =~ s/^ï»¿//) || (eval('use utf8; $lines[0] =~ s/^\x{FEFF}//;'));
#  $@ = ''; $! = undef;  # Clear any error messages
  # The first lines of the file must be blank, comments or start with [
  my $first = '';
  my $allCmt = $self->{allowed_comment_char};
  foreach ( @lines ) {
	next if /^\s*$/;	# ignore blank lines
	next if /^\s*[$allCmt]/;	# ignore comments
	$first = $_;
	last;
  }
  unless( $first =~ /^\s*\[/ ) {
	return undef;
  }
  # Store what our line ending char was for output
  ($self->{line_ends}) = $lines[0] =~ /([\015\012\025\n]+)/;
  while ( @lines ) {
	$_ = shift @lines;
	s/(\015\012?|\012|\025|\n)$//;				# remove line ending char(s)
	$lineno++;
	if (/^\s*$/) {				# ignore blank lines
	  next;
	}
	elsif (/^\s*[$allCmt]/) {			# collect comments
	  push(@cmts, $_);
	  next;
	}
	elsif (/^\s*\[\s*(\S|\S.*\S)\s*\]\s*$/) {		# New Section
	  $sect = $1;
	  if ($self->{nocase}) {
		$sect = lc($sect);
	  }
	  $self->AddSection($sect);
	  $self->SetSectionComment($sect, @cmts);
	  @cmts = ();
	}
	elsif (($parm, $val) = /^\s*([^=]*?[^=\s])\s*=\s*(.*)$/) {	# new parameter
	  $parm = lc($parm) if $nocase;
	  $self->{pCMT}{$sect}{$parm} = [@cmts];
	  @cmts = ( );
	  if ($val =~ /^<<(.*)$/) {			# "here" value
	my $eotmark  = $1;
	my $foundeot = 0;
	my $startline = $lineno;
	my @val = ( );
	while ( @lines ) {
	  $_ = shift @lines;
	  s/(\015\012?|\012|\025|\n)$//;				# remove line ending char(s)
	  $lineno++;
	  if ($_ eq $eotmark) {
		$foundeot = 1;
		last;
	  } else {
		push(@val, $_);
	  }
	}
	if ($foundeot) {
		if (exists $self->{v}{$sect}{$parm} &&
			exists $loaded_params{$sect} &&
			grep( /^\Q$parm\E$/, @{$loaded_params{$sect}}) ) {
		  if (ref($self->{v}{$sect}{$parm}) eq "ARRAY") {
			# Add to the array
			push @{$self->{v}{$sect}{$parm}}, @val;
		  } else {
			# Create array
			my $old_value = $self->{v}{$sect}{$parm};
			my @new_value = ($old_value, @val);
			$self->{v}{$sect}{$parm} = \@new_value;
		  }
		} else {
		$self->{v}{$sect}{$parm} = \@val;
		$loaded_params{$sect} = [] unless $loaded_params{$sect};
		push @{$loaded_params{$sect}}, $parm;
		}
		$self->{EOT}{$sect}{$parm} = $eotmark;
	} else {
	  push(@Config::IniFiles::errors, sprintf('%d: %s', $startline,
				  qq#no end marker ("$eotmark") found#));
	}
	  } else { # no here value
		# process continuation lines, if any
		while($self->{allowcontinue} && $val =~ s/\\$//) {
		  $_ = shift @lines;
	  s/(\015\012?|\012|\025|\n)$//; # remove line ending char(s)
	  $lineno++;
		  $val .= $_;
		}
		# Now load value
	if (exists $self->{v}{$sect}{$parm} &&
		exists $loaded_params{$sect} &&
		grep( /^\Q$parm\E$/, @{$loaded_params{$sect}}) ) {
		if (ref($self->{v}{$sect}{$parm}) eq "ARRAY") {
		# Add to the array
		push @{$self->{v}{$sect}{$parm}}, $val;
		} else {
		# Create array
		my $old_value = $self->{v}{$sect}{$parm};
		my @new_value = ($old_value, $val);
		$self->{v}{$sect}{$parm} = \@new_value;
		}
	} else {
		$self->{v}{$sect}{$parm} = $val;
		$loaded_params{$sect} = [] unless $loaded_params{$sect};
		push @{$loaded_params{$sect}}, $parm;
	}
	  }
	  push(@{$self->{parms}{$sect}}, $parm) unless grep(/^\Q$parm\E$/, @{$self->{parms}{$sect}});
	}
	else {
	  push(@Config::IniFiles::errors, sprintf("Line \%d in file " . $self->{cf} . " is mal-formed:\n\t\%s", $lineno, $_));
	}
  }
  #
  # Now convert all the parameter hashes into tied hashes.
  # This is in all uses, because it must be part of ReadConfig.
  #
  my %parms = %{$self->{startup_settings}};
  if( defined $parms{-default} ) {
	# If the default section doesn't exists, create it.
	unless( defined $self->{v}{$parms{-default}} ) {
	  $self->{v}{$parms{-default}} = {};
	  push(@{$self->{sects}}, $parms{-default}) unless (grep /^\Q$parms{-default}\E$/, @{$self->{sects}});
	  $self->{parms}{$parms{-default}} = [];
	} # end unless
	$parms{-default} = $self->{v}{$parms{-default}};
  } # end if
  foreach( keys %{$self->{v}} ) {
	$parms{-_current_value} = $self->{v}{$_};
	$parms{-parms} = $self->{parms}{$_};
	$self->{v}{$_} = {};
	# Add a reference to our {parms} hash for each section
	tie %{$self->{v}{$_}}, 'Config::IniFiles::_section', %parms
  } # end foreach
  @Config::IniFiles::errors ? undef : 1;
}
sub Sections {
  my $self = shift;
  return @{$self->{sects}} if ref $self->{sects} eq 'ARRAY';
  return ();
}
sub SectionExists {
	my $self = shift;
	my $sect = shift;
	return undef if not defined $sect;
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	return undef() if not defined $sect;
	return 1 if (grep {/^\Q$sect\E$/} @{$self->{sects}});
	return 0;
}
sub AddSection {
	my $self = shift;
	my $sect = shift;
	return undef if not defined $sect;
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	return if $self->SectionExists($sect);
	push @{$self->{sects}}, $sect;
	$self->SetGroupMember($sect);
	# Set up the parameter names and values lists
	$self->{parms}{$sect} = [] unless ref $self->{parms}{$sect} eq 'ARRAY';
	if (!defined($self->{v}{$sect})) {
		$self->{sCMT}{$sect} = [];
		$self->{pCMT}{$sect} = {};		# Comments above parameters
		$self->{parms}{$sect} = [];
		$self->{v}{$sect} = {};
	}
}
sub DeleteSection {
	my $self = shift;
	my $sect = shift;
	return undef if not defined $sect;
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	# This is done, the fast way, change if delval changes!!
	delete $self->{v}{$sect};
	delete $self->{sCMT}{$sect};
	delete $self->{pCMT}{$sect};
	delete $self->{EOT}{$sect};
	delete $self->{parms}{$sect};
	@{$self->{sects}} = grep !/^\Q$sect\E$/, @{$self->{sects}};
	if( $sect =~ /^(\S+)\s+\S+/ ) {
		my $group = $1;
		if( defined($self->{group}{$group}) ) {
			@{$self->{group}{$group}} = grep !/^\Q$sect\E$/, @{$self->{group}{$group}};
		} # end if
	} # end if
	return 1;
} # end DeleteSection
sub Parameters {
  my $self = shift;
  my $sect = shift;
  return undef if not defined $sect;
  if ($self->{nocase}) {
	$sect = lc($sect);
  }
  return @{$self->{parms}{$sect}} if ref $self->{parms}{$sect} eq 'ARRAY';
  return ();
}
sub Groups	{
  my $self = shift;
  return keys %{$self->{group}} if ref $self->{group} eq 'HASH';
  return ();
}
sub SetGroupMember {
	my $self = shift;
	my $sect = shift;
	return undef if not defined $sect;
	return(1) unless $sect =~ /^(\S+)\s+\S+/;
	my $group = $1;
	if (not exists($self->{group}{$group})) {
		$self->{group}{$group} = [];
	}
	if (not grep {/^\Q$sect\E$/} @{$self->{group}{$group}}) {
		push @{$self->{group}{$group}}, $sect;
	}
}
sub RemoveGroupMember {
	my $self = shift;
	my $sect = shift;
	return undef if not defined $sect;
	return(1) unless $sect =~ /^(\S+)\s+\S+/;
	my $group = $1;
	return unless exists $self->{group}{$group};
	@{$self->{group}{$group}} = grep {!/^\Q$sect\E$/} @{$self->{group}{$group}};
}
sub GroupMembers {
  my $self  = shift;
  my $group = shift;
  return undef if not defined $group;
  if ($self->{nocase}) {
  	$group = lc($group);
  }
  return @{$self->{group}{$group}} if ref $self->{group}{$group} eq 'ARRAY';
  return ();
}
sub SetWriteMode
{
	my $self = shift;
	my $mode = shift;
	return undef if not defined ($mode);
	return undef if not ($mode =~ m/[0-7]{3,3}/);
	$self->{file_mode} = $mode;
	return $mode;
}
sub GetWriteMode
{
	my $self = shift;
	return undef if not exists $self->{file_mode};
	return $self->{file_mode};
}
sub WriteConfig {
  my $self = shift;
  my $file = shift;
  return undef unless defined $file;
  # If we are using a filename, then do mode checks and write to a
  # temporary file to avoid a race condition
  if( !ref($file) ) {
	if (-e $file) {
		  if (not (-w $file))
		  {
				  #carp "File $file is not writable.  Refusing to write config";
				  return undef;
		  }
		  my $mode = (stat $file)[2];
		  $self->{file_mode} = sprintf "%04o", ($mode & 0777);
		  #carp "Using mode $self->{file_mode} for file $file";
	} elsif (defined($self->{file_mode}) and not (oct($self->{file_mode}) & 0222)) {
		  #carp "Store mode $self->{file_mode} prohibits writing config";
	}
	my $new_file = $file . "-new";
	local(*F);
	open(F, "> $new_file") || do {
	  carp "Unable to write temp config file $new_file: $!";
	  return undef;
	};
	my $oldfh = select(F);
	$self->OutputConfig;
	close(F);
	select($oldfh);
	rename( $new_file, $file ) || do {
	  carp "Unable to rename temp config file ($new_file) to $file: $!";
	  return undef;
	};
	if (exists $self->{file_mode}) {
	  chmod oct($self->{file_mode}), $file;
	}
  } # Otherwise, reset to the start of the file and write, unless we are using STDIN
  else {
	# Get a filehandle, allowing almost any type of 'file' parameter
	## NB: If this were a filename, this would fail because _make_file
	##	 opens a read-only handle, but we have already checked that case
	##	 so re-using the logic is ok [JW/WADG]
	my $fh = $self->_make_filehandle( $file );
	if (!$fh) {
	  carp "Could not find a filehandle for the input stream ($file): $!";
	  return undef;
	}
	# Only roll back if it's not STDIN (if it is, Carp)
	if( $fh == 0 ) {
	  carp "Cannot write configuration file to STDIN.";
	} else {
	  seek( $fh, 0, 0 );
	  my $oldfh = select($fh);
	  $self->OutputConfig;
	  seek( $fh, 0, 0 );
	  select($oldfh);
	} # end if
  } # end if (filehandle/name)
  return 1;
}
sub RewriteConfig {
  my $self = shift;
  return undef if (
	(not exists $self->{cf}) or
	(not defined $self->{cf}) or
	($self->{cf} eq '')
  );
  # Return whatever WriteConfig returns :)
  $self->WriteConfig($self->{cf});
}
sub GetFileName
{
	my $self = shift;
	my $filename;
	if (exists $self->{cf}) {
		$filename = $self->{cf};
	} else {
		undef $filename;
	}
	return $filename;
}
sub SetFileName {
  my $self = shift;
  my $newfile = shift;
  return undef if not defined $newfile;
  if ($newfile ne "") {
	$self->{cf} = $newfile;
	return $self->{cf};
  }
  return undef;
}
sub OutputConfig {
  my $self = shift;
  my($sect, $parm, @cmts);
  my $ors = $self->{line_ends} || $\ || "\n";		# $\ is normally unset, but use input by default
  my $notfirst = 0;
  local $_;
  foreach $sect (@{$self->{sects}}) {
	next unless defined $self->{v}{$sect};
	print $ors if $notfirst;
	$notfirst = 1;
	if ((ref($self->{sCMT}{$sect}) eq 'ARRAY') &&
	(@cmts = @{$self->{sCMT}{$sect}})) {
	  foreach (@cmts) {
	print "$_$ors";
	  }
	}
	print "[$sect]$ors";
	next unless ref $self->{v}{$sect} eq 'HASH';
	foreach $parm (@{$self->{parms}{$sect}}) {
	  if ((ref($self->{pCMT}{$sect}{$parm}) eq 'ARRAY') &&
	  (@cmts = @{$self->{pCMT}{$sect}{$parm}})) {
	foreach (@cmts) {
	  print "$_$ors";
	}
	  }
	  my $val = $self->{v}{$sect}{$parm};
	  next if ! defined ($val);	# No parameter exists !!
	  if (ref($val) eq 'ARRAY') {
		my $eotmark = $self->{EOT}{$sect}{$parm} || 'EOT';
	print "$parm= <<$eotmark$ors";
	foreach (@{$val}) {
	  print "$_$ors";
	}
	print "$eotmark$ors";
	  } elsif( $val =~ /[$ors]/ ) {
		# The FETCH of a tied hash is never called in
		# an array context, so generate a EOT multiline
		# entry if the entry looks to be multiline
		my @val = split /[$ors]/, $val;
		if( @val > 1 ) {
		  my $eotmark = $self->{EOT}{$sect}{$parm} || 'EOT';
		  print "$parm= <<$eotmark$ors";
		  print map "$_$ors", @val;
		  print "$eotmark$ors";
		} else {
		   print "$parm=$val[0]$ors";
		} # end if
	  } else {
		print "$parm=$val$ors";
	  }
	}
  }
  return 1;
}
sub SetSectionComment
{
	my $self = shift;
	my $sect = shift;
	my @comment = @_;
	return undef if not defined $sect;
	return undef unless @comment;
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	$self->{sCMT}{$sect} = [];
	# At this point it's possible to have a comment for a section that
	# doesn't exist. This comment will not get written to the INI file.
	push @{$self->{sCMT}{$sect}}, $self->_markup_comments(@comment);
	return scalar @comment;
}
# this helper makes sure that each line is preceded with the correct comment
# character
sub _markup_comments
{
  my $self = shift;
  my @comment = @_;
  my $allCmt = $self->{allowed_comment_char};
  my $cmtChr = $self->{comment_char};
  foreach (@comment) {
	m/^\s*[$allCmt]/ or ($_ = "$cmtChr $_");
  }
  @comment;
}
sub GetSectionComment
{
	my $self = shift;
	my $sect = shift;
	return undef if not defined $sect;
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	if (exists $self->{sCMT}{$sect}) {
		return @{$self->{sCMT}{$sect}};
	} else {
		return undef;
	}
}
sub DeleteSectionComment
{
	my $self = shift;
	my $sect = shift;
	return undef if not defined $sect;
	if ($self->{nocase}) {
		$sect = lc($sect);
	}
	delete $self->{sCMT}{$sect};
}
sub SetParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	my @comment = @_;
	defined($sect) || return undef;
	defined($parm) || return undef;
	@comment || return undef;
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	}
	if (not exists $self->{pCMT}{$sect}) {
		$self->{pCMT}{$sect} = {};
	}
	$self->{pCMT}{$sect}{$parm} = [];
	# Note that at this point, it's possible to have a comment for a parameter,
	# without that parameter actually existing in the INI file.
	push @{$self->{pCMT}{$sect}{$parm}}, $self->_markup_comments(@comment);
	return scalar @comment;
}
sub GetParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	defined($sect) || return undef;
	defined($parm) || return undef;
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};
	exists($self->{pCMT}{$sect}) || return undef;
	exists($self->{pCMT}{$sect}{$parm}) || return undef;
	my @comment = @{$self->{pCMT}{$sect}{$parm}};
	return (wantarray)?@comment:join " ", @comment;
}
sub DeleteParameterComment
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	defined($sect) || return undef;
	defined($parm) || return undef;
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};
	# If the parameter doesn't exist, our goal has already been achieved
	exists($self->{pCMT}{$sect}) || return 1;
	exists($self->{pCMT}{$sect}{$parm}) || return 1;
	delete $self->{pCMT}{$sect}{$parm};
	return 1;
}
sub GetParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	defined($sect) || return undef;
	defined($parm) || return undef;
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};
	if (not exists $self->{EOT}{$sect}) {
		$self->{EOT}{$sect} = {};
	}
	if (not exists $self->{EOT}{$sect}{$parm}) {
		return undef;
	}
	return $self->{EOT}{$sect}{$parm};
}
sub SetParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	my $EOT = shift;
	defined($sect) || return undef;
	defined($parm) || return undef;
	defined($EOT) || return undef;
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	};
	if (not exists $self->{EOT}{$sect}) {
		$self->{EOT}{$sect} = {};
	}
	$self->{EOT}{$sect}{$parm} = $EOT;
}
sub DeleteParameterEOT
{
	my $self = shift;
	my $sect = shift;
	my $parm = shift;
	defined($sect) || return undef;
	defined($parm) || return undef;
	if ($self->{nocase}) {
		$sect = lc($sect);
		$parm = lc($parm);
	}
	delete $self->{EOT}{$sect}{$parm};
}
sub Delete {
	my $self = shift;
	# Again, done the fast way, if the data structure changes, change this!
	$self->{sects}  = [];
	$self->{parms}  = {};
	$self->{group}  = {};
	$self->{v}	  = {};
	$self->{sCMT}   = {};
	$self->{pCMT}   = {};
	$self->{EOT}	= {};
	return 1;
} # end Delete
############################################################
#
# TIEHASH Methods
#
# Description:
# These methods allow you to tie a hash to the
# Config::IniFiles object. Note that, when tied, the
# user wants to look at thinks like $ini{sec}{parm}, but the
# TIEHASH only provides one level of hash interace, so the
# root object gets asked for a $ini{sec}, which this
# implements. To further tie the {parm} hash, the internal
# class Config::IniFiles::_section, is provided, below.
#
############################################################
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000May09 Created method								JW
# ----------------------------------------------------------
sub TIEHASH {
  my $class = shift;
  my %parms = @_;
  # Get a new object
  my $self = $class->new( %parms );
  return $self;
} # end TIEHASH
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000May09 Created method								JW
# ----------------------------------------------------------
sub FETCH {
  my $self = shift;
  my( $key ) = @_;
  $key = lc($key) if( $self->{nocase} );
  return $self->{v}{$key};
} # end FETCH
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000Jun14 Fixed bug where wrong ref was saved		   JW
# 2000Oct09 Fixed possible but in %parms with defaults	JW
# 2001Apr04 Fixed -nocase problem in storing			  JW
# ----------------------------------------------------------
sub STORE {
  my $self = shift;
  my( $key, $ref ) = @_;
  return undef unless ref($ref) eq 'HASH';
  $key = lc($key) if( $self->{nocase} );
  # Create a new hash and tie it to a _sections object with the ref's data
  $self->{v}{$key} = {};
  # Store the section name in the list
  push(@{$self->{sects}}, $key) unless (grep {/^\Q$key\E$/} @{$self->{sects}});
  my %parms = %{$self->{startup_settings}};
  $self->{parms}{$key} = [];
  $parms{-parms} = $self->{parms}{$key};
  $parms{-_current_value} = $ref;
  delete $parms{default};
  $parms{-default} = $self->{v}{$parms{-default}} if defined $parms{-default} && defined $self->{v}{$parms{-default}};
  tie %{$self->{v}{$key}}, 'Config::IniFiles::_section', %parms;
} # end STORE
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000May09 Created method								JW
# 2000Dec17 Now removes comments, groups and EOTs too	 JW
# 2001Arp04 Fixed -nocase problem						 JW
# ----------------------------------------------------------
sub DELETE {
  my $self = shift;
  my( $key ) = @_;
  $key = lc($key) if( $self->{nocase} );
  delete $self->{sCMT}{$key};
  delete $self->{pCMT}{$key};
  delete $self->{EOT}{$key};
  delete $self->{parms}{$key};
  if( $key =~ /(\S+)\s+\S+/ ) {
	my $group = $1;
	if( defined($self->{group}{$group}) ) {
	  @{$self->{group}{$group}} = grep !/\Q$key\E/, @{$self->{group}{$group}};
	} # end if
  } # end if
  @{$self->{sects}} = grep !/^\Q$key\E$/, @{$self->{sects}};
  return delete( $self->{v}{$key} );
} # end DELETE
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000May09 Created method								JW
# ----------------------------------------------------------
sub CLEAR {
  my $self = shift;
  foreach (keys %{$self->{v}}) {
	 $self->DELETE( $_ );
  } # end foreach
} # end CLEAR
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000May09 Created method								JW
# ----------------------------------------------------------
sub FIRSTKEY {
  my $self = shift;
  my $a = keys %{$self->{v}};
  return each %{$self->{v}};
} # end FIRSTKEY
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000May09 Created method								JW
# ----------------------------------------------------------
sub NEXTKEY {
  my $self = shift;
  my( $last ) = @_;
  return each %{$self->{v}};
} # end NEXTKEY
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000May09 Created method								JW
# 2001Apr04 Fixed -nocase bug and false true bug		  JW
# ----------------------------------------------------------
sub EXISTS {
  my $self = shift;
  my( $key ) = @_;
  $key = lc($key) if( $self->{nocase} );
  return exists $self->{v}{$key};
} # end EXISTS
# ----------------------------------------------------------
# DESTROY is used by TIEHASH and the Perl garbage collector,
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000May09 Created method								JW
# ----------------------------------------------------------
sub DESTROY {
  # my $self = shift;
} # end if
# ----------------------------------------------------------
# Sub: _make_filehandle
#
# Args: $thing
#	$thing	An input source
#
# Description: Takes an input source of a filehandle,
# filehandle glob, reference to a filehandle glob, IO::File
# object or scalar filename and returns a file handle to
# read from it with.
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 06Dec2001 Added to support input from any source		JW
# ----------------------------------------------------------
sub _make_filehandle {
  my $self = shift;
  #
  # This code is 'borrowed' from Lincoln D. Stein's GD.pm module
  # with modification for this module. Thanks Lincoln!
  #
  no strict 'refs';
  my $thing = shift;
  return $thing if defined(fileno $thing);
#  return $thing if defined($thing) && ref($thing) && defined(fileno $thing);
  # otherwise try qualifying it into caller's package
  my $fh = qualify_to_ref($thing,caller(1));
  return $fh if defined(fileno $fh);
#  return $fh if defined($thing) && ref($thing) && defined(fileno $fh);
  # otherwise treat it as a file to open
  $fh = gensym;
  open($fh,$thing) || return;

  return $fh;
} # end _make_filehandle
############################################################
#
# INTERNAL PACKAGE: Config::IniFiles::_section
#
# Description:
# This package is used to provide a single-level TIEHASH
# interface to the sections in the IniFile. When tied, the
# user wants to look at thinks like $ini{sec}{parm}, but the
# TIEHASH only provides one level of hash interace, so the
# root object gets asked for a $ini{sec} and must return a
# has reference that accurately covers the '{parm}' part.
#
# This package is only used when tied and is inter-woven
# between the sections and their parameters when the TIEHASH
# method is called by Perl. It's a very simple implementation
# of a tied hash object with support for the Config::IniFiles
# -nocase and -default options.
#
############################################################
# Date		Modification							Author
# ----------------------------------------------------------
# 2000.May.09 Created to excapsulate TIEHASH interface	JW
############################################################
package Config::IniFiles::_section;
use strict;
use Carp;
use vars qw( $VERSION );
$Config::IniFiles::_section::VERSION = 2.16;
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::TIEHASH
#
# Args: $class, %parms
#	$class	The class that this is being tied to.
#	%parms   Contains named parameters passed from the
#		   constructor plus thes parameters
#	-_current_value	holds the values to be inserted in the hash.
#	-default	should be a hash ref.
#	-parms  	reference to the $self->{parms}{$sect} of the parent
#
# Description: Builds the object that gets tied to the
# sections name. Inserts the existing hash, defined in the
# named parameter '-_current_value' into the tied hash.
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub TIEHASH {
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my %parms = @_;
  # Make a new object
  my $self = {};
  # Put the passed hash into the holder
  $self->{v} = $parms{-_current_value};
  # Get all other the parms, removing leading '-', if any
  # Option checking is already handled in the Config::IniFiles contructor
  foreach( keys %parms ) {
	s/^-//g;
	$self->{$_} = $parms{-$_};
  } # end foreach
  return bless( $self, $class );
} # end TIEHASH
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::FETCH
#
# Args: $key
#	$key	The name of the key whose value to get
#
# Description: Returns the value associated with $key. If
# the value is a hash, returns a hashref, just like normal
# Perl hashes.
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2000Jun15 Fixed bugs in -default handler				JW
# 2000Dec07 Fixed another bug in -deault handler		  JW
# 2002Jul04 Returning scalar values (Bug:447532)		  AS
# ----------------------------------------------------------
sub FETCH {
  my $self = shift;
  my $key = shift;
  $key = lc($key) if( $self->{nocase} );
  my $val = $self->{v}{$key};
   unless( defined $self->{v}{$key} ) {
	$val = $self->{default}{$key} if ref($self->{default}) eq 'HASH';
  } # end unless
  return $val;
} # end FETCH
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::STORE
#
# Args: $key, @val
#	$key	The key under which to store the value
#	@val	The value to store, either an array or a scalar
#
# Description: Sets the value for the specified $key
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug							 JW
# ----------------------------------------------------------
sub STORE {
  my $self = shift;
  my $key = shift;
  my @val = @_;
  $key = lc($key) if( $self->{nocase} );
  # Add the parameter the the parent's list if it isn't there yet
  push(@{$self->{parms}}, $key) unless (grep /^\Q$key\E$/, @{$self->{parms}});
  if (@val > 1) {
	$self->{v}{$key} = @val;
  } else {
	$self->{v}{$key} = shift @val;
  }
  return $self->{v}{$key};
} # end STORE
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::DELETE
#
# Args: $key
#	$key	The key to remove from the hash
#
# Description: Removes the specified key from the hash
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug							  JW
# ----------------------------------------------------------
sub DELETE   {
  my $self = shift;
  my $key = shift;
  $key = lc($key) if( $self->{nocase} );
#	@{$self->{parms}{$sect}} = grep !/^$parm$/, @{$self->{parms}{$sect}};
  return delete $self->{v}{$key};
} # end DELETE
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::CLEAR
#
# Args: (None)
#
# Description: Empties the entire hash
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub CLEAR	{
  my $self = shift;
  foreach ( keys %{$self->{v}}) {
	$self->DELETE($_);
  } # end foreach
  return $self;
} # end CLEAR
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::EXISTS
#
# Args: $key
#	$key	The key to look for
#
# Description: Returns whether the key exists
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# 2001Apr04 Fixed -nocase bug							 JW
# ----------------------------------------------------------
sub EXISTS   {
  my $self = shift;
  my $key = shift;
  $key = lc($key) if( $self->{nocase} );
  return exists $self->{v}{$key};
} # end EXISTS
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::FIRSTKEY
#
# Args: (None)
#
# Description: Returns the first key in the hash
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub FIRSTKEY {
  my $self = shift;
  # Reset the each() iterator
  my $a = keys %{$self->{v}};
  return each %{$self->{v}};
} # end FIRST KEY
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::NEXTKEY
#
# Args: $last
#	$last	The last key accessed by the interator
#
# Description: Returns the next key in line
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub NEXTKEY  {
  my $self = shift;
  my $last = shift;
  return each %{$self->{v}};
} # end NEXTKEY
# ----------------------------------------------------------
# Sub: Config::IniFiles::_section::DESTROY
#
# Args: (None)
#
# Description: Called on cleanup
# ----------------------------------------------------------
# Date	  Modification							  Author
# ----------------------------------------------------------
# ----------------------------------------------------------
sub DESTROY  {
  # my $self = shift
} # end DESTROY
# Eliminate annoying warnings
if ($^W)	{
	$Config::IniFiles::VERSION = $Config::IniFiles::VERSION;
};